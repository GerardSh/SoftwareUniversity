# General
## Application Flow
### Application Fundamentals
–£–µ–± –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è—Ç–∞ –æ–±—Ä–∞–±–æ—Ç–≤–∞—Ç –∑–∞—è–≤–∫–∏ –∏ –ø—Ä–æ–∏–∑–≤–µ–∂–¥–∞—Ç –æ—Ç–≥–æ–≤–æ—Ä–∏.

–¶–µ–ª–∏—è—Ç –ø—Ä–æ—Ü–µ—Å –µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–æ –ø–æ–¥—Ä–µ–¥–µ–Ω –≤ –Ω—è–∫–∞–∫—ä–≤ –≤–∏–¥ —Ç—Ä—ä–±–æ–ø—Ä–æ–≤–æ–¥ (pipeline). Pipeline-—ä—Ç –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–∞–Ω ‚Äì –∑–∞–ø–æ—á–≤–∞ —Å—ä—Å –∑–∞—è–≤–∫–∞ (request) –∏ –∑–∞–≤—ä—Ä—à–≤–∞ —Å –æ—Ç–≥–æ–≤–æ—Ä (response). –°–∞–º–∏—è—Ç —Ç—Ä—ä–±–æ–ø—Ä–æ–≤–æ–¥ –∏–º–∞ –∫—Ä–∞–Ω—á–µ—Ç–∞, –æ—Ç –∫–æ–∏—Ç–æ –∑–∞–ø–æ—á–≤–∞—Ç —Ä–∞–∑–∫–ª–æ–Ω–µ–Ω–∏—è. –ê–∫–æ —Ä–µ—à–∏–º, –º–æ–∂–µ–º –¥–∞ –æ—Ç–≤–æ—Ä–∏–º –¥–∞–¥–µ–Ω–æ –∫—Ä–∞–Ω—á–µ –∏ –¥–∞ –º–∏–Ω–µ–º –ø—Ä–µ–∑ –Ω–µ–≥–æ–≤–æ—Ç–æ —Ä–∞–∑–∫–ª–æ–Ω–µ–Ω–∏–µ, –∫–æ–µ—Ç–æ –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Å–µ –≤—Ä—ä—â–∞ –æ–±—Ä–∞—Ç–Ω–æ –Ω—è–∫—ä–¥–µ –≤ —Ç—Ä—ä–±–æ–ø—Ä–æ–≤–æ–¥–∞. 
–í ASP.NET Core **application flow-—ä—Ç** —Å–µ —Ä–µ–∞–ª–∏–∑–∏—Ä–∞ —á—Ä–µ–∑ **middleware pipeline**, –∫–æ–π—Ç–æ –º–æ–∂–µ–º –¥–∞ —Å–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏–º –∫–∞—Ç–æ —Ç—Ä—ä–±–æ–ø—Ä–æ–≤–æ–¥. Microsoft —Å–∞ —Å–µ –ø–æ–≥—Ä–∏–∂–∏–ª–∏ –¥–∞ –Ω–∏ –¥–∞–¥–∞—Ç **"–∫—Ä–∞–Ω—á–µ—Ç–∞"** (middleware hooks), –∫–æ–∏—Ç–æ –º–æ–∂–µ–º –¥–∞ ‚Äû–æ—Ç–≤—ä—Ä—Ç–∏–º‚Äú, –∑–∞ –¥–∞ –ø—Ä–µ—Ö–≤–∞–Ω–µ–º –∑–∞—è–≤–∫–∞—Ç–∞ –Ω–∞ —Ç–æ—á–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –º—è—Å—Ç–æ.

–°–ª–µ–¥ –∫–∞—Ç–æ ‚Äû–æ—Ç–≤—ä—Ä—Ç–∏–º –∫—Ä–∞–Ω—á–µ—Ç–æ‚Äú (—Ç.–µ. –¥–æ–±–∞–≤–∏–º —Å–æ–±—Å—Ç–≤–µ–Ω middleware), **–æ—Ç–≥–æ–≤–æ—Ä–Ω–æ—Å—Ç—Ç–∞ –µ –Ω–∞—à–∞** –¥–∞:

- –Ω–∞–ø—Ä–∞–≤–∏–º –∫–∞–∫–≤–æ—Ç–æ —Ç—Ä—è–±–≤–∞ —Å—ä—Å ‚Äû–∑–∞—è–≤–∫–∞—Ç–∞‚Äú (–≤–æ–¥–∞—Ç–∞).
- –µ–≤–µ–Ω—Ç—É–∞–ª–Ω–æ —è –ø—Ä–µ–Ω–∞—Å–æ—á–∏–º.
- –∏ –Ω–∞–π-–≤–∞–∂–Ω–æ—Ç–æ ‚Äì **–¥–∞ –∏–∑–≤–∏–∫–∞–º–µ `next()`**, –∑–∞ –¥–∞ –º–æ–∂–µ –∑–∞—è–≤–∫–∞—Ç–∞ –¥–∞ –ø—Ä–æ–¥—ä–ª–∂–∏ –ø–æ –æ—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç —Ç—Ä—ä–±–∞—Ç–∞.

–ê–∫–æ –Ω–µ –∏–∑–≤–∏–∫–∞–º–µ `next()`, –≤–æ–¥–∞—Ç–∞ –ø—Ä–æ—Å—Ç–æ –æ—Å—Ç–∞–≤–∞ –≤ –Ω–∞—à–µ—Ç–æ —Ä–∞–∑–∫–ª–æ–Ω–µ–Ω–∏–µ –∏ –Ω–µ —Å—Ç–∏–≥–∞ –¥–æ —Ñ–∏–Ω–∞–ª–∞ (–Ω—è–º–∞ –æ—Ç–≥–æ–≤–æ—Ä –∫—ä–º –∫–ª–∏–µ–Ω—Ç–∞). –û–±—Ä–∞–∑—ä—Ç —Å –≤–æ–¥–∞—Ç–∞ –∏ —Ç—Ä—ä–±–∏—Ç–µ –µ –ø–æ–ª–µ–∑–µ–Ω –∑–∞ —Ä–∞–∑–±–∏—Ä–∞–Ω–µ –∫–∞–∫ —Ä–∞–±–æ—Ç–∏ middleware –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞—Ç–∞ –≤ ASP.NET Core. 

–í –ø–æ–≤–µ—á–µ—Ç–æ —Å–ª—É—á–∞–∏ –ø—Ä–æ—Ü–µ—Å—ä—Ç –º–æ–∂–µ –¥–∞ –±—ä–¥–µ —Ä–∞–∑—à–∏—Ä—è–≤–∞–Ω –∏ –ø—Ä–æ–º–µ–Ω—è–Ω.

–£–µ–± –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è—Ç–∞ –∏–º–∞—Ç —Ä–∞–∑–ª–∏—á–Ω–∏ —Å—Ä–µ–¥–∏ –∑–∞ —Ä–∞–∑–≥—Ä—ä—â–∞–Ω–µ. –í –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç –æ—Ç —Ç–æ–≤–∞ –∫—ä–¥–µ —Å–µ –Ω–∞–º–∏—Ä–∞–º–µ ‚Äì –¥–∞–ª–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–≤–∞–º–µ –ª–æ–∫–∞–ª–Ω–æ, —Ç–µ—Å—Ç–≤–∞–º–µ –Ω–∞ staging —Å—ä—Ä–≤—ä—Ä –∏–ª–∏ –≤–µ—á–µ —Å–º–µ –≤ –ø—Ä–æ–¥—É–∫—Ü–∏—è ‚Äì –º–æ–∂–µ –¥–∞ –∏—Å–∫–∞–º–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –Ω–∏ –¥–∞ —Å–µ –¥—ä—Ä–∂–∏ –ø–æ —Ä–∞–∑–ª–∏—á–µ–Ω –Ω–∞—á–∏–Ω.
–¢–æ–≤–∞ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ –Ω–µ –ø—Ä–æ—Å—Ç–æ –º–æ–∂–µ–º –¥–∞ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä–∞–º–µ "–∫—Ä–∞–Ω—á–µ—Ç–∞—Ç–∞" –≤ —Ç—Ä—ä–±–æ–ø—Ä–æ–≤–æ–¥–∞, –∞ –º–æ–∂–µ–º –¥–∞ –≥–∏ –Ω–∞—Å—Ç—Ä–æ–π–≤–∞–º–µ –ø–æ —Ä–∞–∑–ª–∏—á–µ–Ω –Ω–∞—á–∏–Ω —Å–ø–æ—Ä–µ–¥ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞, –≤ –∫–æ–π—Ç–æ —Ä–∞–±–æ—Ç–∏–º.
–ú–æ–∂–µ–º –¥–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–º–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ —Ç–∞–∫–∞, —á–µ –≤ –µ–¥–Ω–∞ —Å—Ä–µ–¥–∞ –¥–∞ –ª–æ–≥–≤–∞–º–µ –ø–æ–¥—Ä–æ–±–Ω–æ –≤—Å–∏—á–∫–æ, –¥–∞ –ø–æ–∫–∞–∑–≤–∞–º–µ –≥—Ä–µ—à–∫–∏ –∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞, –∞ –≤ –¥—Ä—É–≥–∞ ‚Äì –¥–∞ —Å–º–µ –º–∞–∫—Å–∏–º–∞–ª–Ω–æ –ø–µ—Å—Ç–µ–ª–∏–≤–∏ –∏ —Å–∏–≥—É—Ä–Ω–∏.
–ú–µ—Ö–∞–Ω–∏–∑–º—ä—Ç, —á—Ä–µ–∑ –∫–æ–π—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ —Ä–∞–∑–±–∏—Ä–∞ –≤ –∫–∞–∫—ä–≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–µ –Ω–∞–º–∏—Ä–∞, —Å–µ –Ω–∞—Ä–∏—á–∞ **—Å—Ä–µ–¥–∞** (_environment_).
–°—Ä–µ–¥–∞—Ç–∞ –µ –∏–∑–∫–ª—é—á–∏—Ç–µ–ª–Ω–æ –≤–∞–∂–Ω–∞ —á–∞—Å—Ç –æ—Ç –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è—Ç–∞ –Ω–∞ ASP.NET Core, –∑–∞—â–æ—Ç–æ –≤—ä—Ä—Ö—É –Ω–µ—è –ª–µ–∂–∏ –ø–æ–≤–µ–¥–µ–Ω–∏–µ—Ç–æ –Ω–∞ –º–Ω–æ–≥–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ ‚Äì –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è, –ª–æ–≥–≤–∞–Ω–µ, –∏–∑–∫–ª—é—á–µ–Ω–∏—è, —Å–∏–≥—É—Ä–Ω–æ—Å—Ç –∏ –¥—Ä—É–≥–∏

–°—Ä–µ–¥–∏—Ç–µ –≤ 99% –æ—Ç —Å–ª—É—á–∞–∏—Ç–µ –∑–∞—Å—è–≥–∞—Ç pipeline-a.

–£–µ–± –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è—Ç–∞ –∏–º–∞—Ç –Ω–∞—á–∞–ª–Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è.

–ù–∞—Å—Ç—Ä–æ–π–≤–∞—Ç —Å–µ —Ö–æ—Å—Ç, —Å–∏–≥—É—Ä–Ω–æ—Å—Ç, –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏, –∫–æ–Ω–≤–µ–Ω—Ü–∏–∏ –∏ –¥—Ä—É–≥–∏.
### MVC Request Lifecycle
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250518142916.png)

–ò–º–∞–º–µ –∑–∞—è–≤–∫–∞, –∫–æ—è—Ç–æ —Ç—Ä—ä–≥–≤–∞ –ø–æ pipeline-–∞. –ü—ä—Ä–≤–æ—Ç–æ –Ω–µ—â–æ, –ø—Ä–µ–∑ –∫–æ–µ—Ç–æ –º–∏–Ω–∞–≤–∞, –µ Middleware ‚Äì –∑–µ–ª–µ–Ω–æ—Ç–æ –∫–≤–∞–¥—Ä–∞—Ç—á–µ –æ—Ç —Å—Ö–µ–º–∞—Ç–∞. –¢–æ–≤–∞ –Ω–µ –µ –µ–¥–∏–Ω –∫–æ–Ω–∫—Ä–µ—Ç–µ–Ω middleware, –∞ –ø–æ-—Å–∫–æ—Ä–æ **placeholder –∑–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ middlewares**, –∫–æ–∏—Ç–æ –º–æ–∂–µ –¥–∞ —Å–º–µ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–∞–ª–∏.

–°–ª–µ–¥ —Ç–æ–≤–∞ –∑–∞—è–≤–∫–∞—Ç–∞ —Å—Ç–∏–≥–∞ –¥–æ **Routing-–∞**, –∫–æ–π—Ç–æ –æ–ø—Ä–µ–¥–µ–ª—è –∫–æ–π –µ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä—ä—Ç –∏ –∫–æ–π –µ —Å—ä–æ—Ç–≤–µ—Ç–Ω–∏—è—Ç action. –°–∞–º–∏—è—Ç routing —Å—ä—â–æ –µ middleware –∏ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –Ω–∞–º–∏—Ä–∞ –Ω–∞ —Å—Ç—Ä–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –º—è—Å—Ç–æ –≤ pipeline-–∞. –°–ª–µ–¥ –Ω–µ–≥–æ –º–æ–∂–µ–º –¥–∞ –∏–º–∞–º–µ –∏ –¥—Ä—É–≥–∏ middleware-–∏.

–ö–æ–≥–∞—Ç–æ —Å–µ –æ–ø—Ä–µ–¥–µ–ª–∏ –ø—Ä–∞–≤–∏–ª–Ω–∏—è—Ç –ø—ä—Ç, **—Å–µ –≤–¥–∏–≥–∞ —Å—ä–æ—Ç–≤–µ—Ç–Ω–∏—è—Ç –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä –∏ action**, –∏ —Å–µ –ø—Ä–µ–º–∏–Ω–∞–≤–∞ –ø—Ä–µ–∑ —Ñ–∏–ª—Ç—Ä–∏—Ç–µ –≤ Action Execution.

–ü—Ä–µ–¥–∏ –¥–∞ —Å–µ —Å–ª—É—á–∏ **Model Binding**, –ø—ä—Ä–≤–æ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞ **Authorization —Ñ–∏–ª—Ç—ä—Ä—ä—Ç**, –∫–æ–π—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –∏–º–∞ –ø—Ä–∞–≤–∞ –∑–∞ –¥–æ—Å—Ç—ä–ø. –°–ª–µ–¥ –Ω–µ–≥–æ –∏–¥–≤–∞ **Resource —Ñ–∏–ª—Ç—ä—Ä—ä—Ç**.

–°–ª–µ–¥ —Ç–æ–≤–∞ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞ —Å–∞–º–∏—è—Ç **action –º–µ—Ç–æ–¥**, –∏ –Ω–∞–∫—Ä–∞—è –º–∏–Ω–∞–≤–∞–º–µ –ø—Ä–µ–∑ **Result Execution**, –∫—ä–¥–µ—Ç–æ —Ñ–∏–ª—Ç—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∞—Ç –≤ –æ–±—Ä–∞—Ç–µ–Ω —Ä–µ–¥.

–ö–æ–≥–∞—Ç–æ —Ä–µ–∑—É–ª—Ç–∞—Ç—ä—Ç –µ –≥–æ—Ç–æ–≤ (–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –¥–∞–ª–∏ –µ View, JSON –∏–ª–∏ –Ω–µ—â–æ –¥—Ä—É–≥–æ), **View Engine-—ä—Ç** –∏–ª–∏ —Å—ä–æ—Ç–≤–µ—Ç–Ω–∏—è—Ç –º–µ—Ö–∞–Ω–∏–∑—ä–º **—Ä–µ–Ω–¥–µ—Ä–∏—Ä–∞ –æ—Ç–≥–æ–≤–æ—Ä–∞ –∏ –≥–æ –≤—Ä—ä—â–∞ –∫—ä–º –∫–ª–∏–µ–Ω—Ç–∞**.

–¢–æ–≤–∞ –µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏—è—Ç –ø—ä—Ç, –Ω–æ –∏–º–∞–º–µ –≤—ä–∑–º–æ–∂–Ω–æ—Å—Ç **–¥–∞ —Å—ä–∫—Ä–∞—Ç–∏–º –ø—Ä–æ—Ü–µ—Å–∞ –æ—â–µ –≤ –Ω–∞—á–∞–ª–æ—Ç–æ**, –∫–∞—Ç–æ –Ω–∞–ø–∏—à–µ–º —Å–æ–±—Å—Ç–≤–µ–Ω middleware, –∫–æ–π—Ç–æ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤—Ä—ä—â–∞ –æ—Ç–≥–æ–≤–æ—Ä.

–ú–Ω–æ–≥–æ —á–µ—Å—Ç–æ —Ç–æ—á–Ω–æ —Ç–∞–∫–∞ —Ä–∞–±–æ—Ç–∏ **caching middleware-—ä—Ç** ‚Äì –∞–∫–æ –Ω–∞–º–µ—Ä–∏–º –æ—Ç–≥–æ–≤–æ—Ä–∞ –≤ –∫–µ—à–∞, **–Ω—è–º–∞ –Ω—É–∂–¥–∞** –¥–∞ –º–∏–Ω–∞–≤–∞–º–µ –ø—Ä–µ–∑ —Ä—É—Ç–∏—Ä–∞–Ω–µ, –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∏, —Ñ–∏–ª—Ç—Ä–∏ –∏ —Ç.–Ω.

–í—Å—è–∫–∞ —á–∞—Å—Ç –æ—Ç –≤–µ—Ä–∏–≥–∞—Ç–∞ –µ —Ç–æ—á–∫–∞, –≤ –∫–æ—è—Ç–æ –º–æ–∂–µ–º –¥–∞ —Å–µ "–≤–º—ä–∫–Ω–µ–º" –∏ –ø—Ä–∏ –Ω—É–∂–¥–∞ –¥–∞ –≤—ä—Ä–Ω–µ–º –æ—Ç–≥–æ–≤–æ—Ä –≤–µ–¥–Ω–∞–≥–∞, –±–µ–∑ –¥–∞ –ø—Ä–æ–¥—ä–ª–∂–∞–≤–∞–º–µ –ø–æ —Ü–µ–ª–∏—è pipeline.
### Controller Context
–ö–æ–Ω—Ç—Ä–æ–ª–µ—Ä—ä—Ç –µ –µ–¥–∏–Ω –æ—Ç –æ—Å–Ω–æ–≤–Ω–∏—Ç–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –≤ –ø–æ—Ç–æ–∫–∞ –Ω–∞ –∑–∞—è–≤–∫–∞—Ç–∞ (Request pipeline), –∫–æ–π—Ç–æ —É–ø—Ä–∞–≤–ª—è–≤–∞ —Ü–µ–ª–∏—è –ø—Ä–æ—Ü–µ—Å.

–í—Å–µ–∫–∏ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä –∏–º–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–æ –ø—Ä–æ–ø—ä—Ä—Ç–∏ **`ControllerContext`**.

`ControllerContext` —Å—ä–¥—ä—Ä–∂–∞ –Ω–∞–±–æ—Ä –æ—Ç –ø–æ–ª–µ–∑–Ω–∏ –ø—Ä–æ–ø—ä—Ä—Ç–∏—Ç–∞, –∫–æ–∏—Ç–æ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ —Ç–µ–∫—É—â–∞—Ç–∞ –∑–∞—è–≤–∫–∞.

–í `ControllerContext` –º–æ–∂–µ–º –¥–∞ –¥–æ—Å—Ç—ä–ø–∏–º —Å–ª–µ–¥–Ω–∏—Ç–µ –ø—Ä–æ–ø—ä—Ä—Ç–∏—Ç–∞:

`ActionDescriptor` ‚Äì –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ —Ç–µ–∫—É—â–∏—è action, –≤–∫–ª—é—á–∏—Ç–µ–ª–Ω–æ –∞—Ç—Ä–∏–±—É—Ç–∏, –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –∏ –º–µ—Ç–∞-–¥–∞–Ω–Ω–∏.

`HttpContext` ‚Äì —Å—ä–¥—ä—Ä–∂–∞ —Ü—è–ª–æ—Å—Ç–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç –Ω–∞ HTTP –∑–∞—è–≤–∫–∞—Ç–∞, –≤–∫–ª—é—á–∏—Ç–µ–ª–Ω–æ `Request` –∏ `Response`.

`ModelState` ‚Äì —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –æ—Ç –æ–ø–∏—Ç–∏—Ç–µ –∑–∞ –æ–±–≤—ä—Ä–∑–≤–∞–Ω–µ (binding) –Ω–∞ –¥–∞–Ω–Ω–∏ –∏ –≤–∞–ª–∏–¥–∏—Ä–∞–Ω–µ—Ç–æ –∏–º; —Ç—É–∫ –º–æ–∂–µ–º –¥–∞ –ø—Ä–æ–≤–µ—Ä–∏–º –¥–∞–ª–∏ –≤—Ö–æ–¥–Ω–∏—Ç–µ –¥–∞–Ω–Ω–∏ —Å–∞ –≤–∞–ª–∏–¥–Ω–∏.

`RouteData` ‚Äì —Å—ä–¥—ä—Ä–∂–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, –∏–∑–≤–ª–µ—á–µ–Ω–∞ –æ—Ç –º–∞—Ä—à—Ä—É—Ç–∞, –∫–∞—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –æ—Ç URL –∞–¥—Ä–µ—Å–∞ –∏ —Å—ä–æ—Ç–≤–µ—Ç–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç, –ø–æ –∫–æ–π—Ç–æ –µ –º–∏–Ω–∞–ª–∞ –∑–∞—è–≤–∫–∞—Ç–∞.

`ValueProviderFactories` ‚Äì —Å–ø–∏—Å—ä–∫ —Å —Ñ–∞–±—Ä–∏–∫–∏, –∫–æ–∏—Ç–æ –¥–æ—Å—Ç–∞–≤—è—Ç —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –∑–∞ –æ–±–≤—ä—Ä–∑–≤–∞–Ω–µ –∫—ä–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—Ç–µ –Ω–∞ action –º–µ—Ç–æ–¥–∞ (–Ω–∞–ø—Ä. –æ—Ç —Ñ–æ—Ä–º—É–ª—è—Ä–∏, query string, route –∏ —Ç.–Ω.).
### Application Fundamentals
–í ASP.NET Core –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –∫–ª–∞—Å–∞ `Program.cs`, –∑–∞ –¥–∞ –Ω–∞–ø—Ä–∞–≤–∏–º —Å–ª–µ–¥–Ω–æ—Ç–æ:

–ö–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–º–µ HTTP request pipeline-–∞. –ü—Ä–æ–º–µ–Ω—è–π–∫–∏ —Ç–∏–ø–∞ –Ω–∞ –ø—Ä–æ–µ–∫—Ç–∞ –∫–∞—Ç–æ –ø—Ä–∏–º–µ—Ä–Ω–æ –¥–∞–ª–∏ –µ individual accounts –∏–ª–∏ –µ –Ω—è–∫–∞–∫—ä–≤ –¥—Ä—É–≥, —Ç–æ–≤–∞ —â–µ –ø—Ä–æ–º–µ–Ω–∏ pipeline-a.

–û–ø—Ä–µ–¥–µ–ª—è–º–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –∑–∞ —Ä–∞–∑–ª–∏—á–Ω–∏ —Å—Ä–µ–¥–∏.

–û—Å–Ω–æ–≤–Ω–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ (Application Fundamentals):

```csharp
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseCookiePolicy();

app.UseMvcWithDefaultRoute();
```

–ê–∫–æ –Ω–µ —Å–º–µ –≤ —Å—Ä–µ–¥–∞ –∑–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞, –Ω–∞—Å—Ç—Ä–æ–π–≤–∞–º–µ —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–∏—Ä–∞–Ω–æ –æ–±—Ä–∞–±–æ—Ç–≤–∞–Ω–µ –Ω–∞ –≥—Ä–µ—à–∫–∏ –∏ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ HTTP Strict Transport Security.

–ü—Ä–µ–Ω–∞—Å–æ—á–≤–∞–º–µ HTTP –∑–∞—è–≤–∫–∏—Ç–µ –∫—ä–º HTTPS.

–ü–æ–∑–≤–æ–ª—è–≤–∞–º–µ –æ–±—Å–ª—É–∂–≤–∞–Ω–µ –Ω–∞ —Å—Ç–∞—Ç–∏—á–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ.

–ü—Ä–∏–ª–∞–≥–∞–º–µ –ø–æ–ª–∏—Ç–∏–∫–∞ –∑–∞ –±–∏—Å–∫–≤–∏—Ç–∫–∏.

–†–µ–≥–∏—Å—Ç—Ä–∏—Ä–∞–º–µ MVC —Å –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞—â —Å–µ –º–∞—Ä—à—Ä—É—Ç.
### Application Environments
–î–µ–ø–ª–æ–π–º—ä–Ω—Ç—ä—Ç –Ω–∞ —Å–æ—Ñ—Ç—É–µ—Ä–∞ –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Å–µ —Ä–∞–∑–ø—Ä–µ–¥–µ–ª—è –≤ –Ω—è–∫–æ–ª–∫–æ —Ä–∞–∑–ª–∏—á–Ω–∏ —Å—Ä–µ–¥–∏.

–ú–Ω–æ–≥–æ–µ—Ç–∞–ø–Ω–∏—è—Ç (multi-stage) –¥–µ–ø–ª–æ–π–º—ä–Ω—Ç –µ **–∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–µ–Ω** –ø—Ä–∏ enterprise –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.

–í—Å—è–∫–∞ —Å—Ä–µ–¥–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–≤–∞ –∫–æ–º–ø—é—Ç—ä—Ä–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ (–≤–∏—Ä—Ç—É–∞–ª–Ω–∞ –∏–ª–∏ —Ñ–∏–∑–∏—á–µ—Å–∫–∞), –≤—ä—Ä—Ö—É –∫–æ—è—Ç–æ –ø—É—Å–∫–∞–º–µ –Ω–∞—à–∏—è —Å–æ—Ñ—Ç—É–µ—Ä.

–ü–æ–≤–µ—á–µ—Ç–æ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∏ –∏–∑–ø–æ–ª–∑–≤–∞—Ç —Å–ª–µ–¥–Ω–∏—Ç–µ —Å—Ä–µ–¥–∏:

**Dev / Development**  ‚Äì –°—Ä–µ–¥–∞—Ç–∞, –≤ –∫–æ—è—Ç–æ —Ä–∞–∑—Ä–∞–±–æ—Ç–≤–∞–º–µ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –∏–ª–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞.

**Test / Testing**  ‚Äì –°—Ä–µ–¥–∞—Ç–∞, –≤ –∫–æ—è—Ç–æ —Ç–µ—Å—Ç–≤–∞–º–µ –∏ –≤–∞–ª–∏–¥–∏—Ä–∞–º–µ –ø—Ä–æ–¥—É–∫—Ç–∞ (–∏–ª–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞) –∫–∞—Ç–æ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏—Ü–∏.

**Stage / Staging**  ‚Äì –°—Ä–µ–¥–∞—Ç–∞, –≤ –∫–æ—è—Ç–æ –∫–ª–∏–µ–Ω—Ç—ä—Ç –ø—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ –ø—Ä–æ–¥—É–∫—Ç—ä—Ç –æ—Ç–≥–æ–≤–∞—Ä—è –Ω–∞ –Ω–µ–≥–æ–≤–∏—Ç–µ –æ—á–∞–∫–≤–∞–Ω–∏—è.

**Production**  ‚Äì –°—Ä–µ–¥–∞—Ç–∞, –≤ –∫–æ—è—Ç–æ –ø—Ä–æ–¥—É–∫—Ç—ä—Ç –µ –æ—Ñ–∏—Ü–∏–∞–ª–Ω–æ –¥–æ—Å—Ç—ä–ø–µ–Ω –∑–∞ –≤—Å–∏—á–∫–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏.

ASP.NET Core –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞ –ø–æ–≤–µ–¥–µ–Ω–∏–µ—Ç–æ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ —Å–ø–æ—Ä–µ–¥ —Å—Ä–µ–¥–∞—Ç–∞, –≤ –∫–æ—è—Ç–æ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞.

–ü–æ–¥–¥—ä—Ä–∂–∞ —Ç—Ä–∏ –æ—Å–Ω–æ–≤–Ω–∏ —Å—Ä–µ–¥–∏ ‚Äì Development, Staging –∏ Production. Staging –æ–±–µ–¥–∏–Ω—è–≤–∞ Test –∏ Stage —Å—Ä–µ–¥–∏—Ç–µ.

–ß–µ—Ç–µ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞—Ç–∞ –Ω–∞ —Å—Ä–µ–¥–∞—Ç–∞ —Å –∏–º–µ—Ç–æ `"ASPNETCORE_ENVIRONMENT"`.

–°—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ —Ç–∞–∑–∏ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –≤ —Å–≤–æ–π—Å—Ç–≤–æ—Ç–æ `EnvironmentName` –Ω–∞ –æ–±–µ–∫—Ç–∞ `Environment`, –∫–æ–π—Ç–æ –µ —á–∞—Å—Ç –æ—Ç `WebApplication`, –≤—ä—Ä–Ω–∞—Ç –æ—Ç –º–µ—Ç–æ–¥–∞ `Build()` –Ω–∞ `WebApplicationBuilder`.

–ú–æ–∂–µ–º –¥–∞ –∑–∞–¥–∞–¥–µ–º —Å—Ä–µ–¥–∞—Ç–∞ –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–ª–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç. –ü–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ —Å—Ä–µ–¥–∞—Ç–∞ –µ Production.

```csharp
if(app.Environment.IsDevelopment()) // TODO: Do Development
if(app.Environment.IsStaging()) // TODO: Do Staging
if(app.Environment.IsProduction()) // TODO: Do Production
if(app.Environment.IsEnvironment("some_environment")) // TODO: Do Something
```

–ù–µ —Å–º–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏ —Å–∞–º–æ –¥–æ —Å—Ä–µ–¥–∏—Ç–µ, –∫–æ–∏—Ç–æ Microsoft –µ –¥–µ—Ñ–∏–Ω–∏—Ä–∞–ª–∞ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ.
–ú–æ–∂–µ–º —Å–≤–æ–±–æ–¥–Ω–æ –¥–∞ —Å–º–µ–Ω–∏–º —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ `"ASPNETCORE_ENVIRONMENT"` —Å —Ç–∞–∫–∞–≤–∞, –∫–∞–∫–≤–∞—Ç–æ –Ω–∏ –µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞.
–°–ª–µ–¥ —Ç–æ–≤–∞ –º–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –º–µ—Ç–æ–¥–∞ `IsEnvironment`, –∑–∞ –¥–∞ –ø—Ä–æ–≤–µ—Ä–∏–º –¥–∞–ª–∏ —Ç–µ–∫—É—â–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç —Å—ä–≤–ø–∞–¥–∞ —Å —Ç–∞–∑–∏, –∫–æ—è—Ç–æ —Å–º–µ –∑–∞–¥–∞–ª–∏.
–ê–∫–æ —Å—ä–≤–ø–∞–¥–∞, –º–µ—Ç–æ–¥—ä—Ç —â–µ –≤—ä—Ä–Ω–µ `true` –∏ —â–µ –º–æ–∂–µ–º –¥–∞ –≤–∑–µ–º–µ–º —Ä–µ—à–µ–Ω–∏—è –≤ –∫–æ–¥–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç –æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –Ω–∞ —Å—Ä–µ–¥–∞—Ç–∞.
### Application Configuration
–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è—Ç–∞ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –≤ ASP.NET Core –µ –±–∞–∑–∏—Ä–∞–Ω–∞ –Ω–∞ –¥–≤–æ–π–∫–∏ –∫–ª—é—á-—Å—Ç–æ–π–Ω–æ—Å—Ç.

–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏—Ç–µ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ —Å–µ –∑–∞–¥–∞–≤–∞—Ç —á—Ä–µ–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–∏ –¥–æ—Å—Ç–∞–≤—á–∏—Ü–∏ (configuration providers).

–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–∏—Ç–µ –¥–æ—Å—Ç–∞–≤—á–∏—Ü–∏ —á–µ—Ç–∞—Ç –¥–∞–Ω–Ω–∏ –æ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–∏ –∏–∑—Ç–æ—á–Ω–∏—Ü–∏.

–¢–µ–∑–∏ –∏–∑—Ç–æ—á–Ω–∏—Ü–∏ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç Azure Key Vault –∏–ª–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–∏ –æ—Ç –∫–æ–º–∞–Ω–¥–Ω–∏—è —Ä–µ–¥.

–ú–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∏ –¥–æ—Å—Ç–∞–≤—á–∏—Ü–∏ ‚Äì –∏–Ω—Å—Ç–∞–ª–∏—Ä–∞–Ω–∏ –∏–ª–∏ —Å—ä–∑–¥–∞–¥–µ–Ω–∏ –æ—Ç –Ω–∞—Å.

–°—ä—â–æ —Ç–∞–∫–∞ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç —Ñ–∞–π–ª–æ–≤–µ –æ—Ç –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏, –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏ –Ω–∞ —Å—Ä–µ–¥–∞—Ç–∞ –∏ –¥—Ä—É–≥–∏.

–ï–¥–∏–Ω –æ—Ç –∏–∑—Ç–æ—á–Ω–∏—Ü–∏—Ç–µ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ –µ —Ñ–∞–π–ª—ä—Ç `appsettings.json`.

–ú–æ–∂–µ–º –¥–∞ –ø–æ–ª–∑–≤–∞–º–µ –Ω—è–∫–æ–ª–∫–æ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–∏ –ø—Ä–æ–≤–∞–π–¥—ä—Ä–∞ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä `appsettings.json`, environment variables, Azure Key Vault –∏ –¥—Ä—É–≥–∏). –í—Å–∏—á–∫–∏ —Ç–µ —Å–µ –æ–±–µ–¥–∏–Ω—è–≤–∞—Ç –≤ –æ–±—â –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–µ–Ω store, –∫–æ–π—Ç–æ —Ä–∞–±–æ—Ç–∏ –∫–∞—Ç–æ —Ä–µ—á–Ω–∏–∫ –æ—Ç —Ç–∏–ø `Dictionary<string, string>`.

–ú–æ–∂–µ –¥–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–º–µ –Ω—è–∫–æ–∏ –ø—Ä–æ–≤–∞–π–¥—ä—Ä–∏ (–∫–∞—Ç–æ `appsettings.json`) –¥–∞ –Ω–∞–±–ª—é–¥–∞–≤–∞—Ç –∑–∞ –ø—Ä–æ–º–µ–Ω–∏ –≤—ä–≤ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –∏ **–∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –¥–∞ –ø—Ä–µ–∑–∞—Ä–µ–∂–¥–∞—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ**, –±–µ–∑ –Ω—É–∂–¥–∞ –æ—Ç —Ä–µ—Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ. –¢–æ–≤–∞ —Å—Ç–∞–≤–∞ —á—Ä–µ–∑ `reloadOnChange: true`.

–ü—Ä–∏–º–µ—Ä:

```csharp
builder.Configuration.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);
```

–§–∞–π–ª—ä—Ç `launchSettings.json` —Å–µ –Ω–∞–º–∏—Ä–∞ –≤ –ø–∞–ø–∫–∞—Ç–∞ `Properties` –∏ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –∑–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–∞—á–∏–Ω–∞, –ø–æ –∫–æ–π—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ —Å–µ —Å—Ç–∞—Ä—Ç–∏—Ä–∞ –ø–æ –≤—Ä–µ–º–µ –Ω–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞. –¢–æ–π –∑–∞–¥–∞–≤–∞ –ø—Ä–æ—Ñ–∏–ª–∏, –ø–æ—Ä—Ç–æ–≤–µ, URL-–∏ –∏ —Å—Ä–µ–¥–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä —á—Ä–µ–∑ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞—Ç–∞ `ASPNETCORE_ENVIRONMENT`), –∫–æ—è—Ç–æ –æ–ø—Ä–µ–¥–µ–ª—è —Ç–µ–∫—É—â–∞—Ç–∞ —Å—Ä–µ–¥–∞ (–Ω–∞–ø—Ä. Development). –í—ä–ø—Ä–µ–∫–∏ —Ç–æ–≤–∞, `launchSettings.json` **–Ω–µ —É—á–∞—Å—Ç–≤–∞ –≤ –æ—Å–Ω–æ–≤–Ω–∞—Ç–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è (`builder.Configuration`)** –∏ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ —Å–∞–º–æ –ø—Ä–∏ –ª–æ–∫–∞–ª–Ω–æ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ, –∫–∞—Ç–æ –Ω–µ —Å–µ —á–µ—Ç–µ –æ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –ø—Ä–∏ runtime.
–ü—Ä–∏ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ —á—Ä–µ–∑ Visual Studio –∏–ª–∏ `dotnet run` —Å–µ –∏–∑–±–∏—Ä–∞ –µ–¥–∏–Ω –æ—Ç –ø—Ä–æ—Ñ–∏–ª–∏—Ç–µ, –¥–µ—Ñ–∏–Ω–∏—Ä–∞–Ω–∏ –≤ `launchSettings.json`. –°–∞–º–æ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è—Ç–∞ –Ω–∞ –∏–∑–±—Ä–∞–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª —Å–µ –∑–∞—Ä–µ–∂–¥–∞ –∏ –ø—Ä–∏–ª–∞–≥–∞ –∑–∞ —Ç–µ–∫—É—â–∞—Ç–∞ —Å–µ—Å–∏—è –Ω–∞ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ. –¢–æ–≤–∞ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ –∞–∫–æ –∏–∑–±–µ—Ä–µ–º –ø—Ä–æ—Ñ–∏–ª–∞ `IIS Express`, –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ —â–µ —Å—Ç–∞—Ä—Ç–∏—Ä–∞ —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ, –æ–ø–∏—Å–∞–Ω–∏ —Å–∞–º–æ –≤ —Ç–æ–∑–∏ –ø—Ä–æ—Ñ–∏–ª, –∞ –æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ –ø—Ä–æ—Ñ–∏–ª–∏ —â–µ –±—ä–¥–∞—Ç –∏–≥–Ω–æ—Ä–∏—Ä–∞–Ω–∏ –∑–∞ —Ç–∞–∑–∏ —Å–µ—Å–∏—è. –ü–æ —Ç–æ–∑–∏ –Ω–∞—á–∏–Ω –º–æ–∂–µ–º –¥–∞ –∏–º–∞–º–µ —Ä–∞–∑–ª–∏—á–Ω–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∑–∞ —Ä–∞–∑–ª–∏—á–Ω–∏ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –Ω–∞ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä –ª–æ–∫–∞–ª–µ–Ω IIS Express, HTTP –∏–ª–∏ HTTPS, –±–µ–∑ —Ç–µ –¥–∞ —Å–µ –ø—Ä–∏–ª–∞–≥–∞—Ç –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.

–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è—Ç–∞ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ —Å–µ —á–µ—Ç–µ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –æ—Ç —Ä–∞–∑–ª–∏—á–Ω–∏ –ø—Ä–æ–≤–∞–π–¥—ä—Ä–∏.

–í—Å–∏—á–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç –∏ –¥–æ—Å—Ç—ä–ø–≤–∞—Ç —á—Ä–µ–∑ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ `IConfiguration`.

`IConfiguration` –µ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–∞–Ω –≤ DI –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ –∏ –º–æ–∂–µ –¥–∞ —Å–µ –∏–Ω–∂–µ–∫—Ç–∏—Ä–∞ –≤ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∏ –∏–ª–∏ –¥—Ä—É–≥–∏ —É—Å–ª—É–≥–∏.

–ù–∞–ø—Ä–∏–º–µ—Ä, –∞–∫–æ –∏–º–∞–º–µ –≤ `appsettings.json`:

```json
{
  "Greeting": "Hello!",
  "Config": {
    "Secret": "Can‚Äôt touch this"
  }
}
```

–≤ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∞ –º–æ–∂–µ–º –¥–∞ –ø–æ–ª—É—á–∏–º —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ —Ç–∞–∫–∞:

```csharp
public class HomeController : Controller
{
    private readonly IConfiguration config;
    
    public HomeController(IConfiguration config)
    {
        this.config = config;
    }
    
    public IActionResult Config()
    {
        return Content(this.config["Greeting"] + " " + this.config["Config:Secret"]); // returns "Hello! Can‚Äôt touch this"
    }
}
```

–ú–æ–∂–µ–º –¥–∞ –¥–æ—Å—Ç—ä–ø–∏–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ –¥–≤–∞ –Ω–∞—á–∏–Ω–∞: —Å `configuration["Key"]`, –∫–æ–π—Ç–æ –≤—Ä—ä—â–∞ –≤–∏–Ω–∞–≥–∏ `string?`, –∏ —Å `configuration.GetValue<T>("Key")`, –∫–æ–π—Ç–æ –≤—Ä—ä—â–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –∫–∞—Ç–æ –¥–∞–¥–µ–Ω —Ç–∏–ø (–Ω–∞–ø—Ä. `int`, `bool`) –∏ –ø–æ–∑–≤–æ–ª—è–≤–∞ –∑–∞–¥–∞–≤–∞–Ω–µ –Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ. –í—Ç–æ—Ä–∏—è—Ç –≤–∞—Ä–∏–∞–Ω—Ç –µ –ø–æ-–≥—ä–≤–∫–∞–≤ –∏ –±–µ–∑–æ–ø–∞—Å–µ–Ω –ø—Ä–∏ –Ω—É–∂–¥–∞ –æ—Ç —Ç–∏–ø–∏–∑–∏—Ä–∞–Ω–∏ –¥–∞–Ω–Ω–∏.

–í—Å–∏—á–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏, —Å–µ –æ–±–µ–¥–∏–Ω—è–≤–∞—Ç –≤—ä–≤ –≤—ä—Ç—Ä–µ—à–µ–Ω –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–µ–Ω —Ä–µ—á–Ω–∏–∫ –æ—Ç —Ç–∏–ø `IConfiguration`, –∫–æ–π—Ç–æ –∏–∑–ø–æ–ª–∑–≤–∞ –∫–ª—é—á–æ–≤–µ –æ—Ç —Ç–∏–ø `string`. –ö–æ–≥–∞—Ç–æ –∏–º–∞–º–µ –≤–ª–æ–∂–µ–Ω–∏ –æ–±–µ–∫—Ç–∏, –¥–æ—Å—Ç—ä–ø–≤–∞–º–µ —Ç–µ—Ö–Ω–∏—Ç–µ –ø—Ä–æ–ø—ä—Ä—Ç–∏—Ç–∞ —Å –ø–æ–º–æ—â—Ç–∞ –Ω–∞ –¥–≤–æ–µ—Ç–æ—á–∏–µ (`:`) –∫–∞—Ç–æ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª –º–µ–∂–¥—É –Ω–∏–≤–∞—Ç–∞. –ü—Ä–∏–º–µ—Ä:

```json
{
  "ConnectionStrings": {
    "SQLServer": "Server=.;Database=MyDb;Trusted_Connection=True;"
  }
}
```

–ú–æ–∂–µ–º –¥–∞ –¥–æ—Å—Ç—ä–ø–∏–º —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ —Å—ä—Å:

```csharp
config["ConnectionStrings:SQLServer"]
```

–¢–æ–≤–∞ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –µ –µ–¥–Ω–∞–∫–≤–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –¥–∞–ª–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –∏–¥–≤–∞ –æ—Ç JSON —Ñ–∞–π–ª, XML —Ñ–∞–π–ª, environment –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞ –∏–ª–∏ –¥—Ä—É–≥ provider. –¢–æ–≤–∞ –ø–æ–∑–≤–æ–ª—è–≤–∞ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–µ–Ω –¥–æ—Å—Ç—ä–ø –¥–æ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–∏ –¥–∞–Ω–Ω–∏ —á—Ä–µ–∑ –∫–ª—é—á–æ–≤–µ —Å –¥–≤–æ–µ—Ç–æ—á–∏–µ (`:`), –∫–æ–∏—Ç–æ –æ–ø–∏—Å–≤–∞—Ç –ø—ä—Ç—è –¥–æ –≤–ª–æ–∂–µ–Ω–∏—Ç–µ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏.

–ö–æ–≥–∞—Ç–æ –∏–∑–≤–∏–∫–∞–º–µ `WebApplicationBuilder builder = WebApplication.CreateBuilder(args)`, —Å–µ —Å—ä–∑–¥–∞–≤–∞ –æ–±–µ–∫—Ç, –∫–æ–π—Ç–æ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ –∑–∞—Ä–µ–∂–¥–∞ –ø—ä–ª–Ω–∞—Ç–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ. –í –Ω–µ–≥–æ —Å–∞ –Ω–∞–ª–∏—á–Ω–∏ –æ—Å–Ω–æ–≤–Ω–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –∫–∞—Ç–æ `Services`, `Configuration`, `Environment`, `Logging` –∏ –¥—Ä—É–≥–∏. –ß—Ä–µ–∑ —Å–≤–æ–π—Å—Ç–≤–æ—Ç–æ `builder.Configuration` –∏–º–∞–º–µ –¥–æ—Å—Ç—ä–ø –¥–æ –≤—Å–∏—á–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –∏ –º–æ–∂–µ–º –ª–µ—Å–Ω–æ –¥–∞ –≥–∏ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –∑–∞ –Ω–∞—Å—Ç—Ä–æ–π–≤–∞–Ω–µ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –∏–ª–∏ –∑–∞ –∏–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏ –¥–∞–Ω–Ω–∏, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä –≤—Ä—ä–∑–∫–∏ –∫—ä–º –±–∞–∑–∏ –¥–∞–Ω–Ω–∏, –∫–ª—é—á–æ–≤–µ –∏ –¥—Ä—É–≥–∏.
### Application Services Configuration
–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è—Ç–∞ –Ω–∞ —É—Å–ª—É–≥–∏—Ç–µ –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Å–µ –∏–∑–≤—ä—Ä—à–≤–∞ –≤ `Program.cs`, –ø—Ä–µ–¥–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –¥–∞ –±—ä–¥–µ –∏–∑–≥—Ä–∞–¥–µ–Ω–æ —á—Ä–µ–∑ `WebApplicationBuilder`. –£—Å–ª—É–≥–∏—Ç–µ —Å–µ –¥–æ–±–∞–≤—è—Ç –∫—ä–º DI –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ —á—Ä–µ–∑ `builder.Services`, –∫–æ–µ—Ç–æ –ø–æ–∑–≤–æ–ª—è–≤–∞ —Ç–µ –¥–∞ –±—ä–¥–∞—Ç –∏–Ω–∂–µ–∫—Ç–∏—Ä–∞–Ω–∏ –≤ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∏ –∏ –¥—Ä—É–≥–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏. –ò–º–∞ —Ç—Ä–∏ –æ—Å–Ω–æ–≤–Ω–∏ —Ç–∏–ø–∞ –∂–∏–≤–æ—Ç –Ω–∞ —É—Å–ª—É–≥–∏—Ç–µ:

- `AddTransient` ‚Äì —Å—ä–∑–¥–∞–≤–∞ –Ω–æ–≤–∞ –∏–Ω—Å—Ç–∞–Ω—Ü–∏—è –ø—Ä–∏ –≤—Å—è–∫–∞ –∑–∞—è–≤–∫–∞.

- `AddScoped` ‚Äì –µ–¥–Ω–∞ –∏ —Å—ä—â–∞ –∏–Ω—Å—Ç–∞–Ω—Ü–∏—è —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –≤ —Ä–∞–º–∫–∏—Ç–µ –Ω–∞ –¥–∞–¥–µ–Ω–∞ HTTP –∑–∞—è–≤–∫–∞.

- `AddSingleton` ‚Äì –µ–¥–Ω–∞ –∏ —Å—ä—â–∞ –∏–Ω—Å—Ç–∞–Ω—Ü–∏—è —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –ø—Ä–µ–∑ —Ü–µ–ª–∏—è –∂–∏–≤–æ—Ç –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ.

–£—Å–ª—É–≥–∏—Ç–µ –º–æ–≥–∞—Ç –¥–∞ —Å–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞—Ç –ø–æ —Ä–∞–∑–ª–∏—á–µ–Ω –Ω–∞—á–∏–Ω –∑–∞ –≤–Ω–µ–¥—Ä—è–≤–∞–Ω–µ —á—Ä–µ–∑ Dependency Injection (DI), –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç –æ—Ç —Ç–æ–≤–∞ –∫–∞–∫—ä–≤ lifetime –∂–µ–ª–∞–µ–º:

```csharp
// Transient objects are always different
// A new instance is provided to every controller and service
builder.Services.AddTransient<DataService>();

// Scoped objects are the same within a request
// They are different across different requests
builder.Services.AddScoped(typeof(DataService));

// Singleton objects are the same for every object and request.
builder.Services.AddSingleton<DataService>();
```

–ê–∫–æ –Ω–µ —Å–º–µ —Å–∏–≥—É—Ä–Ω–∏ –∫–∞–∫—ä–≤ –¥–∞ –±—ä–¥–µ lifecycle-—ä—Ç –Ω–∞ —É—Å–ª—É–≥–∞—Ç–∞ –Ω–∏ ‚Äì –ø–æ–ª–∑–≤–∞–º–µ `Scoped`.

–í—Å–µ–∫–∏ –≤—Ö–æ–¥—è—â HTTP request –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Å—ä–∑–¥–∞–≤–∞ –Ω–æ–≤ `IServiceScope`. –¢–æ–≤–∞ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ —Ä–∞–º–∫–∏—Ç–µ –Ω–∞ –µ–¥–∏–Ω HTTP request –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–≤–∞—Ç –µ–¥–∏–Ω _scope_ ‚Äî –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –¥–∞–ª–∏ —É—Å–ª—É–≥–∞—Ç–∞ –µ `Scoped`, `Transient` –∏–ª–∏ `Singleton`, —Å–∏—Å—Ç–µ–º–∞—Ç–∞ —Ç—Ä–µ—Ç–∏—Ä–∞ –∑–∞—è–≤–∫–∞—Ç–∞ –∫–∞—Ç–æ —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª–µ–Ω –æ–±—Ö–≤–∞—Ç (scope), –≤ –∫–æ–π—Ç–æ —Å–µ resolve-–≤–∞—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏—Ç–µ. –°–ª–µ–¥ –∫—Ä–∞—è –Ω–∞ –∑–∞—è–≤–∫–∞—Ç–∞ —Ç–æ–∑–∏ scope —Å–µ —É–Ω–∏—â–æ–∂–∞–≤–∞.

–¢–æ–≤–∞ –µ –º—è—Å—Ç–æ—Ç–æ, –∫—ä–¥–µ—Ç–æ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–º–µ –≤—Å–∏—á–∫–∏ —É—Å–ª—É–≥–∏ –∑–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ —á—Ä–µ–∑ `builder.Services`. Microsoft –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è—Ç **extension –º–µ—Ç–æ–¥–∏**, –∫–æ–∏—Ç–æ –æ–±–µ–¥–∏–Ω—è–≤–∞—Ç –≤—Å–∏—á–∫–∏ –Ω—É–∂–Ω–∏ —Å—Ç—ä–ø–∫–∏ –∑–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –¥–∞–¥–µ–Ω —Å—ä—Ä–≤–∏—Å ‚Äî –Ω–∞–ø—Ä–∏–º–µ—Ä `AddControllers()`, `AddDbContext()` –∏ —Ç.–Ω. –ù–∏–µ —Å—ä—â–æ –º–æ–∂–µ–º –¥–∞ —Å—ä–∑–¥–∞–≤–∞–º–µ —Ç–∞–∫–∏–≤–∞ –º–µ—Ç–æ–¥–∏, –∫–æ–∏—Ç–æ –∑–∞–ø–æ—á–≤–∞—Ç —Å `Add`, –∏ —Ç–∞–∫–∞ –ø—Ä–∞–≤–∏–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è—Ç–∞ –ø–æ-—á–∏—Å—Ç–∞ –∏ –ª–µ—Å–Ω–∞ –∑–∞ –ø–æ–≤—Ç–æ—Ä–Ω–∞ —É–ø–æ—Ç—Ä–µ–±–∞.

–ü—Ä–∏–º–µ—Ä:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register services here
builder.Services.AddControllers();
builder.Services.AddDbContext<MyDbContext>();
builder.Services.AddTransient<IMyService, MyService>();

// We can also use our own extension method
builder.Services.AddMyCustomServices();

var app = builder.Build();
```

–°–æ–±—Å—Ç–≤–µ–Ω Extension –ú–µ—Ç–æ–¥ (–ø—Ä–µ–ø–æ—Ä—ä—á–∏—Ç–µ–ª–Ω–æ –∑–∞ –ø–æ-–¥–æ–±—ä—Ä –∫–æ–¥ –∏ –ø–æ–≤—Ç–æ—Ä–Ω–∞ —É–ø–æ—Ç—Ä–µ–±–∞):

```csharp
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddMyCustomServices(this IServiceCollection services)
    {
        services.AddTransient<IMyService, MyService>();
        services.AddScoped<IOtherService, OtherService>();
        return services;
    }
}
```

–í `Program.cs` –ø—Ä–æ—Å—Ç–æ –∏–∑–≤–∏–∫–≤–∞–º–µ:

```csharp
builder.Services.AddMyCustomServices();
```

–ú–æ–∂–µ–º –¥–∞ –¥–æ–±–∞–≤–∏–º –∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≤ —Ç–æ–∑–∏ extension –º–µ—Ç–æ–¥, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä –¥–∞ –ø—Ä–∏–µ–º–∞–º–µ `IConfiguration` –∫–∞—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—ä—Ä –∏ –¥–∞ —è –∏–∑–ø–æ–ª–∑–≤–∞–º–µ, –∑–∞ –¥–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–º–µ —É—Å–ª—É–≥–∏—Ç–µ –¥–∏–Ω–∞–º–∏—á–Ω–æ —Å–ø–æ—Ä–µ–¥ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ –≤ `appsettings.json` –∏–ª–∏ –¥—Ä—É–≥–∏ –∏–∑—Ç–æ—á–Ω–∏—Ü–∏:

```csharp
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddMyCustomServices(this IServiceCollection services, IConfiguration configuration)
    {
        // Get a setting from the configuration
        var mySetting = configuration.GetValue<string>("MySettings:SomeKey");

        // We can use this setting when configuring a service
        services.AddTransient<IMyService>(provider => new MyService(mySetting));

        services.AddScoped<IOtherService, OtherService>();

        return services;
    }
}
```

–í `Program.cs` –≥–æ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ —Ç–∞–∫–∞:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddMyCustomServices(builder.Configuration);

var app = builder.Build();
```

–ü–æ —Ç–æ–∑–∏ –Ω–∞—á–∏–Ω —Ä–∞–∑—à–∏—Ä—è–≤–∞–º–µ —É—Å–ª—É–≥–∏—Ç–µ —Å–∏ –∏ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è—Ç–∞ –∑–∞ –ø–æ-–≥—ä–≤–∫–∞–≤–æ –∑–∞–¥–∞–≤–∞–Ω–µ –Ω–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏.
## Diagnostics & Custom Error Handlers
### Error Handling
–í ASP.NET Core –∏–º–∞ –Ω—è–∫–æ–ª–∫–æ –ø–æ–¥—Ö–æ–¥–∞ –∑–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞—Ç–∞ –Ω–∞ –≥—Ä–µ—à–∫–∏:

- **Developer Exception Page** –ø–æ–∫–∞–∑–≤–∞ –¥–µ—Ç–∞–π–ª–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –≥—Ä–µ—à–∫–∏—Ç–µ –ø–æ –≤—Ä–µ–º–µ –Ω–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞, –∫–∞—Ç–æ stack trace –∏ –∏–∑—Ç–æ—á–Ω–∏–∫–∞ –Ω–∞ –≥—Ä–µ—à–∫–∞—Ç–∞. –¢—Ä—è–±–≤–∞ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –¥–∞ —Å–µ –∏–∑–∫–ª—é—á–≤–∞ –≤ –ø—Ä–æ–¥—É–∫—Ü–∏–æ–Ω–Ω–∞ —Å—Ä–µ–¥–∞, –∑–∞—â–æ—Ç–æ —Å—ä–¥—ä—Ä–∂–∞ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, –∫–æ—è—Ç–æ –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–∞ –æ—Ç –∑–ª–æ–Ω–∞–º–µ—Ä–µ–Ω–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏.

–ü—Ä–∏–º–µ—Ä –∫–∞–∫ –º–æ–∂–µ–º –¥–∞ –¥–æ–±–∞–≤–∏–º `DeveloperExceptionPage` —Å–∞–º–æ –∞–∫–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –µ –≤ —Å—Ä–µ–¥–∞ –Ω–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞:

```csharp
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    // In production environment, we show a more general error page
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}
```

–¢–∞–∫–∞ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞–º–µ, —á–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –≥—Ä–µ—à–∫–∏ —Å–µ –ø–æ–∫–∞–∑–≤–∞ —Å–∞–º–æ –≤ —Å—Ä–µ–¥–∞ –∑–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞ (Development), –¥–æ–∫–∞—Ç–æ –≤ Production –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –≤–∏–∂–¥–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ, –æ–±–æ–±—â–µ–Ω–æ —Å—ä–æ–±—â–µ–Ω–∏–µ. –í Production —Å—Ä–µ–¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –∞–ª—Ç–µ—Ä–Ω–∞—Ç–∏–≤–µ–Ω `ExceptionHandler`, –∫–æ–π—Ç–æ –º–æ–∂–µ –¥–∞ –ø—Ä–µ–Ω–∞—Å–æ—á–≤–∞ –∫—ä–º Razor —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∏–ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–µ–Ω Action –≤ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä. –ü–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ ASP.NET Core –≥–µ–Ω–µ—Ä–∏—Ä–∞ —É–Ω–∏–∫–∞–ª–µ–Ω `TraceIdentifier` –∑–∞ –≤—Å—è–∫–∞ HTTP –∑–∞—è–≤–∫–∞. –¢–æ–≤–∞ `TraceId` –º–æ–∂–µ–º –¥–∞ –¥–æ—Å—Ç—ä–ø–∏–º —á—Ä–µ–∑ `HttpContext.TraceIdentifier` –∏ –¥–∞ –≥–æ –ª–æ–≥–Ω–µ–º –∏–ª–∏ –ø–æ–∫–∞–∂–µ–º –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è –≤ Error —Å—Ç—Ä–∞–Ω–∏—Ü–∞.

–¢–∞–∫–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –º–æ–∂–µ –¥–∞ —Å—ä–æ–±—â–∏ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞, –∞ –Ω–∏–µ –¥–∞ –≥–æ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –≤ –ª–æ–≥–æ–≤–µ—Ç–µ (–Ω–∞–ø—Ä. —Å—ä—Å `Serilog` –∏–ª–∏ Application Insights), –∑–∞ –¥–∞ –ø—Ä–æ—Å–ª–µ–¥–∏–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞—Ç–∞ –≥—Ä–µ—à–∫–∞.
–î–æ–±—Ä–∞ –ø—Ä–∞–∫—Ç–∏–∫–∞ –µ –¥–∞ –ª–æ–≥–≤–∞–º–µ –∫–∞–∫—Ç–æ `TraceId`, —Ç–∞–∫–∞ –∏ —Å–∞–º–∞—Ç–∞ –∏–∑–∫–ª—é—á–µ–Ω–∏–µ (`Exception`) —á—Ä–µ–∑ `_logger.LogError(ex, "...")`, –∑–∞ –¥–∞ –∏–º–∞–º–µ –ø—ä–ª–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑.  
–¢–æ–≤–∞ –Ω–∏ –ø–æ–∑–≤–æ–ª—è–≤–∞ –ª–µ—Å–Ω–æ –¥–∞ —Ñ–∏–ª—Ç—Ä–∏—Ä–∞–º–µ –ª–æ–≥–æ–≤–µ –ø–æ `TraceId` –∏ –¥–∞ –æ—Ç–∫—Ä–∏–µ–º —Ç–æ—á–Ω–∞—Ç–∞ –∑–∞—è–≤–∫–∞ –∏ –≥—Ä–µ—à–∫–∞, –¥–æ—Ä–∏ –≤ –Ω–∞—Ç–æ–≤–∞—Ä–µ–Ω–∏ —Å—Ä–µ–¥–∏.

–ü—Ä–∏–º–µ—Ä:

```csharp
app.UseExceptionHandler("/Home/Error");

public IActionResult Error()
{
    var traceId = HttpContext.TraceIdentifier;
    _logger.LogError($"Unhandled error occurred. Trace ID: {traceId}");
    return View(new ErrorViewModel { RequestId = traceId });
}
```

```html
<!-- Error.cshtml -->
<p>Request ID: @Model.RequestId</p>
```

–ü—Ä–∏–º–µ—Ä–Ω–æ —Å—ä–æ–±—â–µ–Ω–∏–µ –∫—ä–º –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è:  
_‚Äû–ú–æ–ª—è, –∏–∑–ø—Ä–∞—Ç–µ—Ç–µ —Ç–æ–∑–∏ –∫–æ–¥: abc123, –∑–∞ –¥–∞ –º–æ–∂–µ–º –¥–∞ –ø—Ä–æ—Å–ª–µ–¥–∏–º –ø—Ä–æ–±–ª–µ–º–∞.‚Äú_

- **Exception Handler Middleware** ‚Äì –≥–ª–æ–±–∞–ª–µ–Ω –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞ –∏–∑–∫–ª—é—á–µ–Ω–∏—è –∑–∞ production —Å—Ä–µ–¥–∞.

- **Status Code Pages** ‚Äì –ø–æ–∑–≤–æ–ª—è–≤–∞ –ø–æ–∫–∞–∑–≤–∞–Ω–µ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü–∏ –∑–∞ —Ä–∞–∑–ª–∏—á–Ω–∏ HTTP —Å—Ç–∞—Ç—É—Å –∫–æ–¥–æ–≤–µ (–Ω–∞–ø—Ä. 404, 500).

- **Exception Filters (–≤ MVC)** ‚Äì –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è—Ç –Ω–∞—á–∏–Ω –∑–∞ —É–ª–∞–≤—è–Ω–µ –Ω–∞ –≥—Ä–µ—à–∫–∏ –Ω–∞ –Ω–∏–≤–æ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä –∏–ª–∏ –¥–µ–π—Å—Ç–≤–∏–µ.

- **`ModelState` Validation** ‚Äì –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ –≤—Ö–æ–¥–Ω–∏—Ç–µ –¥–∞–Ω–Ω–∏ –æ—Ç–≥–æ–≤–∞—Ä—è—Ç –Ω–∞ –æ—á–∞–∫–≤–∞–Ω–∏—è—Ç–∞ –∏ –≥–µ–Ω–µ—Ä–∏—Ä–∞ –≥—Ä–µ—à–∫–∏ –ø—Ä–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω–∏ –º–æ–¥–µ–ª–∏.
### Status Code Pages
ASP.NET Core –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è—Ç–∞ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è—Ç –±–æ–≥–∞—Ç–∏ —Å—Ç—Ä–∞–Ω–∏—Ü–∏ –∑–∞ —Å—Ç–∞—Ç—É—Å –∫–æ–¥–æ–≤–µ.

–ó–∞ –¥–∞ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏–º —Ç–∞–∫–∏–≤–∞, —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ middleware –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ **Status Code Pages**.

`app.UseStatusCodePages();`

Middleware-—ä—Ç –º–æ–∂–µ –ª–µ—Å–Ω–æ –¥–∞ –±—ä–¥–µ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–∞–Ω.

–ü–æ–¥–¥—ä—Ä–∂–∞ –Ω—è–∫–æ–ª–∫–æ —Ä–∞–∑—à–∏—Ä—è–≤–∞—â–∏ –º–µ—Ç–æ–¥–∞. –ù–∞–ø—Ä–∏–º–µ—Ä:

```csharp
app.UseStatusCodePagesWithRedirects("/error/{0}");
// Redirects the user to a custom error page based on the status code.
```

```csharp
app.UseStatusCodePagesWithReExecute("/error?code={0}");
// Re-executes the request pipeline with a modified path for the error page.
```

–í–∞–∂–Ω–æ –µ –¥–∞ –Ω–∞–ø—Ä–∞–≤–∏–º —Ä–∞–∑–ª–∏–∫–∞ –º–µ–∂–¥—É `UseStatusCodePagesWithRedirects` –∏ `UseStatusCodePagesWithReExecute`, –∑–∞—â–æ—Ç–æ –º–∞–∫–∞—Ä –∏ –¥–≤–µ—Ç–µ –¥–∞ –≤–æ–¥—è—Ç –¥–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞ –≥—Ä–µ—à–∫–∞, –Ω–∞—á–∏–Ω—ä—Ç –ø–æ –∫–æ–π—Ç–æ —Å–µ —Å–ª—É—á–≤–∞ —Ç–æ–≤–∞ –∏–º–∞ –∑–Ω–∞—á–µ–Ω–∏–µ –∑–∞ –ø—Ä–∞–≤–∏–ª–Ω–æ—Ç–æ –æ—Ç—Ä–∞–∑—è–≤–∞–Ω–µ –Ω–∞ —Å—Ç–∞—Ç—É—Å –∫–æ–¥–∞.
–ü—Ä–∏ `UseStatusCodePagesWithRedirects`, –∫–ª–∏–µ–Ω—Ç—ä—Ç –ø–æ–ª—É—á–∞–≤–∞ HTTP —Å—Ç–∞—Ç—É—Å 302 (Redirect), —Å–ª–µ–¥ –∫–æ–µ—Ç–æ —Å–ª–µ–¥–≤–∞ –Ω–æ–≤–∞ –∑–∞—è–≤–∫–∞, –∫–æ—è—Ç–æ –≤—Ä—ä—â–∞ —Å—Ç–∞—Ç—É—Å 200. –¢–æ–≤–∞ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ –≤ **Network** —Ç–∞–±–∞ –Ω–∞ –±—Ä–∞—É–∑—ä—Ä–∞ –Ω—è–º–∞ –¥–∞ –≤–∏–¥–∏–º –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏—è —Å—Ç–∞—Ç—É—Å –∫–æ–¥ –Ω–∞ –≥—Ä–µ—à–∫–∞—Ç–∞, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä 404 ‚Äî –≤–∏–∂–¥–∞–º–µ —Å–∞–º–æ 302 –∏ 200.
–û—Ç –¥—Ä—É–≥–∞ —Å—Ç—Ä–∞–Ω–∞, `UseStatusCodePagesWithReExecute` –ø—Ä–µ–∏–∑–ø—ä–ª–Ω—è–≤–∞ –∑–∞—è–≤–∫–∞—Ç–∞ –≤—ä—Ç—Ä–µ—à–Ω–æ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞, –±–µ–∑ –¥–∞ –ø—Ä–∞–≤–∏ –≤—ä–Ω—à–µ–Ω redirect. –¢–∞–∫–∞ –∫—Ä–∞–π–Ω–∏—è—Ç –æ—Ç–≥–æ–≤–æ—Ä –∫—ä–º –∫–ª–∏–µ–Ω—Ç–∞ –∑–∞–ø–∞–∑–≤–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏—è —Å—Ç–∞—Ç—É—Å –∫–æ–¥ –Ω–∞ –≥—Ä–µ—à–∫–∞—Ç–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä 404, –∫–æ–µ—Ç–æ –µ –ø—Ä–∞–≤–∏–ª–Ω–æ—Ç–æ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –∏ –ø–æ-–∞–¥–µ–∫–≤–∞—Ç–Ω–æ –∑–∞ –¥–µ–±—ä–≥–≤–∞–Ω–µ, –ª–æ–≥–≤–∞–Ω–µ –∏ SEO. –ü–æ—Ä–∞–¥–∏ —Ç–æ–≤–∞ –µ –∂–µ–ª–∞—Ç–µ–ª–Ω–æ –≤–∏–Ω–∞–≥–∏ –¥–∞ –ø–æ–ª–∑–≤–∞–º–µ `UseStatusCodePagesWithReExecute`.
## Middleware
Middleware –µ —Å–æ—Ñ—Ç—É–µ—Ä–µ–Ω –∫–æ–º–ø–æ–Ω–µ–Ω—Ç, –∫–æ–π—Ç–æ —Å–µ —Å–≥–ª–æ–±—è–≤–∞ –≤—ä–≤ –≤–µ—Ä–∏–≥–∞—Ç–∞ –Ω–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ –Ω–∞ –¥–∞–¥–µ–Ω–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ. –¢–æ–π –æ—Ç–≥–æ–≤–∞—Ä—è –Ω–∞ ‚Äû–∫—Ä–∞–Ω—á–µ—Ç–∞—Ç–∞‚Äú –≤ –Ω–∞—à–∏—è pipeline.

–í—Å–µ–∫–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç:

–û–±—Ä–∞–±–æ—Ç–≤–∞ –∑–∞—è–≤–∫–∏ –∏ –æ—Ç–≥–æ–≤–æ—Ä–∏.

–ò–∑–±–∏—Ä–∞ –¥–∞–ª–∏ –¥–∞ –ø—Ä–µ–¥–∞–¥–µ –∑–∞—è–≤–∫–∞—Ç–∞ –∫—ä–º —Å–ª–µ–¥–≤–∞—â–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –≤—ä–≤ –≤–µ—Ä–∏–≥–∞—Ç–∞.

–ú–æ–∂–µ –¥–∞ –∏–∑–≤—ä—Ä—à–∏ —Ä–∞–±–æ—Ç–∞ –ø—Ä–µ–¥–∏ –∏–ª–∏ —Å–ª–µ–¥ –∫–∞—Ç–æ –±—ä–¥–µ –∏–∑–≤–∏–∫–∞–Ω —Å–ª–µ–¥–≤–∞—â–∏—è—Ç –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –≤—ä–≤ –≤–µ—Ä–∏–≥–∞—Ç–∞.

–í ASP.NET Core, request –¥–µ–ª–µ–≥–∞—Ç–∏—Ç–µ –∏–∑–≥—Ä–∞–∂–¥–∞—Ç –≤–µ—Ä–∏–≥–∞—Ç–∞ –∑–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ –∑–∞—è–≤–∫–∏.

–ö–æ–≥–∞—Ç–æ –¥–æ–π–¥–µ –¥–∞–¥–µ–Ω–∞ –∑–∞—è–≤–∫–∞, —Ç—è –º–∏–Ω–∞–≤–∞ –ø—Ä–µ–∑ –≤—Å–∏—á–∫–∏ middleware –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –¥–≤–∞ –ø—ä—Ç–∏ ‚Äî –≤–µ–¥–Ω—ä–∂ –∫–∞—Ç–æ **request**, –ø—Ä–µ–¥–∏ –¥–∞ —Å–µ –æ–±—Ä–∞–±–æ—Ç–∏, –∏ –≤–µ–¥–Ω—ä–∂ –∫–∞—Ç–æ **response**, –∫–æ–≥–∞—Ç–æ –æ—Ç–≥–æ–≤–æ—Ä—ä—Ç —Å–µ –≤—Ä—ä—â–∞ –∫—ä–º –∫–ª–∏–µ–Ω—Ç–∞.
–ú–æ–∂–µ–º –¥–∞ –æ–±—Ä–∞–±–æ—Ç–∏–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏ –Ω–µ—â–∞ –ø—Ä–∏ –ø—ä—Ä–≤–æ—Ç–æ –º–∏–Ω–∞–≤–∞–Ω–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä –ª–æ–≥–≤–∞–Ω–µ –Ω–∞ –∑–∞—è–≤–∫–∞—Ç–∞) –∏ –¥—Ä—É–≥–∏ –ø—Ä–∏ –≤—Ç–æ—Ä–æ—Ç–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–∞–Ω–µ –Ω–∞ –æ—Ç–≥–æ–≤–æ—Ä–∞).
–ó–∞ –¥–∞ –Ω–µ —Å–µ –ø—Ä–µ–∫—ä—Å–Ω–µ pipeline-—ä—Ç, —Å–µ –≤–∏–∫–∞ –º–µ—Ç–æ–¥—ä—Ç `next()`, –∫–æ–π—Ç–æ –∏–∑–≤–∏–∫–≤–∞ —Å–ª–µ–¥–≤–∞—â–∏—è middleware:

```csharp
app.Use(async (context, next) =>
{
    // Code before next() ‚Äî runs during the request phase

    await next();

    // Code after next() ‚Äî runs during the response phase
});
```

–ê–∫–æ –Ω—è–∫–æ–π middleware –Ω–µ –∏–∑–≤–∏–∫–∞ `next()`, —Ç–æ–≥–∞–≤–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ pipeline-–∞ —Å–ø–∏—Ä–∞ –¥–æ—Ç–∞–º –∏ –æ—Ç–≥–æ–≤–æ—Ä—ä—Ç —Å–µ –≤—Ä—ä—â–∞ –¥–∏—Ä–µ–∫—Ç–Ω–æ –∫—ä–º –∫–ª–∏–µ–Ω—Ç–∞. –¢–æ–≤–∞ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ –Ω–∏—Ç–æ –µ–¥–∏–Ω –æ—Ç —Å–ª–µ–¥–≤–∞—â–∏—Ç–µ middleware-–∏ –Ω—è–º–∞ –¥–∞ –±—ä–¥–µ –∏–∑–≤–∏–∫–∞–Ω, –Ω–∏—Ç–æ —â–µ —Å–µ –∏–∑–ø—ä–ª–Ω—è—Ç –¥–µ–π—Å—Ç–≤–∏—è—Ç–∞, –∫–æ–∏—Ç–æ —Å–∞ –Ω–∞–ø–∏—Å–∞–Ω–∏ _—Å–ª–µ–¥_ `await next()` –≤ –ø—Ä–µ–¥—Ö–æ–¥–Ω–∏—Ç–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏.
### Request Delegates
Request –¥–µ–ª–µ–≥–∞—Ç–∏—Ç–µ –æ–±—Ä–∞–±–æ—Ç–≤–∞—Ç –≤—Å—è–∫–∞ HTTP –∑–∞—è–≤–∫–∞ –∏ —Å–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞—Ç —á—Ä–µ–∑ —Ä–∞–∑—à–∏—Ä—è–≤–∞—â–∏—Ç–µ –º–µ—Ç–æ–¥–∏ `Run()`, `Map()` –∏ `Use()`.

Request –¥–µ–ª–µ–≥–∞—Ç–∏—Ç–µ (–Ω–∞—Ä–∏—á–∞–Ω–∏ –æ—â–µ middleware –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏) –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç:

- –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏ –¥–∏—Ä–µ–∫—Ç–Ω–æ –∫–∞—Ç–æ –∞–Ω–æ–Ω–∏–º–Ω–∏ –º–µ—Ç–æ–¥–∏ (inline middleware).

- –î–µ—Ñ–∏–Ω–∏—Ä–∞–Ω–∏ –≤ –ø—Ä–µ–∏–∑–ø–æ–ª–∑–≤–∞–µ–º –∫–ª–∞—Å.

–í—Å–µ–∫–∏ middleware –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Ç—Ä—è–±–≤–∞:

- –î–∞ –∏–∑–≤–∏–∫–∞ —Å–ª–µ–¥–≤–∞—â–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –≤—ä–≤ –≤–µ—Ä–∏–≥–∞—Ç–∞ –∏–ª–∏ –¥–∞ –ø—Ä–µ–∫—ä—Å–Ω–µ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ pipeline-–∞.

```csharp
app.Use(async (context, next) =>
{
    // Logic before passing to the next middleware

    await next();

    // Logic after the next middleware has completed
});
```

–ú–µ—Ç–æ–¥—ä—Ç `Use()` —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞, –∑–∞ –¥–∞ —Å–≤—ä—Ä–∂–µ–º –Ω—è–∫–æ–ª–∫–æ –¥–µ–ª–µ–≥–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–æ. –¢–æ–π –º–æ–∂–µ –¥–∞ –ø—Ä–µ–∫—ä—Å–Ω–µ pipeline-–∞, –∞–∫–æ –Ω–µ –∏–∑–≤–∏–∫–∞ `next()`.

–ü—ä—Ä–≤–∏—è—Ç `Run()` –¥–µ–ª–µ–≥–∞—Ç –ø—Ä–µ–∫—Ä–∞—Ç—è–≤–∞ pipeline-–∞.

- `Run()` –µ –ø–æ-—Å–∫–æ—Ä–æ –∫–æ–Ω–≤–µ–Ω—Ü–∏—è ‚Äî –Ω—è–∫–æ–∏ middleware-–∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è—Ç –º–µ—Ç–æ–¥–∏ –æ—Ç —Ç–∏–ø–∞ `Run{Middleware}`, –∫–æ–∏—Ç–æ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞—Ç –≤ –∫—Ä–∞—è –Ω–∞ –≤–µ—Ä–∏–≥–∞—Ç–∞.

–ú–µ—Ç–æ–¥—ä—Ç `Map()` —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –∑–∞ —Ä–∞–∑–∫–ª–æ–Ω—è–≤–∞–Ω–µ –Ω–∞ pipeline-–∞.

```csharp
app.Map("/admin", adminApp =>
{
    adminApp.Run(async context =>
    {
        await context.Response.WriteAsync("Admin section");
    });
});
```

- Request pipeline-—ä—Ç —Å–µ —Ä–∞–∑–∫–ª–æ–Ω—è–≤–∞ —Å–ø–æ—Ä–µ–¥ –∑–∞–¥–∞–¥–µ–Ω–∏—è –ø—ä—Ç –≤ –∑–∞—è–≤–∫–∞—Ç–∞.

`Use()`, `Run()` –∏ `Map()` —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –∑–∞ –∏–∑–≥—Ä–∞–∂–¥–∞–Ω–µ –Ω–∞ —Ç.–Ω–∞—Ä. **request pipeline** ‚Äì —Ç–æ–≤–∞ –µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–æ—Å—Ç—Ç–∞ –æ—Ç middleware –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏, –∫–æ–∏—Ç–æ –æ–±—Ä–∞–±–æ—Ç–≤–∞—Ç –≤—Å—è–∫–∞ HTTP –∑–∞—è–≤–∫–∞.

**`Use()`**

`Use()` –¥–æ–±–∞–≤—è middleware, –∫–æ–π—Ç–æ –º–æ–∂–µ –¥–∞ –∏–∑–≤—ä—Ä—à–∏ –¥–µ–π—Å—Ç–≤–∏—è **–ø—Ä–µ–¥–∏ –∏/–∏–ª–∏ —Å–ª–µ–¥** –æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –≤ pipeline-–∞. –¢–æ–π –ø—Ä–∏–µ–º–∞ –¥–µ–ª–µ–≥–∞—Ç —Å –ø–∞—Ä–∞–º–µ—Ç—ä—Ä `next`, –∫–æ–π—Ç–æ –¥–∞ –∏–∑–≤–∏–∫–∞ —Å–ª–µ–¥–≤–∞—â–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç. –ê–∫–æ –Ω–µ –≥–æ –∏–∑–≤–∏–∫–∞, –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ —Å–µ –ø—Ä–µ–∫—ä—Å–≤–∞. –ù–∞–π-—á–µ—Å—Ç–æ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞, –∫–æ–≥–∞—Ç–æ –∏—Å–∫–∞–º–µ –¥–∞ –¥–æ–±–∞–≤–∏–º –ª–æ–≥–∏–∫–∞, –∫–æ—è—Ç–æ –¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞ –∑–∞ –≤—Å–∏—á–∫–∏ –∑–∞—è–≤–∫–∏ ‚Äì –Ω–∞–ø—Ä–∏–º–µ—Ä –ª–æ–≥–≤–∞–Ω–µ, –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –∞–≤—Ç–µ–Ω—Ç–∏–∫–∞—Ü–∏—è –∏ —Ç.–Ω.

**`Map()`**

`Map()` —Å—ä–∑–¥–∞–≤–∞ **—Ä–∞–∑–∫–ª–æ–Ω–µ–Ω–∏–µ** –Ω–∞ pipeline-–∞ ‚Äì —Ç–æ–µ—Å—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ —â–µ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞ —Å–∞–º–æ –∞–∫–æ –∑–∞—è–≤–∫–∞—Ç–∞ —Å—ä–≤–ø–∞–¥–∞ —Å –¥–∞–¥–µ–Ω –ø—ä—Ç (URL —Å–µ–≥–º–µ–Ω—Ç). –¢–∞–∫–∞ –º–æ–∂–µ–º –¥–∞ –∏–∑–≥—Ä–∞–¥–∏–º —Ä–∞–∑–ª–∏—á–Ω–∏ ‚Äû–ø–æ–¥-pipeline-–∏‚Äú –∑–∞ —Ä–∞–∑–ª–∏—á–Ω–∏ –ø—ä—Ç–∏—â–∞ ‚Äì –Ω–∞–ø—Ä–∏–º–µ—Ä `/admin`, `/api`, –∏ —Ç.–Ω. –í—ä—Ç—Ä–µ –≤ `Map()` –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –æ—Ç–Ω–æ–≤–æ `Use()` –∏–ª–∏ `Run()`.

**`Run()`**

`Run()` —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –∑–∞ –¥–æ–±–∞–≤—è–Ω–µ –Ω–∞ **–∫—Ä–∞–µ–Ω middleware**. –¢–æ–π –Ω–µ –ø—Ä–∏–µ–º–∞ `next`, —Ç–æ–µ—Å—Ç **–Ω–µ –ø—Ä–µ–¥–∞–≤–∞ –∑–∞—è–≤–∫–∞—Ç–∞ –Ω–∞—Ç–∞—Ç—ä–∫**. –û–±–∏–∫–Ω–æ–≤–µ–Ω–æ –≥–æ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –≤ –∫—Ä–∞—è –Ω–∞ pipeline-–∞, –∫–æ–≥–∞—Ç–æ –∏—Å–∫–∞–º–µ –¥–∞ –∏–∑–ø—Ä–∞—Ç–∏–º —Ñ–∏–Ω–∞–ª–µ–Ω –æ—Ç–≥–æ–≤–æ—Ä –Ω–∞ –∫–ª–∏–µ–Ω—Ç–∞. –°–ª–µ–¥ `Run()` –Ω–∏—â–æ –¥—Ä—É–≥–æ –Ω—è–º–∞ –¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω–∏.
### Creating Your Own Middleware (Inline)
ASP.NET Core Request Pipeline –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–≤–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–æ—Å—Ç –æ—Ç _Request Delegates_, –∫–æ–∏—Ç–æ —Å–µ –∏–∑–≤–∏–∫–≤–∞—Ç –µ–¥–∏–Ω —Å–ª–µ–¥ –¥—Ä—É–≥.

–ù–∏–µ —Å—ä–∑–¥–∞–≤–∞–º–µ —Å–≤–æ–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–∏ _Request Delegates_ —á—Ä–µ–∑ –æ–±–µ–∫—Ç–∞ `IApplicationBuilder`.

```csharp
app.Use(async (context, next) =>
{
    // Do work that doesn't write to the Response.
    
    await next();
    
    // Do logging or other work that doesn't write to the Response.
});

//Other code below...
```

–¢–æ–≤–∞ –µ –ø—Ä–∏–º–µ—Ä –∑–∞ —Å—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω middleware inline ‚Äì —Ç–æ–µ—Å—Ç –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –∫–æ–¥–∞, –±–µ–∑ –æ—Ç–¥–µ–ª–µ–Ω –∫–ª–∞—Å.

–°–ª–µ–¥ —Ç–æ–∑–∏ middleware –º–æ–∂–µ –¥–∞ –∏–º–∞ –∏ –¥—Ä—É–≥ –∫–æ–¥, –∫–æ–π—Ç–æ —â–µ —Å–µ –∏–∑–ø—ä–ª–Ω–∏, –∞–∫–æ `await next()` –±—ä–¥–µ –∏–∑–≤–∏–∫–∞–Ω.

–ù–µ —Ç—Ä—è–±–≤–∞ –¥–∞ –ø–∏—à–µ–º –ø–æ response-a –∑–∞—â–æ—Ç–æ –≤—Å—è–∫–∞ –ø—Ä–æ–º—è–Ω–∞ —â–µ –¥–æ–≤–µ–¥–µ –¥–æ short-circuit.
### Creating Your Own Middleware (Class)
Request delegates –º–æ–≥–∞—Ç —Å—ä—â–æ –¥–∞ –±—ä–¥–∞—Ç –¥–µ—Ñ–∏–Ω–∏—Ä–∞–Ω–∏ –∫–∞—Ç–æ –∫–ª–∞—Å–æ–≤–µ.

–°—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω Middleware (–∫–ª–∞—Å):

```csharp
public class CustomMiddleware
{
    // The next delegate in the pipeline
    private readonly RequestDelegate next;

    public CustomMiddleware(RequestDelegate next)
    {
        this.next = next;
    }

    // IMyService is injected into InvokeAsync through DI
    public async Task InvokeAsync(HttpContext httpContext, IMyService svc) 
    {
        svc.MyProperty = 1000;
        await this.next(httpContext);
    }
}
```

–ö–æ–≥–∞—Ç–æ —Å—ä–∑–¥–∞–≤–∞–º–µ middleware –∫–∞—Ç–æ –∫–ª–∞—Å, –Ω–∏–µ –≥–æ –ø—Ä–∞–≤–∏–º –ø–æ-–æ—Ä–≥–∞–Ω–∏–∑–∏—Ä–∞–Ω–æ –∏ –ø–æ–¥—Ö–æ–¥—è—â–æ –∑–∞ –ø–æ–≤—Ç–æ—Ä–Ω–∞ —É–ø–æ—Ç—Ä–µ–±–∞. –ú–æ–∂–µ–º —Å—ä—â–æ —Ç–∞–∫–∞ –ª–µ—Å–Ω–æ –¥–∞ –∏–Ω–∂–µ–∫—Ç–∏—Ä–∞–º–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤ –º–µ—Ç–æ–¥–∞ `InvokeAsync`. –¢–æ–≤–∞ –ø–æ–∑–≤–æ–ª—è–≤–∞ –¥–∞ –≤–∫–ª—é—á–∏–º –ª–æ–≥–∏–∫–∞ –∏–ª–∏ –ø–æ–≤–µ–¥–µ–Ω–∏–µ, –∫–æ–µ—Ç–æ –º–æ–∂–µ –¥–∞ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –≤ —Ä–∞–∑–ª–∏—á–Ω–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –∏–ª–∏ —Å—Ü–µ–Ω–∞—Ä–∏–∏.

–ó–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ —Å–æ–±—Å—Ç–≤–µ–Ω Middleware –∫–ª–∞—Å, —Ç—Ä—è–±–≤–∞ –¥–∞ –≥–æ –≤–∫–ª—é—á–∏–º –≤ pipeline-–∞.

```csharp
public static class CustomMiddlewareExtensions
{
    public static IApplicationBuilder UseCustom(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<CustomMiddleware>();
    }
}
```

–°–ª–µ–¥ —Ç–æ–≤–∞ –Ω–∏–µ –¥–æ–±–∞–≤—è–º–µ middleware-–∞ –≤ pipeline-–∞ —Å:

```csharp
app.UseCustom();
```

–¢–∞–∫–∞ –Ω–∞—à–∏—è—Ç middleware —Å–µ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–∞ –∏ —â–µ –±—ä–¥–µ –∏–∑–≤–∏–∫–∞–Ω –∑–∞ –≤—Å—è–∫–∞ –∑–∞—è–≤–∫–∞, –º–∏–Ω–∞–≤–∞—â–∞ –ø—Ä–µ–∑ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ.

–° —Ç–æ–∑–∏ –º–µ—Ç–æ–¥ —Ä–∞–∑—à–∏—Ä—è–≤–∞–º–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ `IApplicationBuilder`, –∑–∞ –¥–∞ –º–æ–∂–µ–º —É–¥–æ–±–Ω–æ –¥–∞ –¥–æ–±–∞–≤–∏–º –Ω–∞—à–∏—è `CustomMiddleware` –≤ pipeline-–∞ —Å –ø—Ä–æ—Å—Ç–æ –∏–∑–≤–∏–∫–≤–∞–Ω–µ –Ω–∞ `app.UseCustom()`.

–¢–∞–∫–∞ –ø—Ä–∞–≤–∏–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è—Ç–∞ –Ω–∞ middleware-–∞ –ø–æ-—á–µ—Ç–ª–∏–≤–∞ –∏ —É–¥–æ–±–Ω–∞, –≤–º–µ—Å—Ç–æ –¥–∞ –ø–∏—à–µ–º –¥–∏—Ä–µ–∫—Ç–Ω–æ `app.UseMiddleware<CustomMiddleware>()` –Ω–∞–≤—Å—è–∫—ä–¥–µ.
### Built-in Middleware
# Misc
# ChatGPT
## Configuration Model
So at the beginning of an ASP.NET application, is the configuration being built and loaded into a key-value structure, similar to a dictionary, where both keys and values are strings?

**ChatGPT said:**

Yes, exactly ‚Äî your understanding is correct.

Here‚Äôs what happens step by step:

1. **`WebApplication.CreateBuilder(args)`**  
    This initializes the **`WebApplicationBuilder`**, which:
    
    - Loads configuration from sources (like `appsettings.json`, environment variables, etc.).
        
    - Sets up the **dependency injection (DI) container**.
        
    - Prepares logging, environment info, and other infrastructure.
        
2. **`builder.Configuration.GetConnectionString("SQLServer")`**  
    This retrieves the connection string defined in your configuration (most often from `appsettings.json`).
    
3. **`builder.Services`**  
    This is where you register services (like `DbContexts`, identity, middleware-related services, custom services, etc.) into the **DI container**, so they can be injected and used throughout the app.

So in short:  
‚úÖ The builder reads and prepares the configuration.  
‚úÖ Then you register the services.  
‚úÖ After that, you build and run the app.

**You said:**

All the configuration settings are available in the builder, and when we call `GetConnectionString("SQLServer")`, are we just retrieving the value associated with the "`SQLServer`" key from the configuration system?

**ChatGPT said:**

Yes ‚Äî that's exactly how it works behind the scenes.

Here's the breakdown:

- When you call `WebApplication.CreateBuilder(args)`, the builder loads configuration from various sources (like `appsettings.json`, `environment variables`, `user secrets`, etc.).
    
- All these sources are merged into a **single configuration system**, which behaves like a **key-value dictionary** (`IConfiguration` under the hood).

So when you write:

```csharp
string connectionString = builder.Configuration.GetConnectionString("SQLServer");
```

You're effectively doing this:

- Look for a key named **"`ConnectionStrings:SQLServer`"** in the configuration data.
    
- If found, return its value.

The `.GetConnectionString("SQLServer")` method is just a helper that looks up the key using the prefix `ConnectionStrings:`.

**Example:**

In `appsettings.json`:

```json
{
  "ConnectionStrings": {
    "SQLServer": "Server=.;Database=MyDb;Trusted_Connection=True;"
  }
}
```

This will be flattened into the key:

```
ConnectionStrings:SQLServer ‚Üí "Server=.;Database=MyDb;Trusted_Connection=True;"
```

So yes ‚Äî the `Configuration` is just a dictionary-like store, and you‚Äôre asking for a specific key when calling `.GetConnectionString()`.
## Two main ways to access configuration values in ASP.NET Core
‚úÖ **Option 1: `configuration["KeyPath"]` (Indexer Access)**

**Example:**

```csharp
var value = configuration["Logging:LogLevel:Default"];
```

**Characteristics:**

- **Returns `string?`** (nullable string).
    
- Simple and direct.
    
- **No type conversion** ‚Äì it's always a string or `null`.
    
- If the key doesn't exist ‚Üí returns `null`.

‚úÖ **Option 2: `configuration.GetValue<T>("KeyPath")`**

**Example:**

```csharp
var value = configuration.GetValue<string>("Logging:LogLevel:Default");
```

**Characteristics:**

- **Strongly typed** access.
    
- **Performs conversion** from string to the type you request (`int`, `bool`, etc).
    
- If the key doesn't exist ‚Üí returns `default(T)` (e.g., `null` for `string`, `0` for `int`, etc).
    
- You can also specify a fallback default value:

```csharp
var level = configuration.GetValue("Logging:LogLevel:Default", "Info");
```

üîç **Which One to Use?**

|Use Case|Prefer This|
|---|---|
|You just need a string|Either works|
|You need to convert to a number/bool|`GetValue<T>()`|
|You want to specify a fallback value|`GetValue<T>()`|
|You want to bind an entire section|`GetSection()` (separate topic)|
|You don‚Äôt care about null safety|Indexer is fine|

üìù **Summary**

- Use `configuration["Key"]` for **quick string access**.
    
- Use `configuration.GetValue<T>()` for **type-safe and fallback-friendly access**.
## Extension Methods on Interfaces
Extension methods defined for an interface are available on all classes that implement that interface. This means that whether a variable is typed as the interface or as a class implementing it, you can call the extension method on that variable. The compiler resolves extension methods based on the variable‚Äôs type and the interfaces it implements, allowing you to extend the functionality of all implementations without modifying their code.

Example:

```csharp
public interface IMyInterface
{
    void DoSomething();
}

public class ClassA : IMyInterface
{
    public void DoSomething() { }
}

public class ClassB : IMyInterface
{
    public void DoSomething() { }
}

public static class MyInterfaceExtensions
{
    public static void MyExtension(this IMyInterface instance)
    {
        Console.WriteLine("Extension method called");
    }
}

// Usage:
IMyInterface a = new ClassA();
IMyInterface b = new ClassB();

a.MyExtension();  // Works!
b.MyExtension();  // Works too!
```

This way, you can add methods to all implementations of an interface easily through extension methods.
## Scope
In .NET Dependency Injection (DI), a **scope** is a **lifetime boundary** for services registered with `AddScoped`.

- A **scoped service** is created once **per scope**.
    
- In ASP.NET Core, **each HTTP request automatically creates a scope** behind the scenes.
    
- `CreateScope()` is how you **manually start a scope**, useful in:
    
    - background services
        
    - console apps
        
    - or places **outside** of the normal HTTP request pipeline

üß± **What `CreateScope()` does:**

```csharp
using (var scope = serviceProvider.CreateScope())
{
    var myService = scope.ServiceProvider.GetRequiredService<IMyService>();
    myService.DoWork();
}
```

- `CreateScope()` gives you a **new `IServiceScope`**.
    
- `scope.ServiceProvider` gives access to services **within that scope**.
    
- When the scope is disposed (`using` block), all **scoped services are disposed**, ensuring proper cleanup.

‚úÖ **When should you use it?**

Use `CreateScope()` when you:

- Need to resolve services that are `Scoped`, but you're **outside of a request**, such as:
    
    - In a `BackgroundService`
        
    - In `Main()` of a console app
        
    - In a long-running worker process

‚ùó **Don‚Äôt use it just anywhere**

If you're **already inside a controller or middleware**, you **don‚Äôt need to call `CreateScope()`** ‚Äî the framework already handles it for each request.
##  Connection Pooling

**Connection pooling** is a technique to improve performance by reusing existing database connections instead of opening a new one every time.

Think of it like reusing the same taxi instead of calling a new one for every ride.

‚öôÔ∏è **How It Works in ASP.NET & EF**

When you use **Entity Framework** (EF Core or EF6) with a database like SQL Server, the underlying **ADO.NET provider** (e.g., `SqlClient`) manages the connection pool **automatically**.

- When `DbContext.Database.OpenConnection()` or `context.SaveChanges()` is called, EF opens a connection.
    
- If a connection is available in the pool, it reuses it.
    
- If not, it opens a new one (up to the max pool size).

After the operation, the connection is **returned** to the pool, **not closed**.

‚úÖ **Benefits**

- **Reduced overhead** of opening and closing connections.
    
- **Improved scalability** for web applications.
    
- **Better performance** under load.

üß† **Important Parameters (Connection String)**

You can control connection pooling using parameters in your connection string:

```csharp
"Server=.;Database=MyDb;Trusted_Connection=True;Max Pool Size=100;Min Pool Size=5;"
```

|Parameter|Description|
|---|---|
|`Max Pool Size`|Maximum number of connections in the pool|
|`Min Pool Size`|Minimum number of connections kept alive|
|`Pooling=true`|Enables pooling (default is true)|
|`Connection Timeout`|Timeout for getting a connection from the pool|

üí° **Best Practices**

1. **Use `using` statements**  
    Always wrap your `DbContext` in `using` or dispose it properly so connections return to the pool:
    
```csharp
using (var context = new MyDbContext())
{
    // Your logic here
}
```
    
2. **Avoid long-lived contexts**  
    Don‚Äôt hold `DbContext` instances open too long (especially in ASP.NET apps).
    
3. **Minimize concurrent connection usage**  
    Use async operations when possible (`await context.SaveChangesAsync()`).

üîç **How to Monitor It**

You can monitor connection pool behavior using:

- **Performance counters** (`.NET Data Provider for SqlServer`)
    
- **SQL Server Profiler**
    
- **EF logging** (`EnableSensitiveDataLogging`, `LogTo`)

üß™ **Troubleshooting Tips**

- **Timeout errors?** You might be exhausting the pool. Increase `Max Pool Size` or fix context disposal.
    
- **Too many open connections?** Check for missing `Dispose()` or `using`.

**You said:**

This is similar to how a thread pool operates in asynchronous programming, right?

**ChatGPT said:**

Great question! The concepts of **connection pooling** and **thread pooling** are related in that both aim to improve performance by reusing resources, but they are different in what exactly they manage and how they work. Here‚Äôs a quick comparison to clarify:

**Connection Pool vs Thread Pool ‚Äî What‚Äôs Similar and What‚Äôs Different?**

|Aspect|Connection Pool|Thread Pool|
|---|---|---|
|**What is managed?**|Reuses **database connections** to avoid overhead opening/closing DB connections.|Reuses **threads** to avoid overhead creating/destroying threads for tasks.|
|**Purpose**|Reduce the expensive cost of opening DB connections multiple times.|Efficiently manage threads for parallel/asynchronous operations.|
|**When is it used?**|Whenever the app needs to talk to the database (via ADO.NET, EF).|Whenever async or parallel work is done (e.g., Task.Run, async/await).|
|**How reuse works?**|Connections are pooled and returned after use, ready for next DB call.|Threads are reused to run different tasks sequentially or in parallel.|
|**Pooling lifetime**|Pool is managed per connection string, lives as long as app runs.|Thread pool lives as long as the process runs and manages threads dynamically.|
|**Example in ASP.NET**|Reusing SQL Server connections via EF `DbContext`.|Reusing threads for asynchronous controller actions or background tasks.|

**So: Are They Similar?**

**Yes, conceptually** ‚Äî both improve efficiency by avoiding costly resource creation.

**But practically, they are managing very different things:**

- **Connection pooling:** optimizes database connection management.
    
- **Thread pooling:** optimizes CPU-bound or async task execution.

**How Do They Work Together in ASP.NET?**

When you use async operations in ASP.NET with EF:

- Your code may run on a **thread from the thread pool**.
    
- EF uses **connection pooling** to get a DB connection quickly without waiting.
    
- Async frees up threads while waiting on I/O (like DB), improving throughput.
    
- Connection pool ensures fast DB access without waiting for new connections.

**Quick analogy:**

- **Thread pool** is like a pool of workers ready to do tasks.
    
- **Connection pool** is like a fleet of cars ready to drive workers around (DB calls).

Both make the system faster by **reusing resources efficiently**.
## Understanding `app.Use()` Middleware in ASP.NET Core
1. **What does `app.Use()` do?**

- The `Use` method lets you **add middleware components** to the ASP.NET Core HTTP request pipeline.
    
- Middleware are small pieces of code that can **inspect, modify, or short-circuit** HTTP requests and responses.
    
- Each middleware has this signature:

```csharp
Func<HttpContext, Func<Task>, Task>
```

This means:

- It accepts an `HttpContext` (current HTTP request and response info).
    
- It accepts a `Func<Task>` called `next`, which represents the **next middleware in the pipeline**.
    
- It returns a `Task` because the middleware typically performs asynchronous operations.

2. **What exactly is the `next` parameter (`Func<Task>`)?**

- **`next` is a delegate that ASP.NET Core provides for you.**
    
- It represents the **next middleware in the chain**, wrapped as a `Func<Task>` delegate.
    
- When you call:

```csharp
await next();
```

you‚Äôre telling ASP.NET Core:

> _‚ÄúRun the next middleware in the pipeline now.‚Äù_

- You do **not** build or supply `next` yourself. The framework constructs and passes it in for you behind the scenes.

3. **How is the middleware pipeline built?**

When you write multiple middleware registrations:

```csharp
app.Use(MiddlewareA);
app.Use(MiddlewareB);
app.Use(MiddlewareC);
```

ASP.NET Core builds a **middleware pipeline** under the hood by **nesting each middleware inside the previous one**, kind of like this conceptually:

```csharp
context => MiddlewareA(context, 
    () => MiddlewareB(context, 
        () => MiddlewareC(context, 
            () => terminalMiddleware(context)
        )
    )
)
```

- Each `next()` is a delegate that calls the next middleware in the pipeline.
    
- So inside `MiddlewareA`, calling `await next()` executes `MiddlewareB`, and so on.

4. **What does a typical middleware look like?**

Example middleware:

```csharp
app.Use(async (context, next) =>
{
    Console.WriteLine("Middleware A - Before");

    await next(); // Pass control to Middleware B

    Console.WriteLine("Middleware A - After");
});
```

- You can run code **before** and **after** calling `await next()`.
    
- If you choose **not to call** `next()`, the pipeline short-circuits and no later middleware runs.

5. **Visualizing the flow**

```csharp
Func<HttpContext, Func<Task>, Task> middleware = async (context, next) =>
{
    // Before
    await next(); // Invokes the *next* middleware in the chain
    // After
};
```

- ASP.NET Core **automatically constructs and injects** `next` for you.
    
- Your middleware just decides **when or if** to call `await next()`.

6. **Summary**

- `app.Use()` builds the middleware pipeline one step at a time.
    
- Each middleware receives:
    
    - The current `HttpContext`
        
    - A `next` delegate representing the next middleware
        
- The framework wires up the chain and passes the correct `next` delegate each time behind the scenes.
    
- You control the pipeline flow by calling or skipping `await next()`.

7. **Extra tips**

- Middleware ordering is critical ‚Äî it determines how requests and responses are handled.
    
- Middleware can modify requests before passing them on, or modify responses after calling `next()`.
    
- Short-circuiting (skipping `next()`) is useful for handling errors, returning early responses, or serving static files.
### How the Framework Collects `Use(...)` Middleware into One Chain

When you write:

```csharp
app.Use(MiddlewareA);
app.Use(MiddlewareB);
app.Use(MiddlewareC);
app.Run(FinalHandler);
```

ASP.NET Core doesn‚Äôt execute those right away. Instead, it **stores them in order**, and only later **builds a single chain of middleware functions**.

Here‚Äôs what happens under the hood:

üß± 1. **`app.Use(...)` Adds Middleware to a List**

Every time you call `app.Use(...)`, it adds your delegate to an internal list inside `IApplicationBuilder`.

```csharp
public class ApplicationBuilder : IApplicationBuilder
{
    private readonly List<Func<RequestDelegate, RequestDelegate>> _components 
        = new List<Func<RequestDelegate, RequestDelegate>>();

    public IApplicationBuilder Use(Func<HttpContext, Func<Task>, Task> middleware)
    {
        // Wrap your middleware into a RequestDelegate factory
        _components.Add(next => context => middleware(context, () => next(context)));
        return this;
    }
}
```

So your middleware gets wrapped in a `Func<RequestDelegate, RequestDelegate>` (we'll return to this shortly).

üî® 2. **`app.Run(...)` Adds the Terminal Middleware**

`Run(...)` is also middleware, but it's meant to be the **end of the chain**. It doesn‚Äôt call `next()`, so nothing executes after it.

It also gets wrapped and added to the list.

üß© 3. **At `app.Build()` ‚Äî All Middleware Get Composed into a Chain**

When the framework starts handling a request, it calls:

```csharp
var app = builder.Build(); // this triggers the actual pipeline construction
```

And this happens inside:

```csharp
public RequestDelegate Build()
{
    RequestDelegate app = context =>
    {
        // If no middleware is registered
        return Task.CompletedTask;
    };

    // Build in reverse order ‚Äî last registered gets executed last
    foreach (var component in _components.Reverse())
    {
        app = component(app); // Each middleware wraps the current pipeline
    }

    return app; // Final pipeline delegate
}
```

So now you have a **single `RequestDelegate`**, like:

```csharp
context => MiddlewareA(context, 
    () => MiddlewareB(context, 
        () => MiddlewareC(context, 
            () => FinalHandler(context)
        )
    )
)
```

üéØ 4. **When a Request Comes In**

The composed `RequestDelegate` is executed for each HTTP request. Each middleware:

- Receives `HttpContext`
    
- Does something **before**
    
- Calls `await next()` (which is just the next delegate)
    
- Does something **after**

üìà **Visual Flow**

```
Request
   ‚Üì
MiddlewareA
   ‚Üì
MiddlewareB
   ‚Üì
MiddlewareC
   ‚Üì
FinalHandler
```

Each `Use(...)` call builds a layer that wraps the one after it.

‚úÖ **Summary**

- `app.Use(...)` calls are stored as delegate factories
    
- `app.Build()` reverses and chains them
    
- The result is a single delegate that ASP.NET Core invokes per request
    
- The `next()` parameter is created during this composition step
    
- This allows each middleware to control when and whether the next one runs

**You said:**

Lets follow the below code in detail.

```csharp
app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.MapRazorPages(); // Add routing to Identity Razor Pages

app.Use(async (context, next) =>
{
    Console.WriteLine("before");
    await next();
    Console.WriteLine("after");
});

app.Run();
```

**ChatGPT said:**

Let's walk through **exactly what happens** in the code you posted ‚Äî step by step ‚Äî so you can understand how ASP.NET Core builds and executes the middleware pipeline.

‚úÖ **Full Code**

```csharp
app.UseAuthorization(); // 1. Middleware added: Who can access what?

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.MapRazorPages(); // 2. Adds endpoints for Razor Pages

app.Use(async (context, next) => { 
    Console.WriteLine("before"); 
    await next(); 
    Console.WriteLine("after"); 
});

app.Run();
```

üîÑ **Step-by-Step Explanation**

1. **`app.UseAuthorization();`**

This is a **built-in middleware** that enforces authorization policies.

- It doesn‚Äôt know which endpoint the user is requesting yet.
    
- It waits until **routing has been done**, so it knows what endpoint was matched, then checks if the user is allowed to access it.

> ‚ö†Ô∏è **Important**: It depends on routing metadata, which means:

- You must call `UseAuthorization()` **after `UseRouting()`**, and
    
- **Before `Map*()` methods like `MapControllers()` or `MapRazorPages()`** ‚Äî unless you're using endpoint routing, which auto-applies middleware.

In newer versions, `MapControllerRoute()` and `MapRazorPages()` call `UseRouting()` internally, so `UseAuthorization()` can be used slightly earlier.

2. `app.MapControllerRoute(...)` and `app.MapRazorPages();`

These are **endpoint mapping methods**. They register the actual routes/endpoints in the app.

- `MapControllerRoute(...)` says: ‚ÄúIf the URL looks like `/Home/Index`, call the `HomeController.Index()` method.‚Äù
    
- `MapRazorPages()` adds routes for Razor Pages (e.g., `/Account/Login`, `/Register`, etc.)
    

Under the hood, these methods call `UseEndpoints(...)` to add endpoint execution to the pipeline.

**So now:**

- The middleware chain has something to route to (controllers or pages).
    
- `UseAuthorization()` can now work with the endpoints metadata.

3. `app.Use(...)` ‚Äì Your custom middleware

```csharp
app.Use(async (context, next) => {
    Console.WriteLine("before"); 
    await next(); 
    Console.WriteLine("after"); 
});
```

This adds a **custom middleware** into the pipeline.

- It prints `before`
    
- Calls `await next()` ‚Üí which continues the pipeline (eventually hitting the matched controller/page)
    
- Then prints `after` once the response is returning back up the chain
    

> This is a very common pattern for logging, performance measurement, error catching, etc.

4. `app.Run();`

This ends the middleware pipeline. It‚Äôs the **terminal middleware** ‚Äî nothing after this will run.

> If `app.Run()` is empty, and the request has already been handled by an endpoint (like a controller), then it does nothing.
> 
> But if no endpoint handled the request, and no `Run()` was defined to handle fallback behavior (like 404), the request may return a default 404 response.

üß† **Internal Chain (Visual)**

Let‚Äôs simulate what ASP.NET Core builds:

```csharp
context => 
    UseAuthorization(context, 
        () => YourCustomMiddleware(context, 
            () => EndpointMiddleware(context)
        )
    )
```

Or, to visualize:

```
‚Üì Request comes in
‚îú‚îÄ‚îÄ UseAuthorization() middleware
‚îÇ   ‚îú‚îÄ‚îÄ checks if user is allowed to access matched endpoint
‚îÇ   ‚Üì
‚îú‚îÄ‚îÄ Your custom middleware
‚îÇ   ‚îú‚îÄ‚îÄ prints "before"
‚îÇ   ‚îú‚îÄ‚îÄ calls next()
‚îÇ   ‚îÇ   ‚Üì
‚îÇ   ‚îî‚îÄ‚îÄ eventually the endpoint handler is called (controller or Razor Page)
‚îÇ   ‚îî‚îÄ‚îÄ prints "after"
‚Üì Response goes out
```

‚úÖ **Final Notes**

- `UseAuthorization()` expects routing metadata to already exist.
    
- Your `Use(...)` middleware runs _before and after_ the matched endpoint executes.
    
- `MapControllerRoute()` and `MapRazorPages()` register the actual endpoints.
    
- ASP.NET Core collects all middleware and endpoint mappings, then chains them in reverse order during app startup.
## `app.UseRouting()`

`app.UseRouting()` is a **middleware** that matches incoming HTTP requests to the **route definitions** in your app.

üìå **Purpose**

- It **analyzes the request URL** and **selects the matching endpoint** (e.g., controller action, Razor Page, minimal API).
    
- It **populates the `HttpContext` with route data** (like controller, action, parameters).

‚ö†Ô∏è **Why It‚Äôs Important**

- Without it, your app:
    
    - ‚ùå Can't find which action/controller to invoke.
        
    - ‚ùå Can‚Äôt apply attribute-based policies like `[Authorize]`, `[HttpPost]`, etc.
        
    - ‚ùå Can‚Äôt match URLs to endpoint definitions.

üß© **Where It Goes**

It must come **before**:

- `app.UseAuthorization()` ‚Äì because authorization depends on matched route data.
    
- `app.UseEndpoints()` (or `MapControllerRoute()` / `MapRazorPages()`), which actually executes the matched endpoint.

‚úÖ **Correct Order Example**

```csharp
app.UseRouting();          // Matches the route
app.UseAuthentication();   // (optional) Identity
app.UseAuthorization();    // Uses route metadata for policies
app.MapControllers();      // Executes the controller action
```
## Endpoint
üîç **In ASP.NET Core:**

An **endpoint** is the final destination that handles a request ‚Äî this can be:

- A controller action method (e.g. `ProductsController.Get(int id)`)
    
- A Razor Page
    
- A minimal API handler
    
- A middleware endpoint (e.g. a `Run` delegate)

üß≠ **Example:**

```csharp
[Route("api/products")]
public class ProductsController : ControllerBase
{
    [HttpGet("{id}")]
    public IActionResult Get(int id)
    {
        return Ok($"Product {id}");
    }
}
```

When you call `/api/products/5`, the framework:

1. Matches the route using `UseRouting()`
    
2. Authorizes access using `UseAuthorization()`
    
3. Finds the **endpoint**: `Get(int id)` action method
    
4. Executes that action

In the context of MVC and Web API, **the endpoint is the matched action method that gets executed for a given route**.
## `MapControllerRoute()`
`MapControllerRoute()` sets up **conventional routing** for MVC controllers in ASP.NET Core.

‚úÖ **Purpose:**

It defines a **pattern** that matches incoming URLs to controller actions, based on naming conventions.

üß© **Syntax:**

```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```

‚öôÔ∏è **What it does:**

- Matches URLs like `/Products/Details/5`
    
- Maps them to:
    
    - `ProductsController`
        
    - `Details` method
        
    - `id = 5` (optional)

üó∫Ô∏è **Pattern Breakdown:**

- `{controller}` ‚Üí Controller name (e.g., `Products`)
    
- `{action}` ‚Üí Method name (e.g., `Details`)
    
- `{id?}` ‚Üí Optional route parameter

üõ†Ô∏è **When to use it:**

- You‚Äôre using traditional MVC with controllers and views.
    
- You want **convention-based** routing (no `[Route]` attributes needed).

üö´ **If you don‚Äôt use it:**

- URLs won't be routed to controllers unless you‚Äôre using **attribute routing** (`[Route]`, `[HttpGet]`, etc.).

üö´ **Important Notes:**

- ‚úÖ **Not a middleware** ‚Äî it's an **endpoint registration method** that configures the final routing table.
    
- ‚ùå If you skip it (and aren‚Äôt using attribute routing), the framework won‚Äôt know how to route requests to your controller actions.
    
- ‚úÖ Requires `app.UseRouting()` and `app.UseEndpoints()` (or Razor/MVC maps) to be called beforehand.

‚öôÔ∏è **Implicit Behavior:**

- ‚ùó **`app.UseEndpoints()` is implicitly called** behind the scenes when using **Minimal APIs** or `MapControllerRoute()` in ASP.NET Core 6.0+ (with top-level statements or simplified hosting).
    
- But in full hosting scenarios, you might still see it explicitly written in older templates.

**You said:**

In essence, `MapControllerRoute` registers route patterns used by the routing system to resolve incoming requests to controller actions. While it's possible to manually register each action with specific routes, the more efficient and maintainable approach is to define a dynamic pattern‚Äîsuch as `{controller}/{action}`‚Äîwhich allows the framework to dynamically match existing controllers and actions. If no match is found, a 404 is returned. This pattern-based routing saves the effort of explicitly listing every route.

**ChatGPT said:**

Yes ‚Äî you're absolutely correct, and you've described the real mechanism behind `MapControllerRoute` quite well. Let's break it down clearly:

üîß **What `MapControllerRoute` Does**

`MapControllerRoute` **registers a URL pattern** that the ASP.NET Core routing system uses to map incoming requests to **controller actions**.

Example:

```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```

- This tells ASP.NET Core:
    
    > "For any URL that looks like `/SomeController/SomeAction`, try to find a matching controller and action in the app."

‚úÖ **Dynamic Pattern Matching ‚Äî The Convenient Way**

You're spot-on here:

> We can define **a generic pattern** once, like `{controller}/{action}`, and ASP.NET Core will dynamically match existing controllers and actions.

Advantages:

- You **don‚Äôt have to list every action** manually.
    
- It scales automatically as you add new controllers and actions.
    
- Invalid routes (e.g., to nonexistent controllers/actions) automatically return **404**.

This is the **convention-based routing** system.

üß± **Alternative: Manually Mapping Each Route**

Yes, you can do this too:

```csharp
app.MapControllerRoute(
    name: "homeIndex",
    pattern: "home/index",
    defaults: new { controller = "Home", action = "Index" });

app.MapControllerRoute(
    name: "about",
    pattern: "info/about",
    defaults: new { controller = "Info", action = "About" });
```

But this is:

- Verbose
    
- Harder to maintain
    
- Prone to errors

That‚Äôs why it‚Äôs usually reserved for:

- Special-case URLs
    
- SEO-friendly custom URLs
    
- Legacy systems

üß† **Summary**

|Approach|What It Does|When To Use|
|---|---|---|
|‚úÖ Generic pattern: `{controller}/{action}/{id?}`|Automatically maps to all existing controller/action pairs|Default, scalable approach|
|‚ùå Manual route mapping|You write specific routes for each action|Only when you need custom URLs or special handling|

So your observation is exactly right:

> ‚úîÔ∏è _We can register all actions one by one, but the more convenient, scalable, and idiomatic way is to use a dynamic pattern like `{controller}/{action}`._

**Final Notes**

`MapControllerRoute` is not middleware; instead, it **registers route patterns** with the application's endpoint routing system. These patterns define how incoming URLs should be matched to controller actions. The order in which `MapControllerRoute` is called doesn't affect the request pipeline, because it simply adds endpoints to an internal collection (`EndpointDataSource`) before the routing middleware (`UseRouting`) is executed. At runtime, the routing system uses these registered patterns to resolve requests. If a URL matches a defined pattern and corresponds to an existing controller/action, it's handled accordingly; otherwise, a 404 is returned.

- These `Map*` methods run **immediately during app startup**, when the app is building its internal routing table.
    
- This happens **before any HTTP requests are processed**.
    
- So no matter if you place them before or after `app.UseRouting()`, the routes are registered in time for the routing middleware to use.

**What really matters is:**

- `app.UseRouting()` must be in the middleware pipeline before middlewares like `UseAuthorization()` that rely on routing data.
    
- `MapControllerRoute()` (and other `Map*` methods) must be called **before the app starts handling requests** (which happens naturally during startup).

In practice, you almost always see this order for clarity and convention:

```csharp
app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllerRoute(...);
```

But the key point is: **the routes get registered at startup regardless of their position relative to `UseRouting()`.**

‚úÖ **`app.Map()`

- **What it does:**  
    `app.Map()` **branches the middleware pipeline** based on the request path.  
    It allows you to define **sub-pipelines** that only run when the request path starts with a specific prefix.
    
- **Syntax example:**
    
```csharp
app.Map("/admin", adminApp =>
{
    adminApp.UseMiddleware<SomeMiddleware>();
    adminApp.Run(async ctx => await ctx.Response.WriteAsync("Admin area"));
});
```
    
- **Behavior:**
    
    - Requests to `/admin` or anything starting with `/admin/...` will be handled by this sub-pipeline.
        
    - All other requests **skip this branch entirely**.
        
- **Part of the pipeline:**  
    ‚úÖ `Map()` **is a middleware**. It actively **alters the request pipeline** structure, unlike `MapControllerRoute()`.

üîÑ **`Map()` vs `MapControllerRoute()`**

|Feature|`Map()`|`MapControllerRoute()`|
|---|---|---|
|Part of middleware pipeline|‚úÖ Yes|‚ùå No ‚Äì just registers routes at startup|
|Controls path branching|‚úÖ Yes|‚ùå No|
|Used for|Custom logic for specific path roots|Routing to controller actions (MVC)|
|Runs during request?|‚úÖ Yes ‚Äì affects request flow|‚ùå No ‚Äì registers before requests begin|

In short:

- `Map()` **controls** the flow of requests at runtime.
    
- `MapControllerRoute()` **registers** routes during app startup and is not itself a middleware.

**You said:**

So the purpose of `map()` is to define an endpoint for a request, effectively routing it to the appropriate action controller or page?

**ChatGPT said:**

‚úÖ **Yes, exactly ‚Äî you're spot on.**

The purpose of `app.MapControllerRoute(...)` and `app.MapRazorPages()` is to **create _endpoints_** ‚Äî they tell ASP.NET Core:

> ‚ÄúWhen the middleware pipeline finishes its work, here‚Äôs where to send the request based on the URL.‚Äù

Let‚Äôs unpack this more clearly:

üîß **What `MapControllerRoute()` Does**

```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```

This **registers an endpoint route** in the system that tells the framework:

> ‚ÄúIf the URL looks like `/products/list/5`, then match:
> 
> - controller = `Products`
>     
> - action = `List`
>     
> - id = `5`.‚Äù
>     

So this is the **final destination** in the pipeline ‚Äî it‚Äôs the part that says:  
‚ÄúBased on the URL, call the correct controller action.‚Äù

üß≠ **What `MapRazorPages()` Does**

This registers **Razor Page routes** (like `/Account/Login`) if you're using Identity UI or Razor Pages. So it wires up paths like `/Account/Register`, `/Identity/Account/Manage`, etc.

üöá **How Middleware + Endpoints Work Together**

1. You register middlewares with `app.Use(...)`.
    
2. You end with `Map...()` to define **what will respond** to the request.
    
3. Behind the scenes, the framework builds a giant chain like:

```csharp
[UseAuthentication]
   ‚Üí [UseAuthorization]
      ‚Üí [Your Logging Middleware]
         ‚Üí [Routing Middleware]
            ‚Üí [Controller or Razor Page] üëà endpoint
```

üß† **Think of it like a subway**

- Each `Use()` is a station that can:
    
    - Inspect the request
        
    - Reject the request
        
    - Let it continue
        
- The `Map...()` at the end is your final **destination** ‚Äî it dispatches the `HttpContext` to the **controller or page** that will handle it.

‚úÖ **In summary:**

Yes ‚Äî `MapControllerRoute()` and `MapRazorPages()` are how ASP.NET Core knows:

> ‚ÄúWhich controller/page should respond to this request based on its URL?‚Äù

And all the middleware (`UseX`) runs **before the request reaches** that controller/page ‚Äî like a filter tunnel.

Let me know if you want to build a minimal example together ‚Äî it's the best way to _see_ it.
## Map()
`app.Map()` is a middleware branching method that lets you create a **branch in the request pipeline** based on a specific condition, usually a URL path prefix.

**Purpose**

- **Branch the middleware pipeline** so that requests matching a certain path (or condition) are handled by a separate, isolated pipeline.
    
- This helps you organize your middleware and endpoint routing **by URL path segments**, allowing different middleware sets, routing, or authorization rules on different app sections.

**How does `app.Map()` work?**

- `app.Map()` takes two parameters:
    
    1. **Path prefix** (string) or **predicate** (a function that evaluates the request)
        
    2. **A branch configuration action**, which receives a new `IApplicationBuilder` representing the branch pipeline
        
- When a request comes in:
    
    - The middleware pipeline checks if the request path matches the map condition (e.g., starts with the path prefix)
        
    - If **yes**, the request is routed into the branch pipeline you configure inside the `Map()` call
        
    - If **no**, the request continues down the main pipeline, skipping the branch entirely

**Signature examples**

```csharp
// Branch based on path prefix (e.g. "/admin")
app.Map("/admin", adminApp =>
{
    // Configure middlewares and endpoints for /admin requests here
});

// Branch based on a custom condition
app.Map(context => context.Request.Method == "POST", postApp =>
{
    // This pipeline handles POST requests only
});
```

**What happens inside the branch pipeline?**

- The branch pipeline is a **new middleware pipeline**, isolated from the main one starting at the branch point.
    
- Middlewares registered in the main pipeline **before** the `Map()` call **run first**.
    
- When the request reaches the `Map()` middleware:
    
    - If the request matches the branch condition, it jumps into the branch pipeline **and runs only middlewares registered inside it**.
        
    - The branch pipeline does **not run middleware registered in the main pipeline after the `Map()` call**.
        
- This means you often need to **repeat middlewares like `UseRouting()`, `UseAuthentication()`, or `UseAuthorization()` inside the branch** if those middlewares are needed for requests in that branch.

**Can a middleware branch return to the root branch after it finishes?**

Once the request enters a branch via `app.Map("/something", ...)`, it is **isolated** to that sub-pipeline. The root (parent) pipeline is **not revisited**.

Think of it like this:

```
Root pipeline
 ‚îú‚îÄ‚îÄ Map("/admin") ‚Üí [ admin middleware1 ‚Üí middleware2 ‚Üí Run() ]
 ‚îî‚îÄ‚îÄ All other requests ‚Üí continue in root pipeline
```

When a request enters `/admin`, it **jumps entirely into the `/admin` branch**, and **never returns** to the outer pipeline.

Quick analogy:

Think of `Map()` like a **toll booth split**:

- Once you take the `/admin` path, you‚Äôre on a **separate road**.
    
- That road has **its own signs and logic** (`Use`, `Run`, `MapControllers()` etc.).
    
- You **won‚Äôt rejoin** the main highway unless you manually re-route requests (which is rare and complex).

**Important notes**

- `app.Map()` only matches requests based on **path prefixes or custom predicates**. The rest of the URL (after the prefix) is still available inside the branch.
    
- The middleware pipeline inside the branch **does not automatically inherit** middleware registered after the branch point in the main pipeline.
    
- The middleware pipeline inside the branch can have **its own routing and endpoint setup**.

- When you create a new branch pipeline with `app.Map()`, it acts as a separate, isolated pipeline that handles requests matching its condition. This branch **does not merge back** into the main pipeline‚Äîonce a request enters the branch, it only runs the middleware configured inside that branch and skips any middleware registered after the `Map()` call in the main pipeline. In other words, the branch pipeline is independent and does not continue or combine with the main pipeline‚Äôs middleware.

**Why use `app.Map()`?**

- To **separate concerns**: e.g., an admin area with different authentication or policies.
    
- To **isolate functionality** or middleware chains for a part of the app.
    
- To create **mini applications** inside your bigger app with different middleware and endpoints.

**Example**

```csharp
app.UseRouting();

app.Map("/admin", adminApp =>
{
    adminApp.UseAuthentication();
    adminApp.UseAuthorization();

    adminApp.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(
            name: "admin",
            pattern: "admin/{controller=Dashboard}/{action=Index}/{id?}");
    });
});

app.UseAuthentication();
app.UseAuthorization();

app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(
        name: "default",
        pattern: "{controller=Home}/{action=Index}/{id?}");
});
```

- Requests to `/admin/...` go to the branch pipeline with its own routing and authorization.
    
- Requests to other URLs go through the main pipeline.
### Why does the branch pipeline need to add middleware again, even if it was already added before the branching point?
**Short answer:**  
The branch pipeline **starts at the point of the `app.Map()` call**, and **does not continue executing middleware registered before it** again ‚Äî it _starts fresh_ there.

**How the middleware pipeline actually works under the hood**

Imagine the middleware pipeline like a chain of handlers that process requests one after another.

When you do this:

```csharp
app.UseMiddlewareA();    // #1
app.UseMiddlewareB();    // #2
app.Map("/branch", branchApp =>
{
    branchApp.UseMiddlewareC(); // #3
});
app.UseMiddlewareD();    // #4
```

Requests flow like this:

- For non-branch requests:
    
    - MiddlewareA (#1) ‚Üí MiddlewareB (#2) ‚Üí MiddlewareD (#4)
        
- For branch requests (e.g., `/branch/whatever`):
    
    - MiddlewareA (#1) ‚Üí MiddlewareB (#2) ‚Üí **jump to branch pipeline starting at #3** ‚Üí MiddlewareC (#3)
        

Notice that:

- MiddlewareA and MiddlewareB run _before_ the branch pipeline
    
- But the branch pipeline starts at `MiddlewareC` (#3) and **does NOT run `MiddlewareD` (#4)**

So what about middleware like routing and authentication registered before `app.Map()`?

- **Those middlewares are already run before the branch pipeline.**
    
- So your branch **does get the effect** of those middlewares (because they were executed earlier in the main pipeline).

**Then why do we have to add routing/auth _again_ in the branch?**

Because:

- **Routing middleware (`UseRouting`) builds the routing table for the current pipeline.**
    
- The routing middleware registered _before_ the branch is invoked _before_ the branch pipeline starts, but it only knows about endpoints registered in that pipeline up to that point.
    
- The **branch pipeline needs its own routing middleware and endpoint registrations to handle its own endpoints** because it's a separate sub-pipeline.
    
- Same for authorization/authentication middleware that rely on routing info and endpoint metadata ‚Äî **the branch needs to re-run them to apply policies based on the branch's routes**.

**Another way to see it:**

- **Middleware before the branch modifies the request and sets up things for the branch.**
    
- **But the branch pipeline needs to build its own routing table and apply authorization logic relevant to its own endpoints.**
    
- So even though `UseAuthentication()` was called before `app.Map()`, **the branch pipeline still needs to call it again to enforce auth on its own endpoints** because the authorization middleware uses routing information that is only available _after_ routing middleware runs inside that branch.

**To summarize:**

|Middleware type|Registered before `app.Map()`|Registered inside branch pipeline?|Reason|
|---|---|---|---|
|`UseRouting()`|Yes|Yes|Branch needs routing table for its own endpoints|
|`UseAuthentication()`|Yes|Yes|Authorization depends on routing metadata, so branch must apply it again|
|`UseAuthorization()`|Yes|Yes|Authorization policies must run with branch routes|
|Other middlewares|Yes|No or optional|Some modify request globally and run once (e.g., logging)|

**Example:**

```csharp
app.UseRouting();           // Builds main routing table (without branch endpoints)
app.UseAuthentication();    // Authenticates user for all requests before branching

app.Map("/branch", branchApp =>
{
    branchApp.UseRouting();           // Branch builds routing table for branch endpoints
    branchApp.UseAuthentication();   // Auth middleware re-applies for branch endpoints
    branchApp.UseAuthorization();    // Authorization middleware re-applies policies based on branch routes

    branchApp.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();  // Map controllers in branch
    });
});

app.UseAuthorization();     // Runs only for main pipeline endpoints
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllers();      // Map controllers in main pipeline
});
```

If you think about the routing & authorization middlewares as "building and applying policies based on routes", then **each pipeline has its own routing table and policy application**, so you must set them up _in every pipeline you create_.
### How `app.Map()` Branches and Strips the Path in ASP.NET Core

- The `app.Map("/prefix", branch => { ... })` middleware **creates a branch** in the request pipeline that is only executed when the incoming request path **starts with** the specified prefix (`/prefix`).
    
- When a request matches the prefix, the middleware **removes that prefix segment from the request path** (`HttpContext.Request.Path`) before executing the branch middleware.
    
- Inside the branch, the request path (`HttpContext.Request.Path`) is **adjusted to the remainder after the prefix**, usually starting at `/` or some sub-path, relative to the branch root.
    
- The removed prefix is normally stored in `HttpContext.Request.PathBase`, which represents the "base path" of the application or branch. However, depending on the middleware setup or nested branches, `PathBase` may sometimes remain empty.
    
- Because the branch middleware pipeline sees a modified request path (with the prefix removed), **all routing inside the branch is relative to the stripped path**, not the original full URL.
    
- This behavior allows you to isolate and handle different URL segments with different middleware pipelines or routing rules.

**Example**

Request URL:

```
/cinema/admin
```

With branch:

```csharp
app.Map("/cinema/admin", adminApp =>
{
    // Inside here, Request.Path = "/" (prefix "/cinema/admin" is stripped)
    // So routing patterns and controllers should be relative to "/"
});
```

Result inside the branch:

| Property           | Value                                        | Explanation                                           |
| ------------------ | -------------------------------------------- | ----------------------------------------------------- |
| `Request.Path`     | `/`                                          | The part of the path **after** `/cinema/admin` prefix |
| `Request.PathBase` | `/cinema/admin` (usually) or sometimes empty | The matched prefix (base path)                        |

**Why is this useful?**

- You can **compose modular request pipelines** for different URL prefixes.
    
- You isolate routing and middleware logic specific to a prefix without needing to handle the prefix manually.
    
- You write routing inside the branch **as if the prefix was the application root**.
## `app.Run()` ‚Äì The Application Start Button vs Middleware Terminator

üü¢ **1. `app.Run()` (no parameters)**

This is like the **start button** for your application.  
It **starts the web server** and begins listening for HTTP requests.

- ‚úîÔ∏è Mandatory to start the app.
    
- ‚ùóWithout it, the app will build but **won‚Äôt start** or respond to requests.
    
- Placed at the **very end** of `Program.cs` or `Startup.cs`.

```csharp
var app = builder.Build();
// ... middleware setup
app.Run(); // Starts the app
```

üü° **2. `app.Run(delegate)` ‚Äì Final Middleware (terminating)**

This version **adds a terminal middleware** to the request pipeline.

- It **handles requests** and **prevents any further middleware** from executing after it.
    
- Used to provide **custom responses** like:

```csharp
app.Run(async context =>
{
    await context.Response.WriteAsync("Hello!");
});
```

- This is **NOT the same** as the empty `app.Run()` above.

‚ö†Ô∏è **Important Differences**

|Purpose|`app.Run()` (no args)|`app.Run(delegate)`|
|---|---|---|
|Role|Starts the server|Ends the request pipeline|
|Required?|‚úÖ Yes|‚ùå Optional|
|Executes middleware?|‚ùå No|‚úÖ Yes (but terminates the pipeline)|
|Placement|Last line of `Program.cs`|Anywhere in pipeline, often last logic|

üîÅ **Summary**

- ‚úÖ `app.Run()` (no delegate) is **mandatory** ‚Äì it starts your app.
    
- üöß `app.Run(delegate)` is **a middleware** ‚Äì it ends request processing and should be used carefully to not block MVC or Razor routing.

# Bookmarks
Completion: 20.05.2025