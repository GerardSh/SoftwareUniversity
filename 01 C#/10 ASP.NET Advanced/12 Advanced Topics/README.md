# General
## `WebHost`
ASP.NET Core приложенията конфигурират и стартират хост.

Старият .NET Framework е бил тясно обвързан с Windows. Използвал е директно API-тата на операционната система. Това работи много добре, когато се поддържа само Windows, но когато възникне нужда от работа с други операционни системи, се появяват затруднения. Причината е, че приложенията комуникират директно с операционната система.
Поради това е взето решение да се създаде механизъм, който да позволява изпълнението на приложения върху различни операционни системи. Ядрото на .NET е било пренаписано така, че да бъде независимo от Windows API-тата. Създава се обща виртуална машина, която да осигурява тази независимост и възможност за работа в различни среди.
Този подход обаче усложнява комуникацията между приложенията и конкретната операционна система. Вече липсва предишната възможност за създаване на силно специализирани приложения, каквито са били например WinForms приложенията, които се изграждат бързо и лесно в рамките на Windows екосистемата.
На практика всяко ASP.NET Core приложение е конзолно приложение. Необходима е обаче абстракция, която да му придаде конкретна насоченост — тази абстракция е така нареченият хост. Хостът комуникира с операционната система и предоставя на приложението допълнителни услуги.
Хостът позволява едно и също приложение да стане специализирано в различен контекст, в зависимост от нуждите. Предоставени са различни типове хостове, един от които е т.нар. `WebHost`. Той е абстракцията, която предоставя всичко необходимо за работа с уеб технологии — HTTP заявки и отговори, сесии, пътища, query string параметри, headers, trailers и всички други аспекти, специфични за уеб приложенията.
Цялата уеб функционалност е част от Web хоста. Това позволява с промяна на хоста да се получи различен тип приложение, без да се променя бизнес логиката. Логиката обикновено се пише по един и същи начин, независимо от конкретния тип приложение.

Хостът отговаря за стартирането и управлението на жизнения цикъл на приложението. Стартира самото приложение и му предоставя определени услуги, от които то се нуждае. Една от тези услуги е управлението на жизнения цикъл (lifetime management).
Хостът трябва да може да стартира приложението, да го спре при необходимост, както и да осигури възстановяване в случай на възникнал проблем.

Минимално, хостът конфигурира сървър и pipeline за обработка на заявки.
Всеки тип хост има своя специфика. За `WebHost` това включва настройка на сървъра и request pipeline-а.
Оттам нататък се преценява какви допълнителни услуги да бъдат използвани освен задължителните. Примери за такива услуги са логване, инжектиране на зависимости, използване на конфигурации и други.
Всичко, което се конфигурира в `Program.cs`, реално настройва хоста.
Първоначално се използва host builder, в който се добавят отделни компоненти — всеки от тях представлява допълнителна услуга.
След като бъдат добавени всички необходими услуги, се извиква `builder.Build()`. Така се създава самият `WebHost`, който често се нарича web application, въпреки че реално представлява конкретен хост.
След това може да започне конфигурирането на pipeline-а, което е специфично за `WebHost`. Другите хостове притежават различни възможности и поведение.
Типът на приложението зависи от избрания хост.

Върху него вече може да почнем конфигурирането на pipeline-a. Това е специфично за web хоста, другите хостове имат други неща. От хоста зависи какъв е типа на даденото приложение.
## `WebApplication`
Преди .NET 6 първо се конфигурира `WebHost`, а след това се изгражда самото приложение.

От .NET 6 нататък тези действия се извършват едновременно в `Program.cs`.

`WebHost` по дизайн е bare minimum — нещо, което просто стартира приложението и обработва заявки, но нищо повече. Върху него започва надграждането с необходимите функционалности. Затова имаме нужда от `builder`, върху който добавяме различни услуги.
Например, `builder.Services.AddControllersWithViews()` добавя MVC поддръжка.
`builder.AddServiceDefaults()` е много добър патърн и е желателно да се спазва. Идеята е, че при няколко проекта част от настройките на `WebHost` могат да бъдат изнесени на едно централизирано място, за да не се налага да се повтарят за всяко приложение поотделно. Ако настройваме едни и същи услуги в няколко различни приложения, има риск при промяна да пропуснем някъде да я направим. Затова имаме extension метода `builder.AddServiceDefaults()`. Създаден е отделен проект `ServiceDefaults`, който съдържа един клас — `Extensions.cs`. Всичко, което пишем в `Program.cs`, може да бъде изнесено там.
Логването и мониторингът са две задължителни услуги за всяко приложение. Тяхната конфигурация е относително еднаква и затова могат да се управляват централизирано в проекта `ServiceDefaults`.

В първата част, преди да извикаме `builder.Build()`, добавяме услугите, които приложението ще ползва.
След това изграждаме pipeline-а — определяме какво трябва да се случи при заявка към приложението.

`WebApplication` представлява абстракция върху `WebHost`. Връща се от метода `Build()` на класа `WebApplicationBuilder`.

Определя начина, по който приложението комуникира със средата, в която работи.
## `CreateBuilder()`
Методът `CreateBuilder()` инициализира нова инстанция на класа `WebApplicationBuilder` и извършва няколко основни задачи:

- Конфигурира Kestrel сървъра
    
- Зарежда конфигурацията на хоста и самото приложение
    
- Настройва логването, интеграцията с IIS, content root и др.

Първоначално Kestrel не е бил проектиран като пълноценен web server, а по-скоро като _application server_, който може да стартира и обслужва уеб приложения. Това е така, защото са му липсвали редица важни механизми за сигурност, които са критично необходими за излагане на приложения в интернет.
Важно е да разбираме, че уеб пространството враждебна среда и може да се очакват атаки от различни източници. Ето защо уеб сървърът трябва да бъде добре защитен и правилно конфигуриран. Приложението ни работи върху web сървър, който в повечето случаи е Kestrel.

Макар `WebApplicationBuilder` да предоставя базова конфигурация, по подразбиране тя е минимална — например, използват се случайни портове, няма предварително зададени ограничения и политики за сигурност.

Затова е силно препоръчително да се научим как да конфигурираме Kestrel сървъра правилно. Това може да стане по няколко начина:

- Чрез подаване на аргументи при стартиране на приложението
    
- С помощта на делегат чрез метода `ConfigureKestrel`
    
- Чрез конфигурационни секции от `appsettings.json`
    
- С използване на environment променливи
    
- Или комбинация от горните подходи

Добрата конфигурация на сървъра е ключова за стабилността и сигурността на едно ASP.NET Core приложение, особено когато се разполага в production среда.

Настройва логването, интеграцията с IIS, установява кореновата директория за съдържанието и други.

Това създава стандартна конфигурация, която може да бъде променяна.
# Misc
# ChatGPT
## Nested Extension Methods

- **Extension methods are static methods** that take the instance as their first parameter, marked with `this`.
    
- When you call an extension method like `instance.Method()`, it’s just syntactic sugar for `StaticClass.Method(instance)`.
    
- Inside an extension method, calling another extension method on the same instance is simply calling another static method and passing the same instance explicitly.
    
- The `this` parameter always represents the instance you operate on, and it is passed along explicitly under the hood in every nested call.
    
- This means chaining extension methods or calling one extension method inside another is just a series of static method calls, each receiving the same object instance.
    
- You don’t need to worry about “where the instance comes from” inside extension methods — it’s always passed explicitly as a parameter.

**Example**

Original extension method using extension syntax:

```csharp
public static TBuilder AddServiceDefaults<TBuilder>(this TBuilder builder)
{
    builder.ConfigureOpenTelemetry();  // calling another extension method
    builder.AddDefaultHealthChecks();  // calling another extension method
    return builder;
}
```

What happens under the hood, rewritten explicitly as static method calls:

```csharp
public static TBuilder AddServiceDefaults<TBuilder>(this TBuilder builder)
{
    Extensions.ConfigureOpenTelemetry(builder);   // passing instance explicitly
    Extensions.AddDefaultHealthChecks(builder);   // passing instance explicitly
    return builder;
}
```

This shows clearly that the same instance (`builder`) is passed around explicitly as a parameter in each call, even though extension methods let you write it with a nicer, instance-style syntax.
# Bookmarks
Completion: 11.06.2025