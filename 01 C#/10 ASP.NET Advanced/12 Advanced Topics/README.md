# General
## `WebHost`
ASP.NET Core приложенията конфигурират и стартират хост.

Старият .NET Framework е бил тясно обвързан с Windows. Използвал е директно API-тата на операционната система. Това работи много добре, когато се поддържа само Windows, но когато възникне нужда от работа с други операционни системи, се появяват затруднения. Причината е, че приложенията комуникират директно с операционната система.
Поради това е взето решение да се създаде механизъм, който да позволява изпълнението на приложения върху различни операционни системи. Ядрото на .NET е било пренаписано така, че да бъде независимo от Windows API-тата. Създава се обща виртуална машина, която да осигурява тази независимост и възможност за работа в различни среди.
Този подход обаче усложнява комуникацията между приложенията и конкретната операционна система. Вече липсва предишната възможност за създаване на силно специализирани приложения, каквито са били например WinForms приложенията, които се изграждат бързо и лесно в рамките на Windows екосистемата.
На практика всяко ASP.NET Core приложение е конзолно приложение. Необходима е обаче абстракция, която да му придаде конкретна насоченост — тази абстракция е така нареченият хост. Хостът комуникира с операционната система и предоставя на приложението допълнителни услуги.
Хостът позволява едно и също приложение да стане специализирано в различен контекст, в зависимост от нуждите. Предоставени са различни типове хостове, един от които е т.нар. `WebHost`. Той е абстракцията, която предоставя всичко необходимо за работа с уеб технологии — HTTP заявки и отговори, сесии, пътища, query string параметри, headers, trailers и всички други аспекти, специфични за уеб приложенията.
Цялата уеб функционалност е част от Web хоста. Това позволява с промяна на хоста да се получи различен тип приложение, без да се променя бизнес логиката. Логиката обикновено се пише по един и същи начин, независимо от конкретния тип приложение.

Хостът отговаря за стартирането и управлението на жизнения цикъл на приложението. Стартира самото приложение и му предоставя определени услуги, от които то се нуждае. Една от тези услуги е управлението на жизнения цикъл (lifetime management).
Хостът трябва да може да стартира приложението, да го спре при необходимост, както и да осигури възстановяване в случай на възникнал проблем.

Минимално, хостът конфигурира сървър и pipeline за обработка на заявки.
Всеки тип хост има своя специфика. За `WebHost` това включва настройка на сървъра и request pipeline-а.
Оттам нататък се преценява какви допълнителни услуги да бъдат използвани освен задължителните. Примери за такива услуги са логване, инжектиране на зависимости, използване на конфигурации и други.
Всичко, което се конфигурира в `Program.cs`, реално настройва хоста.
Първоначално се използва host builder, в който се добавят отделни компоненти — всеки от тях представлява допълнителна услуга.
След като бъдат добавени всички необходими услуги, се извиква `builder.Build()`. Така се създава самият `WebHost`, който често се нарича web application, въпреки че реално представлява конкретен хост.
След това може да започне конфигурирането на pipeline-а, което е специфично за `WebHost`. Другите хостове притежават различни възможности и поведение.
Типът на приложението зависи от избрания хост.

Върху него вече може да почнем конфигурирането на pipeline-a. Това е специфично за web хоста, другите хостове имат други неща. От хоста зависи какъв е типа на даденото приложение.
## `WebApplication`
Преди .NET 6 първо се конфигурира `WebHost`, а след това се изгражда самото приложение.

От .NET 6 нататък тези действия се извършват едновременно в `Program.cs`.

`WebHost` по дизайн е bare minimum — нещо, което просто стартира приложението и обработва заявки, но нищо повече. Върху него започва надграждането с необходимите функционалности. Затова имаме нужда от `builder`, върху който добавяме различни услуги.
Например, `builder.Services.AddControllersWithViews()` добавя MVC поддръжка.
`builder.AddServiceDefaults()` е много добър патърн и е желателно да се спазва. Идеята е, че при няколко проекта част от настройките на `WebHost` могат да бъдат изнесени на едно централизирано място, за да не се налага да се повтарят за всяко приложение поотделно. Ако настройваме едни и същи услуги в няколко различни приложения, има риск при промяна да пропуснем някъде да я направим. Затова имаме extension метода `builder.AddServiceDefaults()`. Създаден е отделен проект `ServiceDefaults`, който съдържа един клас — `Extensions.cs`. Всичко, което пишем в `Program.cs`, може да бъде изнесено там.
Логването и мониторингът са две задължителни услуги за всяко приложение. Тяхната конфигурация е относително еднаква и затова могат да се управляват централизирано в проекта `ServiceDefaults`.

В първата част, преди да извикаме `builder.Build()`, добавяме услугите, които приложението ще ползва.
След това изграждаме pipeline-а — определяме какво трябва да се случи при заявка към приложението.

`WebApplication` представлява абстракция върху `WebHost`. Връща се от метода `Build()` на класа `WebApplicationBuilder`.

Определя начина, по който приложението комуникира със средата, в която работи.
## `CreateBuilder()`
Методът `CreateBuilder()` инициализира нова инстанция на класа `WebApplicationBuilder` и извършва няколко основни задачи:

- Конфигурира Kestrel сървъра
    
- Зарежда конфигурацията на хоста и самото приложение
    
- Настройва логването, интеграцията с IIS, content root и др.

Първоначално Kestrel не е бил проектиран като пълноценен web server, а по-скоро като _application server_, който може да стартира и обслужва уеб приложения. Това е така, защото са му липсвали редица важни механизми за сигурност, които са критично необходими за излагане на приложения в интернет.
Важно е да разбираме, че уеб пространството враждебна среда и може да се очакват атаки от различни източници. Ето защо уеб сървърът трябва да бъде добре защитен и правилно конфигуриран. Приложението ни работи върху web сървър, който в повечето случаи е Kestrel.

Макар `WebApplicationBuilder` да предоставя базова конфигурация, по подразбиране тя е минимална — например, използват се случайни портове, няма предварително зададени ограничения и политики за сигурност.

Затова е силно препоръчително да се научим как да конфигурираме Kestrel сървъра правилно. Това може да стане по няколко начина:

- Чрез подаване на аргументи при стартиране на приложението
    
- С помощта на делегат чрез метода `ConfigureKestrel`
    
- Чрез конфигурационни секции от `appsettings.json`
    
- С използване на environment променливи
    
- Или комбинация от горните подходи

Добрата конфигурация на сървъра е ключова за стабилността и сигурността на едно ASP.NET Core приложение, особено когато се разполага в production среда.

Настройва логването, интеграцията с IIS, установява кореновата директория за съдържанието и други.

Това създава стандартна конфигурация за логване, която може да бъде променяна чрез `builder.Host`. По подразбиране имаме дефинирана секция `"Logging"` в `appsettings.json` и `appsettings.Development.json`, където фреймуъркът чете настройките за конфигуриране на логването. В тази секция можем да зададем желаното ниво на логване — например, в `appsettings.Development.json` е често полезно да се сложи `Debug`, за да получаваме по-подробна информация по време на разработка.

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Host.ConfigureServices((context, services) =>
{
    services.Configure<KestrelServerOptions>(
        context.Configuration.GetSection("Kestrel"));
});

builder.Host.ConfigureLogging(logging =>
{
    logging.SetMinimumLevel(LogLevel.Warning);
});
```

По този начин настройваме логването глобално за приложението, но също така може да го презапишем с настройки от `appsettings.json`, което дава гъвкавост и лесно управление на нивата на логване според средата (development, production и т.н.).

- `WebApplication.CreateBuilder(args)` създава инстанция на `WebApplicationBuilder`, върху която след това може да се конфигурира:
    
    - Хоста: `builder.Host`
        
    - Услугите: `builder.Services`
        
    - Лога: `builder.Logging`
        
    - Конфигурации: `builder.Configuration`

- В конфигурационния файл `appsettings.json` може да има секция "Kestrel".

```json
"Kestrel": {
  "Endpoints": {
    "Http": {
      "Url": "http://localhost:5000"
    },
    "Https": {
      "Url": "https://localhost:5001"
    }
  },
  "Limits": {
    "MaxRequestBodySize": 10485760
  }
}
```

Тези настройки ще бъдат автоматично свързани към `KestrelServerOptions`, когато се ползва:

```csharp
services.Configure<KestrelServerOptions>(
    context.Configuration.GetSection("Kestrel"));
```
## Logging
**ASP.NET Core** предоставя вградена logging API, която е гъвкава и разширяема. Едно от най-важните неща в едно приложение е да имаме логове. Каквото и да се случи, за да разберем проблема, трябва да разгледаме логовете. Преди ASP.NET Core логовете обикновено са се записвали във файлове на диска или в базата данни, което е увеличавало размера на базата. От Майкрософт са решили да ни предоставят инструмент, който да е достатъчно гъвкав и да можем да управляваме логовете си според нуждите.

Фреймуъркът разполага с logging factory — фабрика, която създава логъри. Когато създадем логър, той следва определен интерфейс и позволява да записваме необходимата информация. Абстракцията е налична чрез фабрика и един общ интерфейс, което означава, че чрез смяна на провайдърите можем да променяме начина, по който логваме проблемите в приложението.

Появили се се много компании, които разработват логинг провайдъри за различни нужди. Това обаче не винаги е добре, защото при инсталиране на логинг провайдър често се добавят и много ненужни зависимости.

От Майкрософт предоставят два основни провайдъра: първият е за дебъгване — той знае как да логва в дебъг конзолата на Visual Studio. Докато разработваме, в тази конзола можем да виждаме какво се случва и да записваме нужните грешки.

Вторият провайдър логва в стандартния изход (Standard Out). Това е абстракция, която се държи различно в зависимост от средата, в която е пуснато приложението. Например:

- Ако приложението се стартира в Windows, грешките се показват в конзолата.
    
- При стартиране като Linux service, стандартният изход е насочен към системния журнал (`systemd journal`), и всички грешки се записват там.
    
- Ако приложението е в Docker контейнер, стандартният изход е насочен към Docker логовете.

Стандартният изход е универсален и всяка платформа знае къде да го насочи, така че грешките се виждат там, където е най-удобно.

Има и други варианти за логване, като например ELK stack (Elasticsearch, Logstash, Kibana), който е много подходящ за анализ на грешки и логове. Обаче ако инсталираме провайдър, който директно записва в Elasticsearch, трябва да сме наясно, че това става през HTTP заявки. HTTP е сравнително бавен и ако логваме много често, особено при дебъг, това може да забави приложението, защото всеки запис трябва да бъде изпратен по мрежата.

Ако логваме само при грешки, това не е толкова голям проблем, но при интензивно логване при дебъг, може да има сериозно влияние върху производителността.

Затова е добре да пазим стандартния изход (Standard Out) като основен канал за логване. Трудно е да се каже кое е по-бързо — дали HTTP заявките или писането на диск — тъй като това зависи от множество фактори като латентност на мрежата, натоварване на диска и други.

Обикновено системният журнал работи много добре. Ако искаме да изпращаме логовете към Elasticsearch, можем да инсталираме на машината Logstash. Той може независимо от нашето приложение да чете системния журнал, да трансформира данните, да добавя допълнителна информация и след това да ги изпраща към Elasticsearch по HTTP. По този начин нашето приложение не се забавя, защото логването и трансформацията стават в отделен процес.

Това е по-чистият и ефективен подход.

Поддържа работа с различни **logging providers** – например Console, Debug, Azure, Seq, Serilog и др.  
Logging инфраструктурата се състои от **три основни компонента**:

- **`ILoggerProvider`** – определя **къде** се извеждат лог съобщенията (конзола, файл, база и т.н.)
      ↓
- **`ILoggerFactory`** – фабрика за създаване на инстанции на `ILogger`
      ↓
- **`ILogger<T>`** – интерфейс, чрез който приложението създава лог съобщения

Приложението може да има **няколко logging провайдъра едновременно**, които работят паралелно.
### `ILogger`, `ILoggerFactory` and `ILoggerProvider`
- **`ILoggerFactory`**  
    Това е фабрика, която създава инстанции на логъри. Тя управлява и регистрира различни провайдъри за логване.
    
- **`ILogger`**  
    Интерфейсът, който използваме в нашите класове, за да пишем логове. Той "опакова" всички регистрирани логъри (логинг провайдъри) и насочва съобщенията към тях.
    
- **`ConsoleLogger`, `FileLogger` и други**  
    Това са конкретни имплементации на логъри, които изпращат логовете към определени дестинации — конзолата, файлове и т.н.
    
- **`ILoggerProvider`**  
    Провайдърите се използват за създаване на логъри, които логват към конкретна дестинация. Те се регистрират в `ILoggerFactory`.

**Как работи**

1. В `ILoggerFactory` се регистрират един или повече логинг провайдъри, например:
    
    - `AddConsole()` — добавя логване към конзолата.
        
    - `AddFile()` — добавя логване във файлове (ако е наличен такъв провайдър).
        
2. Когато инжектираме `ILogger<T>` в клас, той създава логър, който обединява всички регистрирани провайдъри и подава логовете към тях.
    
3. Чрез `CreateLogger()` фабриката създава конкретен логър, който ползваме за писане на съобщения.

**Примерно използване**

```csharp
public class MyService
{
    private readonly ILogger<MyService> _logger;

    public MyService(ILogger<MyService> logger)
    {
        _logger = logger;
    }

    public void DoWork()
    {
        _logger.LogInformation("Working...");
    }
}
```

В този пример, логърът ще изпрати логовете към всички провайдъри, регистрирани във фабриката, като например конзола, файл и други.
### Logging Configuration
Конфигурацията за логване обикновено се задава чрез настройките на приложението:

`appsettings.json`

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Warning"
    }
  },
  ...
}
```

Свойството `Logging` може да съдържа `LogLevel`.

`LogLevel` указва минималното ниво за логване.

Други свойства под Logging могат да указват доставчици на логове.

Примерни логове:

```
info: TodoApi.Controllers.TodoController[1002]
 Getting item 0

warn: TodoApi.Controllers.TodoController[4000]
 GetById(0) NOT FOUND
```
### Logging Levels
Нивата на логване не зависят от конкретна технология.

Важно е да се познават нивата и тяхното предназначение.

Когато сe избере едно ниво, се логва всичко над това ниво. Примерно  е избрано Information, ще се логват всички нива до Critical.

Нивата на логване и тяхното описание:

**Trace** – за информация, която е ценна само при отстраняване на грешки.

**Debug** – за информация, полезна по време на разработка и отстраняване на грешки.

**Information** – за проследяване на общия поток на приложението. Тук могат да се видят и SQL заявките.

**Warning** – за необичайни и неочаквани събития в потока на приложението.

**Error** – за грешки и изключения, които не могат да бъдат обработени.

**Critical** – за проблеми, изискващи незабавно внимание.
### How to Log Messages
```csharp
public class HomeController : Controller
{
    private readonly ILogger<HomeController> logger;

    public HomeController(ILogger<HomeController> logger) // Inject ILogger through the constructor
        => this.logger = logger;

    public IActionResult Index()
    {
        var message = $"Home page visited at {DateTime.Now}";
        this.logger.LogInformation(message); // Logs an informational message

        var error = "Some error";
        this.logger.LogError(error); // Logs an error message

        return View();
    }
}
```

Съобщенията се показват в конзолата.

Примерни съобщения:

```text
info: YourApp.Controllers.HomeController[0]
      Home page visited at 6/10/2025 10:42:15 AM

fail: YourApp.Controllers.HomeController[0]
      Some error
```

Разбира се къде е грешката, тъй като `ILogger<T>` е generic интерфейс, а като параметър е подаден `HomeController`.
### `OpenTelemetry` with Application Insights and .NET Aspire
Всяко приложение, дори и най-добре написаното, неминуемо се сблъсква с проблеми и бъгове. Това, което отличава добрите приложения от останалите, не е липсата на грешки, а способността ни **бързо да реагираме на възникнали проблеми** – дори **преди клиентите да ги забележат**.

За да постигнем това, е важно **да имаме пълна видимост (visibility)** върху състоянието на приложението:

- **Да можем да проследим всеки проблем,** още в момента на възникването му
    
- **Да разполагаме с логове, метрики и трасета (traces)**
    
- **Да можем бързо да разберем откъде идва проблемът** и да реагираме своевременно

**Логърът е необходим, но не е достатъчен**

Логърът (чрез `ILogger<T>`) е **основен инструмент**, който трябва да бъде **винаги достъпен и лесен за анализ**, без нужда да се рови по сървъри. Но в съвременните приложения **само логовете не са достатъчни**, особено когато:

- **Грешка не е записана в лога**, но приложението не работи коректно
    
- **Проблемът е разпределен** в няколко микросервиса
    
- **Изпълнението се забавя**, но няма видима причина

**Нужно е да проследим целия път: от заявка до отговор**

За тази цел ни е необходим **механизъм за tracing и събиране на метрики**, с който да:

- **Проследим всяка заявка по целия ѝ път през системата**
    
- **Видим колко време отнема всяка стъпка**
    
- **Сравним метрики с предходни стойности**
    
- **Открием тесни места (bottlenecks)** и ги отстраним превантивно

Например:

> Ако приложението ни е обработвало по 200 заявки в секунда, а внезапно падне до 100, без да има спад в броя на потребителите – това е ясен сигнал за проблем. Може да се окаже, че даден компонент е претоварен. Ако имаме нужната видимост, можем **да пуснем hotfix** преди потребителите да разберат.

**`OpenTelemetry` и .NET**

Microsoft предоставя **вградена поддръжка за `OpenTelemetry`** – отворен стандарт за логване, tracing и метрики. Целта е да се даде възможност за:

- Централизирано наблюдение на приложението
    
-  Интеграция с популярни инструменти като **Prometheus** и **Grafana**
    
- **Проследяване в реално време** как се държат компонентите на системата

**Проблем: повечето решения изискват сложна настройка**

Първоначално интеграцията на `OpenTelemetry` изискваше инсталиране на допълнителни инструменти и сървиси, което възпря много разработчици. Microsoft осъзнават това и започват да предоставят **по-достъпни инструменти**.

**Application Insights и .NET Aspire**

- **Application Insights** е решение на Microsoft за централизирано наблюдение, но работи основно в **Azure**.
    
- За да дадат възможност на разработчиците да наблюдават системата **локално**, Microsoft създават **.NET Aspire** – оркестратор, който:
    
    - Може да се използва **в development среда**
        
    - Позволява визуализация на логове, трасета и метрики
        
    - Осигурява **графичен интерфейс през браузъра** за бърз анализ на проблеми
        
    - В production се публикува основно в Azure, но локалното му използване спестява много време в процеса на разработка

**Как да го активираме?**

За да се възползваме от `OpenTelemetry` и .NET Aspire в нашето приложение, е нужно да добавим следната конфигурация в `Program.cs`:

```csharp
builder.ConfigureOpenTelemetry();
```

Това осигурява начална интеграция с `OpenTelemetry`, като можем да разширим конфигурацията според нуждите ни (например да добавим Prometheus exporter, графичен интерфейс и др.).

**Заключение**

В ерата на облачните и разпределени приложения **видимостта е ключова**. За да поддържаме стабилни и добре работещи системи:

- Трябва да събираме логове, трасета и метрики
    
- Трябва да можем да ги анализираме в реално време
    
- Трябва да можем да реагираме **преди потребителите** да усетят проблемите

Съчетанието от **`ILogger`, `OpenTelemetry`, .NET Aspire и подходящи визуализации** ни дава именно тази възможност.
## Cache
**An Efficient Way to Store Data**

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250610205651.png)

Кешът създава копие на част от данните и го съхранява по-близо до мястото, където тези данни ще бъдат използвани. Това позволява те да бъдат извлечени значително по-бързо, отколкото ако се взимат всеки път от оригиналния източник.

Кеширането е мощен инструмент за подобряване на производителността. Но има една уловка: инвалидацията на кеша е толкова трудна, че редом с нея поставяме и измислянето на добри имена за променливи. Ако някога чуем „това ще е лесна задача“ – трябва да проверим дали не включва кеш.

Кешът работи най-добре с данни, които **не се променят често**. Например: трябва да показваме **валутните курсове от БНБ** за няколко валути. БНБ публикува тези курсове веднъж дневно на сайта си.
Имаме сървис, който ги тегли оттам. Но въпросът е – **всеки път ли**, когато някой от нашето приложение иска да види курса, трябва да правим заявка към БНБ?
**Няма смисъл.** Това би било излишно натоварване както за нашето приложение, така и за сървъра на БНБ. Освен това това е **web call**, който е **далечен, бавен и уязвим** на проблеми.
Затова го правим по-умно: **веднъж на ден теглим курса и го пазим в кеша**. До следващия ден просто го показваме оттам. Ако искаме да събираме и история – тогава вече си ги записваме локално.
Разбира се, **не всичко става за кеширане**. Например **стоковата борса**, където данните се сменят на всяка секунда – там кешът ще покаже остаряла информация.

```sql
+-----------+
|   Client  |
+-----+-----+
      |
      v
+-----+-----+
|   Cache   |
+-----+-----+
      |
   Cache hit?
   /       \
  /         \
Yes         No
 |           |
 v           v
+-------+  +--------+
| Return|  |  Query |
| Cache |  |Database|
| Data  |  |        |
+-------+  +--------+ 
                |
                v
           +---------+
           | Store in|
           |  Cache  |
           +---------+
                |
                v
          +-----------+
          |  Return   |
          |  Data to  |
          |  Client   |
          +-----------+
```

Когато имаме заявка (request), процесът с кеширане обикновено следва тези стъпки:

1. Първият път заявката **не намира резултат в кеша**.
    
2. Извиква се **базата данни** и се взима необходимата информация.
    
3. Данните **се записват в кеша**.
    
4. Резултатът се връща към клиента.
    

При следваща заявка със същите параметри:

- **Кешът се проверява първо**.
    
- Ако има резултат – **той се връща директно**.
    
- Ако няма – **заявката отново стига до базата**, данните се взимат и **се добавят в кеша**.

Това поведение се нарича **cache-aside pattern** (или lazy caching) – кешът сам не знае кога да се обнови, ние го управляваме.
### Cache Types


# Misc
# ChatGPT
## Nested Extension Methods

- **Extension methods are static methods** that take the instance as their first parameter, marked with `this`.
    
- When you call an extension method like `instance.Method()`, it’s just syntactic sugar for `StaticClass.Method(instance)`.
    
- Inside an extension method, calling another extension method on the same instance is simply calling another static method and passing the same instance explicitly.
    
- The `this` parameter always represents the instance you operate on, and it is passed along explicitly under the hood in every nested call.
    
- This means chaining extension methods or calling one extension method inside another is just a series of static method calls, each receiving the same object instance.
    
- You don’t need to worry about “where the instance comes from” inside extension methods — it’s always passed explicitly as a parameter.

**Example**

Original extension method using extension syntax:

```csharp
public static TBuilder AddServiceDefaults<TBuilder>(this TBuilder builder)
{
    builder.ConfigureOpenTelemetry();  // calling another extension method
    builder.AddDefaultHealthChecks();  // calling another extension method
    return builder;
}
```

What happens under the hood, rewritten explicitly as static method calls:

```csharp
public static TBuilder AddServiceDefaults<TBuilder>(this TBuilder builder)
{
    Extensions.ConfigureOpenTelemetry(builder);   // passing instance explicitly
    Extensions.AddDefaultHealthChecks(builder);   // passing instance explicitly
    return builder;
}
```

This shows clearly that the same instance (`builder`) is passed around explicitly as a parameter in each call, even though extension methods let you write it with a nicer, instance-style syntax.
## .NET Configuration Precedence and Overrides
in .NET, **configuration is a composite of multiple sources**, such as:

- `appsettings.json`
    
- `appsettings.{Environment}.json`
    
- `secrets.json` (User secrets)
    
- Environment variables
    
- Command-line arguments
    
- In-memory collections
    
- Azure Key Vault, etc.

✅ If the same **section/key exists in multiple sources**, here's what happens:

**The value from the source with the highest precedence overrides the others.**

📊 **Configuration source precedence (lowest to highest):**

|Precedence|Source|
|---|---|
|1|`appsettings.json`|
|2|`appsettings.{Environment}.json`|
|3|User secrets|
|4|Environment variables|
|5|Command-line arguments|
|6|In-memory configuration|

🧪 **Example:**

Suppose you have this in `appsettings.json`:

```json
"MySettings": {
  "ApiKey": "1234"
}
```

And this in `appsettings.Development.json`:

```json
"MySettings": {
  "ApiKey": "DEV-5678"
}
```

And you set an environment variable:

```
MySettings__ApiKey=ENV-9999
```

The final value resolved for `MySettings:ApiKey` will be:

```
"ENV-9999"
```

❗**What if the same section appears twice in one source?**

If a section appears **multiple times in a single source** (like `appsettings.json`), the **last one wins**.

**Example:**

```json
"MySettings": {
  "ApiKey": "First"
},
"MySettings": {
  "ApiKey": "Second"
}
```

👉 The final value will be `"Second"` (but this is bad practice — it can lead to unpredictable behavior or even parsing errors depending on the format).

💡 **Best Practice:**

- Avoid repeating the same section/key in the same file.
    
- Use **overrides intentionally** in higher-precedence sources like environment variables or `appsettings.{Env}.json`.
    
- Use `.Bind()` or `IOptions<T>` to load and validate settings in a structured way.
# Bookmarks
Completion: 11.06.2025