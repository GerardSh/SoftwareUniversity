# General
## Recap of EF Core Basics
Entity Framework Core е лек, разширяем и много платформен.

ORM (Object Relational Mapping) framework за .NET приложения.

Предоставя високо ниво на абстракция за управление на релационни бази данни с минимален код.

Поддържа много различни бази данни.
### The Model
С Entity Framework Core достъпът до данни се осъществява чрез модел.

Моделът се състои от класове на ентитети и контекстен обект, който представлява сесия с базата данни.

Контекстният обект позволява извличане и запазване на данни.
### Model Development Approaches
Генерираме модел от съществуваща база данни.

Ръчно създаваме модел, който съответства на базата данни.

След като моделът е създаден, ползваме EF Migrations, за да създадем база данни от модела.

Migrations позволява еволюцията на базата данни при промени в модела.
### Querying
Инстанциите на ентити класовете се извличат от базата данни чрез Language Integrated Query (LINQ).

LINQ позволява да ползваме C# за писане на заявки със силно типизиране.

LINQ ползва нашия производен контекст и класовете на ентитетите, за да реферира обектите в базата данни.

EF Core предава представяне на LINQ заявката към доставчика на базата данни. Доставчиците на бази данни от своя страна я преобразуват в заявка, специфична за съответната база данни.

Заявките винаги се изпълняват спрямо базата данни, дори ако ентитетите в резултата вече съществуват в контекста.

Чрез заявките можем да четем данни от базата данни.
### Saving Data
Данните се създават, изтриват и променят в базата данни чрез екземпляри на нашите класове на ентитети.

Запазването на данни означава добавяне на нови ентитети в базата данни, премахване на ентитети или промяна на пропъртита на съществуващи ентитети по някакъв начин. Това се осъществява чрез Entity / Change Tracker.
### Saving Data Approaches
Entity Framework Core поддържа два основни подхода за запазване на данни в базата данни:

- **`Change tracking`** и **`SaveChanges

**Bulk Update:**

- **`ExecuteUpdate`** и **`ExecuteDelete`** 

EF Core имплементира патърна **Unit of Work**, който гарантира, че всички промени в данните ще бъдат извършени като една операция, дори ако засягат различни таблици и обекти. Това означава, че когато извикаме метода `SaveChanges()` или `SaveChangesAsync()`, всички промени, направени върху обектите в контекста, се запазват в базата данни като единна транзакция. Ако възникне грешка, всички промени се връщат назад, осигурявайки атомност на операцията.

Този патърн е полезен за поддържане на консистентност и интегритет на данните, когато се извършват множество промени в различни таблици или обекти.
## Repository Pattern
Ако нямаме репозитори, ние достъпваме директно DB context-а, което не е добра практика. DB context-а е конкретна имплементация на EF Core и когато знаем с каква база данни искаме да работим е добре, но когато има вероятност да се направи промяна, трябва да минем през абстракция, каквато е репозиторито - абстракция върху слоя за работа с данни. Хубавото на тази абстракция е, че тя е относително лесна за работа и може да се имплементира лесно. Реално EF ни дава възможност да сменяме data store-а, чрез смяна на провайдера, но продължава да е релационен. Ако решим да ползваме нещо, което не се поддържа от EF, тогава имаме нужда от абстракция върху EF.

Repository патърнът ни дава възможност да тестваме, без да ползваме базата данни, макар че с ентити моделите не се получава много добре и е трудно.

Класическият repository pattern ни дава по-голяма свобода при миграция към друг data store и тестване на данни. Много по-лесно се правят нещата, но е много сложен за писане и поддръжка. В него ние дори не трябва да виждаме ентити класовете. Там идеята е всяко нещо, което искаме да направим с базата, трябва да си има собствен метод. Примерно ако имаме кино програма и искаме да получим всички филми, които вървят в кино X, трябва да имаме метод, на който да кажем, че искаме всички филми, филтрирани по кино с дадено ID. Той трябва да ни върне готов view model - DTO, а не ентити. Нито входните параметри трябва да са ентити, нито изходът трябва да включва каквото и да било от ентити класовете. Каквото и да е свързано с базата данни, не трябва да напуска репозиторито. 
Има репозитори патърни, примерно Generic repository, при които това не е така и се ползват, получават и изпращат ентити класове. Това от една страна ни разрешава доста по-бързо и лесно да разработим нещата, но става много по-трудно да тестваме и да мигрираме, защото разчитаме на ентити класове, които може да не отговарят на data store-а, към който бихме искали да преминем. Примерно на не релационна база, навигационните пропъртита в ентити класовете не й говорят нищо. От тази гледна точка, ние все пак сме зависими от EF, тогава когато ентити класовете напускат репозиторито. Всичко е trade off, защото ако не искаме да излизат ентити класовете, трябва да направим страшно много модели, специализирани методи за всичко, което усложнява много кратно работата.

Реално върху репозиторито има още една абстракция, която е service layer, и ентити класовете трябва да стигат максимум до него. От там нататък може да има само view models, дори при варианта с generic repository. Класическото репозитори е средно между repository и сървис, или по-скоро репозитори-то и сървиса са в едно. Подходът с generic repo и отделно сървиси е малко по-гъвкав от гледна точка на бизнес логика, но малко по-ограничен откъм работа с базата. Когато имаме класическо репозитори, тогава е малко по-гъвкаво с работата с данните, но по-ограничен от бизнес логика.

Понеже целта често е time to market, колкото може по-бързо да сме на пазара, съответно клиента се интересува от бизнес логиката, от която той разбира и да му върши неговата работа. Поради това се гони гъвкавост в тази част и по-малко в частта с данните.

Репозитори патърна ни дава разделяне на отговорностите, което повишава maintainability, testability и scalability. Абстракциите като цяло повишават тези възможности.
### Generic Repository Pattern
Идеята на generic-ите в програмирането е да намалим повторението на кода, като същевременно поддържаме гъвкавост. В C#, който е силно типизиран език, възниква проблемът с повторенията. Ако имаме един и същи метод, който изпълнява една и съща операция, но трябва да работи с различни типове обекти, това води до нужда от многократно писане на подобен код.

Generic Repository патърнът в C# е дизайнерски патърн, който абстрахира слоя за данни на приложението, като улеснява управлението на логиката за достъп до данни от различни източници. Неговата цел е да намали повторението на код, като обединява общите операции върху данни в едно универсално репозитори, вместо да се създават отделни репозиторита за всеки тип ентитет.

**Generic Interface**

Обикновено едно generic репозитори започва с дефинирането на общ интерфейс, който описва основни операции като Add, Delete, Find и Update.  
Тези операции се дефинират по начин, който е приложим към всеки тип ентитет. Интерфейсът трябва да бъде проектиран така, че да не бъде тясно обвързан с EF Core, но същевременно да позволява имплементирането му и по други начини, ако е необходимо.

**Implementation** 

Общият интерфейс се имплементира в конкретен клас.  
Този клас се грижи за взаимодействието с източника на данни, например чрез заявка към база данни с използване на ORM (като Entity Framework).

**Entity Framework Context** 

Имплементацията обикновено използва контекст на Entity Framework за взаимодействие с базата данни.

**Why Do We Need Generic Repository DP**

В класическото или non-generic репозитори трябва да създаваме отделни репозиторита за всеки ентитет в приложението ни.  
Например, ако имаме три ентитета - Employee, Product и Customer, ще трябва да създадем три отделни репозиторита:  
- `EmployeeRepository`, `ProductRepository` и `CustomerRepository`.
### DRY - Don’t Repeat Yourself Principle
Създаването на отделни репозитори е досадна и повтаряща се работа, особено когато всички репозитори изпълняват едни и същи операции — обикновено CRUD операции с базата данни.

Това противоречи на принципа DRY (Don’t Repeat Yourself), според който трябва да избягваме дублирането на код.

За да решим този проблем, прилагаме дизайна с Generic Repository Pattern.
## Inversion of Control Design Principle
Принципът на Inversion of Control (IoC) препоръчва обръщане на контрола в обектно-ориентирания дизайн с цел постигане на по-слаба свързаност между класовете в приложението.

Основният клас не трябва да съдържа конкретна имплементация на друг клас, от който зависи. Вместо това, той трябва да разчита на абстракцията на този клас. Пример за това е класа кола, която има вътре клас двигател. Ако тази кола има конкретната имплементация на бензинов двигател, тогава ние не може да си направим дизелова кола, ако решим. Правилното решение е колата да има абстракция примерно `IEngine`, който да казва какво трябва да има двигателя, като пропъртита и методи. Този подход следва принципа на Dependency Inversion, който е част от SOLID принципите и насърчава ниска обвързаност (loose coupling).

Тук под "контрол" се разбира всяка допълнителна отговорност на класа, която надхвърля неговата основна или фундаментална роля.

Това е една от най-важните концепции, които трябва да усвоим. Принципът на Inversion of Control (IoC) е в основата не само на ASP.NET Core, но и на .NET.

Microsoft предоставя своя собствена имплементация на IoC контейнер, наречена **Service Collection**. Тя е интегрирана директно във framework-а и предлага достатъчно възможности за постигане на желаната функционалност.

Inversion of Control (IoC) е принцип в обектно-ориентираното програмиране, който цели да обърне контрола върху създаването и управлението на зависимости.

Dependency Injection (DI) е патърн, който имплементира този принцип, като предоставя начин за инжектиране на зависимости в класовете, вместо те сами да ги създават.
### Dependency Injection
**Service Collection** е конкретната имплементация на Microsoft за Dependency Injection, която следва принципа на Inversion of Control.

Когато имаме нужда от обект, обикновено използваме `new`, за да извикаме конструктора му и да го създадем. Например, ако имаме обект на кола, тя може да съдържа двигател, скоростна кутия и други части. Проблемът е, че тези части могат да бъдат различни и имат взаимни зависимости помежду си. Например, когато създадем нова кола, нейният конструктор може да очаква да му бъде подаден двигател, но двигателят от своя страна може да изисква подадена скоростна кутия.

Това ни дава контрол върху създаването на обектите, но същевременно нарушава принципа на Inversion of Control (IoC). Според IoC, когато имаме зависимости, не трябва да ги създаваме сами – контрола върху създаването на обектите не трябва да е при нас. Вместо това, трябва да посочим какви зависимости ни трябват и да ги получим наготово. Тоест, някой друг трябва да създаде необходимите обекти и да ни ги предостави.

Това обръщане на контрола (Inversion of Control) значително улеснява създаването на обектите, защото не е нужно да изреждаме всички зависимости, като използваме `new` и извикваме техните конструктори. Вместо това, зависимостите се създават автоматично и ни се предоставят от външна система.

За да работи този принцип, трябва да се спази още един важен принцип – принципът на явните зависимости (Explicit Dependency Principle). Той гласи, че когато даден клас има нужда от нещо, за да изпълни своята работа, трябва да го посочи ясно. Това означава, че класовете не трябва да създават зависимости скрито, а трябва да ги декларират в своите конструктори.

Този принцип всъщност изисква, когато даден клас има нужда от допълнителни обекти, за да свърши работата си, да ги поиска изрично чрез конструктора си. Когато го правим, не трябва да искаме конкретни имплементации, а абстракции. Параметрите на конструктора не трябва да бъдат конкретни типове, а абстрактни типове (например интерфейси). Възможно е да използваме конкретни имплементации, но това би нарушило принципа на IoC.

Когато спазваме тези два принципа – Inversion of Control и Explicit Dependency – получаваме Dependency Injection, което ни позволява да работим с обекти и техните зависимости по начин, който е по-гъвкав и лесен за поддръжка.

Огромният плюс на този подход е, че ако приложението ни създава автомобили на много места и всички те са били с дизелов двигател, ако утре решим да преминем към бензинови двигатели, трябва да променим всички тези места, където използваме дизеловия двигател. Ако обаче зависим от абстракция, трябва да променим само едно място — в контейнера за управление на зависимостите (IoC контейнер). В него просто ще посочим, че от днес исканата имплементация на двигателя вече е бензинов. Това значително подобрява поддръжката (maintainability) на приложението и води до намалена връзка (loose coupling) между зависещите класове.

DI работи на принципа, че имаме "кутия" (IoC контейнер), в която съхраняваме различни имплементации, свързани с абстракции. Например, ако абстракцията е `IEngine`, може да създадем две имплементации: `IDieselEngine`, която имплементира `IEngine`, и `IGasolineEngine`, която също имплементира `IEngine`. В IoC контейнера ще регистрираме тези имплементации и ще ги свържем с абстракцията `IEngine`.

Когато създаваме обект, който има нужда от `IEngine`, можем да посочим в конструктора какъв точно двигател искаме. Например, ако искаме дизелов двигател, ще кажем в конструктора, че искаме `IDieselEngine`. Контейнерът IoC ще открие съответната имплементация и ще я предостави на приложението.

Това е работата на IoC контейнера – той решава каква имплементация да ни предостави в зависимост от конфигурацията му. Контролът вече не е при нас, а е прехвърлен към контейнера, който автоматично осигурява съответните зависимости, като ние просто посочваме какви абстракции искаме.

Този подход значително улеснява поддръжката на кода и прави класовете по-гъвкави и по-лесни за разширяване в бъдеще.
#### Ways to Achieve DI
**Constructor** - Това е най-често използваният метод и той спазва принципа на **Explicit Dependency Principle (EDP)**. С инжектиране през конструктора, зависимостите са ясни още при създаването на обекта, което подобрява четимостта и тестването на кода.

**Property** - Зависимостите могат да се инжектират директно в пропъртита на класовете - в даден клас да имаме пропърти, което е от тип абстракция и да получава стойност от IoC контейнера. Това обаче нарушава принципа на **EDP**, защото зависимостта не е ясно изразена в конструктора и може да бъде променена по-късно. Това прави кода по-малко предсказуем и труден за поддръжка.

**Method** - Възможно е параметрите на методите да бъдат инжектирани от IoC контейнера. Въпреки това, този подход не се препоръчва, тъй като методите обикновено не трябва да зависят от външни ресурси по този начин. Възможността за инжектиране на зависимости в методи може да доведе до обърквания и трудно проследяване на зависимостите.

**Service Locator** - Много програмисти го смятат за анти-патърн и препоръчват да не се използва. При този подход имаме възможност да се обърнем към IoC контейнера отвсякъде в приложението и да поискаме необходимата зависимост. Това обаче означава, че трябва да имаме достъп до IoC контейнера, което нарушава принципа за **контрол на зависимостите**. Освен това, такъв подход прави кода труден за тестване и поддръжка. Въпреки това, без **Service Locator** някои задачи стават много сложни за решаване. Имплементацията на Microsoft за IoC принципа (Service Collection) също включва елементи на **Service Locator**, което позволява решаването на специфични проблеми.

Препоръчва се основно да се използва **constructor injection**, а когато това не е възможно, да се премине към **Service Locator**, защото той е достатъчно **експлицитен**, но трябва да се използва с внимание.
# Misc
# ChatGPT
# Bookmarks
Completion: 19.03.2025