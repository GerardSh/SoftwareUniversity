# General
## What is XML
HTML започва като обикновен текстов формат, но в даден момент се осъзнава, че само текст не е достатъчен. Появява се необходимост от по-добра визуализация на документите, което води до добавянето на мета данни. Тези мета данни се включват в текста така, че да не пречат на четимостта, но да добавят допълнителен контекст. Благодарение на тази информация става възможно текстът да се форматира по различни начини – с подчертаване, удебеляване, по-голям размер на буквите и други визуални подобрения.

Този подход постепенно се развива в HTML, а към него се добавя и концепцията за хипервръзки – връзки между отделните документи. Целта е не само да обменяме документи, но и да ги свързваме помежду им. Наричат ги „hyper” връзки, защото излизат извън рамките на самия документ. HTML се оказва много подходящ за визуализиране на документи, но с времето се установява, че визуализацията сама по себе си не е достатъчна. Появява се нужда да предаваме и нестандартна мета информация – специфична за различните потребители.

Понеже не всичко може да бъде включено в HTML документа, решено е да се създаде универсален стандарт, който да позволява на всеки да предава каквато мета информация пожелае. При обмен на такава информация обаче е важно двете страни да знаят как да я интерпретират и какво означава тя.
Тук XML показва своето предимство пред JSON. XML позволява не само да опишем данните, но и да ги документираме по начин, който автоматично дава яснота за съдържанието им. Поради лесната и бърза комуникация в съвременния свят, JSON е предпочитан, тъй като можем директно да попитаме другата страна какво означава дадено поле. Въпреки това, по времето когато XML е създаден, комуникацията не е била толкова достъпна, затова неговата документация е била изключително ценна. Разработчиците на XML са подходили методично и с научна прецизност към създаването му, като са се стремели всичко да бъде структурирано, подредено и добре документирано. Именно тази концепция за яснота и подреденост е в основата на XML.

XML е универсален стандарт за описване на структурирана информация чрез текст и тагове. Нарича се „extensible“, защото можем да добавяме собствени тагове, но е необходимо да опишем какво представляват те. Тук влизат в действие схемите – те подробно описват всеки един елемент в XML: неговия тип, позволените стойности, дали е задължителен или не, валидации и други. Това описание е в текстов формат и е машинно четимо. 
Схемите дават огромно предимство, тъй като разработчиците могат да генерират автоматично код на база на схемата. По този начин се създават класове и методи, които могат да валидират, десериализират и структурират XML документа в точния формат, в който трябва да бъде.

JSON също позволява да представим всякакъв вид информация, но там липсва този строг контрол и документация. При JSON често се налага да гадаем какво означават определени полета или да разчитаме на допълнителни инструкции от създателя на документа. Макар че съществуват проекти за JSON Schema, който да осигури подобна структура и валидация като при XML, той все още не е приет като официален стандарт.

XML остава предпочитан за много enterprise приложения именно заради детайлната документация и възможността за автоматично генериране на код и модели на база на нея.

Разглеждаме XML и JSON като стандартизирани формати за прехвърляне на данни, които могат лесно да се използват в различни платформи. Всички водещи бази данни имат възможност да записват данни в тези формати. И двата формата могат да се използват дори като бази данни. Има много случаи, в които приложенията трябва да запазят малко количество данни, като например настройки, които могат да бъдат записани в XML или JSON. Ако трябва да запишем малко количество данни, можем спокойно да използваме тези формати. Единственият проблем е, че ако искаме да достъпим тези данни, трябва да ги заредим в паметта и да работим с тях оттам. Можем да имаме толкова данни, колкото паметта позволява да заредим. Има вариант да работим с тях без да ги зареждаме в паметта, ако работим просто като текст, но това е ограничено и пак трябва да ги зареждаме частично.

Основната разлика между XML и JSON е, че XML предлага по-структурирани възможности за включване на мета данни в същата структура, докато в JSON мета данните се добавят като допълнителни свойства или обекти. Това е полезно, например, ако имаме снимка и след време се чудим кога и къде е била направена. Информацията за локацията и датата може да се запази като мета данни към снимката. Реално, мета информацията не влияе пряко на основните данни, тя просто предоставя допълнителен контекст. И без тези мета данни снимката си остава снимка, но е добре да имаме повече информация към нея. JSON ни позволява да запазим тези мета данни като допълнителни свойства. Например, може да създадем обект "снимка", който да има свойства за съдържание, дата, локация и т.н. Този подход обаче прави данните равностойни, когато разглеждаме обекта, изглежда, че съдържанието и датата са еднакво полезни. За да избегнем това, можем да структурираме обекта по различен начин – например, да имаме обект "снимка", който има съдържание и след това пропърти "мета данни", което всъщност е отделен обект с допълнителната информация. Така семантично подражаваме на реалната структура, в която мета данните са допълнителна информация, но не са равни на основните данни.
### Example
![](Pasted%20image%2020250313174252.png)

Всички елементи в XML имат отварящ и затварящ таг с наклонена черта, като между тях се намира стойността им. Те могат да се вграждат един в друг, като всички са част от основния елемент. Таговете могат да съдържат атрибути, които са представени като key-value двойки и носят мета информация. Дори самото име на тага е допълнителна информация, която не е налична при JSON.

Първият ред в XML е декларация, която указва, че документът е XML, както и версията на XML, в случай че някой случайно е сменил разширението. Това обаче не е абсолютно необходимо и добавя допълнителен текст, който увеличава размера на файла.

Основната разлика с JSON е, че XML е много по-описателен. Винаги има root елемент, който определя какъв е документът, докато JSON започва директно с отваряща скоба и пропъртитата на обекта. 

Следващият елемент в XML примера е "книга", което също е разлика с JSON, тъй като в JSON бихме имали просто масив от обекти с изброени пропъртитата, без да знаем какви точно са тези обекти и за да разберем какви са, трябва да се ориентираме по пропъртитата им. Ако искахме да опишем JSON много детайлно, щеше да стане сложно и не бихме могли да го направим толкова прецизно. JSON носи по-малко информация, но заради това е предпочитан, тъй като е по-лек и по-бързо преминава през нестабилни мрежи.
### Syntax
XML има няколко основни компонента:

Header - Дефинира версията и енкодинга на файла. Днес почти всички използваме UTF-8, който е и стандартът за JSON. В миналото са се ползвали различни кодови таблици, което е затруднявало разчитането на данните. UTF-8 е универсална кодова таблица, а нейното разширение е UTF-16. Причината за съществуването на UTF-16 е необходимостта от представяне на символи, които изискват повече от 1 байт за кодиране. Докато UTF-8 може да кодира символи с променлива дължина (от 1 до 4 байта), UTF-16 работи с фиксирани 2 или 4 байта, което го прави по-ефективен за текстове, съдържащи много символи от по-разширени азбуки, като китайски, японски или корейски.

Elements - Дефинират структурата на XML документа.

Attributes - Служат за съхранение на мета информация.

Values - Това са реалните данни, записани между отварящия и затварящия таг на елемента.

Root element - Задължително трябва да има само един такъв елемент, който представлява основния контейнер в XML документа. При JSON еквивалентът на root елемента са началната и крайната фигурна скоба `{}`.

Елементите изграждат структурата, атрибутите съхраняват мета информацията, а стойностите съдържат реалните данни.

Пример:

```xml
<title lang="en">Professional C# and .NET</title>
```

В този случай:
- Елементът е `title`.
- Атрибутът е `lang`.
- Стойността е текстът между отварящия и затварящия таг — "Professional C# and .NET".

**Structure:**

![](Pasted%20image%2020250313195653.png)
## XML and HTML
**Similarities:**

XML произлиза от markup езиците. Всъщност HTML е разновидност на XML, която позволява само стандартни стойности. XML обаче не е HTML, защото в него можем да дефинираме произволни тагове и стойности.

И двата формата са базирани на текст и използват тагове и атрибути.

**Differences:**

HTML е предназначен за описване на документи и тяхната структура, докато XML е синтаксис за представяне на данни от всякакъв вид. XML се счита за мета език, защото може да описва самия себе си или други езици. Всеки език, който може да се опише със себе си, се нарича мета език.

HTML се фокусира върху структурата и визуалното оформление на информацията.

XML изисква документът да бъде строго форматиран. Макар и HTML да има строги изисквания към форматирането, браузърите често успяват да компенсират допуснатите грешки и да визуализират страницата правилно въпреки тях.
### XML Advantages
XML е human readable за разлика от бинарните формати.

Може да съхранява всякакъв вид структурирани данни. Ако структурата е динамична, губим предимството на XSD (XML Schema Definition), което представлява строгата схема на данните и не бива да се променя.

XML данните съдържат самоописваща се мета информация. Освен самите данни, получаваме и допълнителна информация за тяхното предназначение и обработка.

XML поддържа пълно Unicode кодиране, което позволява представяне на текст на всякакви езици.

Можем да създаваме персонализирани XML-базирани езици за специфични приложения, като дефинираме собствени тагове.

Съществуват XML парсери за всички популярни езици за програмиране и платформи.

Едно от най-големите предимства на XML, освен XSD схемите, е неговата стандартизация, която е далеч по-устойчива в сравнение с JSON.
### XML Disadvantages
Данните в XML са по-големи и заемат повече място в сравнение с бинарни формати или JSON. Това означава по-голямо изразходване на памет, мрежови трафик, повече пространство на твърдия диск и по-висока консумация на ресурси като цяло.

Обработката на XML изисква повече изчислителни ресурси. Това включва повече време за парсване и конструиране на XML таговете, което може да доведе до забавяне на производителността, особено при големи обеми от данни.

XML не е оптимален формат за всички видове данни, особено за бинарни данни като графики, снимки, видео и т.н. Макар че XML може да съдържа такива данни, има други специализирани формати, които са много по-подходящи за тях. Няма универсален storage или база данни, които да са подходящи за всички типове данни. Поради това има различни модели на съхранение, като например polyglot persistence, който използва различни бази данни за различните типове данни. Например, ако трябва да съхраняваме отношения между приятели в социална мрежа, тогава базата данни, която използваме, трябва да бъде графова.
## XML vs JSON
| **Характеристика**    | **XML**                          | **JSON**                       |
| --------------------- | -------------------------------- | ------------------------------ |
| **Типове данни**      | Данните са без тип               | Обектите имат тип              |
| **Поддържани типове** | Всички данни трябва да са стринг | string, number, array, Boolean |
| **Достъп до данни**   | Данните трябва да се парсват     | Данните трябва да се парсват   |
| **Коментари**         | Поддържа коментари               | Не поддържа                    |
| **Енкодиране**        | Поддържа различни енкодирания    | Поддържа само UTF-8            |
Макар че данните в XML се съхраняват като стринг, може да посочим техния тип, използвайки атрибутите. Благодарение на тях, може да кажем, че даден елемент е от тип "кола". С други думи, в самите данни не се забелязва разлика, но чрез мета информацията (атрибути), можем да посочим техния тип.
## Parsing XML
### LINQ-to-XML
LINQ се използва за достъп до XML.

Позволява лесно четене, търсене, писане и модифициране на XML документи. Обикновено е по-удобно да се десериализират XML или JSON данни в POCO (Plain Old CLR Objects), да се обработят и след това да се сериализират отново. При XML обаче, това не винаги е възможно, когато са необходими специфични криптографски операции.

**LINQ-to-XML classes:

- `XDocument` - представлява LINQ-активиран XML документ, който съдържа препратка към заглавния ред и основния елемент.
- `XElement` - основният компонент, който съдържа информацията в XML.
- `XAttribute` - използва се за работа с атрибутите.

`XDocument` и `XElement` класовете, въпреки че ни позволяват достъп до определени части на XML документа, запазват оригиналната XML структура така, както е, включително всеки един символ. При десериализация на XML данни се запазват данните, но се губи оригиналният обект – точната криптографска репрезентация. Тези класове се използват, когато е необходимо да се запази оригиналният XML, но ако не е нужно запазването на структурата, а работим с DTO, по-добре е да ги десериализираме, обработим и сериализираме отново.
### Reading XML
Може да зареждаме XML по различни начини — от файл, от HTTP заявка или от стринг. Когато XML е стринг, кавичките се escape-ват автоматично.

**To process an XML String:**

```csharp
string str = @"<?xml version=""1.0""?>
<!-- comment at the root level -->
<Root>
	<Child>Content</Child>
</Root>";
XDocument doc = XDocument.Parse(str);
```

**Loading XML directly from file:**

```csharp
XDocument xmlDoc = XDocument.Load("../../books.xml");
```

Можете също така да заредите XML чрез HTTP заявка, като използваме `HttpClient`, ако данните идват от външен източник:

**Loading XML from an HTTP request:**
### Working with `XDocument`
```csharp
var cars = xmlDoc.Root.Elements();
foreach (var car in cars)
{
 string make = car.Element("make").Value;
 string model = car.Element("model").Value;
 Console.WriteLine($"{make} {model}");
}
```

# Misc
# ChatGPT
# Bookmarks
Completion: 14.03.2025