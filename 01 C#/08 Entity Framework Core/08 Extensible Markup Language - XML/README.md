# General
## What is XML
HTML започва като обикновен текстов формат, но в даден момент се осъзнава, че само текст не е достатъчен. Появява се необходимост от по-добра визуализация на документите, което води до добавянето на мета данни. Тези мета данни се включват в текста така, че да не пречат на четимостта, но да добавят допълнителен контекст. Благодарение на тази информация става възможно текстът да се форматира по различни начини – с подчертаване, удебеляване, по-голям размер на буквите и други визуални подобрения.

Този подход постепенно се развива в HTML, а към него се добавя и концепцията за хипервръзки – връзки между отделните документи. Целта е не само да обменяме документи, но и да ги свързваме помежду им. Наричат ги „hyper” връзки, защото излизат извън рамките на самия документ. HTML се оказва много подходящ за визуализиране на документи, но с времето се установява, че визуализацията сама по себе си не е достатъчна. Появява се нужда да предаваме и нестандартна мета информация – специфична за различните потребители.

Понеже не всичко може да бъде включено в HTML документа, решено е да се създаде универсален стандарт, който да позволява на всеки да предава каквато мета информация пожелае. При обмен на такава информация обаче е важно двете страни да знаят как да я интерпретират и какво означава тя.
Тук XML показва своето предимство пред JSON. XML позволява не само да опишем данните, но и да ги документираме по начин, който автоматично дава яснота за съдържанието им. Поради лесната и бърза комуникация в съвременния свят, JSON е предпочитан, тъй като можем директно да попитаме другата страна какво означава дадено поле. Въпреки това, по времето когато XML е създаден, комуникацията не е била толкова достъпна, затова неговата документация е била изключително ценна. Разработчиците на XML са подходили методично и с научна прецизност към създаването му, като са се стремели всичко да бъде структурирано, подредено и добре документирано. Именно тази концепция за яснота и подреденост е в основата на XML.

XML е универсален стандарт за описване на структурирана информация чрез текст и тагове. Нарича се „extensible“, защото можем да добавяме собствени тагове, но е необходимо да опишем какво представляват те. Тук влизат в действие схемите – те подробно описват всеки един елемент в XML: неговия тип, позволените стойности, дали е задължителен или не, валидации и други. Това описание е в текстов формат и е машинно четимо. 
Схемите дават огромно предимство, тъй като разработчиците могат да генерират автоматично код на база на схемата. По този начин се създават класове и методи, които могат да валидират, десериализират и структурират XML документа в точния формат, в който трябва да бъде.

JSON също позволява да представим всякакъв вид информация, но там липсва този строг контрол и документация. При JSON често се налага да гадаем какво означават определени полета или да разчитаме на допълнителни инструкции от създателя на документа. Макар че съществуват проекти за JSON Schema, който да осигури подобна структура и валидация като при XML, той все още не е приет като официален стандарт.

XML остава предпочитан за много enterprise приложения именно заради детайлната документация и възможността за автоматично генериране на код и модели на база на нея.

Разглеждаме XML и JSON като стандартизирани формати за прехвърляне на данни, които могат лесно да се използват в различни платформи. Всички водещи бази данни имат възможност да записват данни в тези формати. И двата формата могат да се използват дори като бази данни. Има много случаи, в които приложенията трябва да запазят малко количество данни, като например настройки, които могат да бъдат записани в XML или JSON. Ако трябва да запишем малко количество данни, можем спокойно да използваме тези формати. Единственият проблем е, че ако искаме да достъпим тези данни, трябва да ги заредим в паметта и да работим с тях оттам. Можем да имаме толкова данни, колкото паметта позволява да заредим. Има вариант да работим с тях без да ги зареждаме в паметта, ако работим просто като текст, но това е ограничено и пак трябва да ги зареждаме частично.

Основната разлика между XML и JSON е, че XML предлага по-структурирани възможности за включване на мета данни в същата структура, докато в JSON мета данните се добавят като допълнителни свойства или обекти. Това е полезно, например, ако имаме снимка и след време се чудим кога и къде е била направена. Информацията за локацията и датата може да се запази като мета данни към снимката. Реално, мета информацията не влияе пряко на основните данни, тя просто предоставя допълнителен контекст. И без тези мета данни снимката си остава снимка, но е добре да имаме повече информация към нея. JSON ни позволява да запазим тези мета данни като допълнителни свойства. Например, може да създадем обект "снимка", който да има свойства за съдържание, дата, локация и т.н. Този подход обаче прави данните равностойни, когато разглеждаме обекта, изглежда, че съдържанието и датата са еднакво полезни. За да избегнем това, можем да структурираме обекта по различен начин – например, да имаме обект "снимка", който има съдържание и след това пропърти "мета данни", което всъщност е отделен обект с допълнителната информация. Така семантично подражаваме на реалната структура, в която мета данните са допълнителна информация, но не са равни на основните данни.
### Example
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250313174252.png)

Всички елементи в XML имат отварящ и затварящ таг с наклонена черта, като между тях се намира стойността им. Те могат да се вграждат един в друг, като всички са част от основния елемент. Таговете могат да съдържат атрибути, които са представени като key-value двойки и носят мета информация. Дори самото име на тага е допълнителна информация, която не е налична при JSON.

Първият ред в XML е декларация, която указва, че документът е XML, както и версията на XML, в случай че някой случайно е сменил разширението. Това обаче не е абсолютно необходимо и добавя допълнителен текст, който увеличава размера на файла.

Основната разлика с JSON е, че XML е много по-описателен. Винаги има root елемент, който определя какъв е документът, докато JSON започва директно с отваряща скоба и пропъртитата на обекта. 

Следващият елемент в XML примера е "книга", което също е разлика с JSON, тъй като в JSON бихме имали просто масив от обекти с изброени пропъртитата, без да знаем какви точно са тези обекти и за да разберем какви са, трябва да се ориентираме по пропъртитата им. Ако искахме да опишем JSON много детайлно, щеше да стане сложно и не бихме могли да го направим толкова прецизно. JSON носи по-малко информация, но заради това е предпочитан, тъй като е по-лек и по-бързо преминава през нестабилни мрежи.
### Syntax
XML има няколко основни компонента:

Header - Дефинира версията и енкодинга на файла. Днес почти всички използваме UTF-8, който е и стандартът за JSON. В миналото са се ползвали различни кодови таблици, което е затруднявало разчитането на данните. UTF-8 е универсална кодова таблица, а нейното разширение е UTF-16. Причината за съществуването на UTF-16 е необходимостта от представяне на символи, които изискват повече от 1 байт за кодиране. Докато UTF-8 може да кодира символи с променлива дължина (от 1 до 4 байта), UTF-16 работи с фиксирани 2 или 4 байта, което го прави по-ефективен за текстове, съдържащи много символи от по-разширени азбуки, като китайски, японски или корейски.

Elements - Дефинират структурата на XML документа.

Attributes - Служат за съхранение на мета информация.

Values - Това са реалните данни, записани между отварящия и затварящия таг на елемента.

Root element - Задължително трябва да има само един такъв елемент, който представлява основния контейнер в XML документа. При JSON еквивалентът на root елемента са началната и крайната фигурна скоба `{}`.

Елементите изграждат структурата, атрибутите съхраняват мета информацията, а стойностите съдържат реалните данни.

Пример:

```xml
<title lang="en">Professional C# and .NET</title>
```

В този случай:
- Елементът е `title`.
- Атрибутът е `lang`.
- Стойността е текстът между отварящия и затварящия таг — "Professional C# and .NET".

**Structure:**

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250313195653.png)
## XML and HTML
**Similarities:**

XML произлиза от markup езиците. Всъщност HTML е разновидност на XML, която позволява само стандартни стойности. XML обаче не е HTML, защото в него можем да дефинираме произволни тагове и стойности.

И двата формата са базирани на текст и използват тагове и атрибути.

**Differences:**

HTML е предназначен за описване на документи и тяхната структура, докато XML е синтаксис за представяне на данни от всякакъв вид. XML се счита за мета език, защото може да описва самия себе си или други езици. Всеки език, който може да се опише със себе си, се нарича мета език.

HTML се фокусира върху структурата и визуалното оформление на информацията.

XML изисква документът да бъде строго форматиран. Макар и HTML да има строги изисквания към форматирането, браузърите често успяват да компенсират допуснатите грешки и да визуализират страницата правилно въпреки тях.
### XML Advantages
XML е human readable за разлика от бинарните формати.

Може да съхранява всякакъв вид структурирани данни. Ако структурата е динамична, губим предимството на XSD (XML Schema Definition), което представлява строгата схема на данните и не бива да се променя.

XML данните съдържат самоописваща се мета информация. Освен самите данни, получаваме и допълнителна информация за тяхното предназначение и обработка.

XML поддържа пълно Unicode кодиране, което позволява представяне на текст на всякакви езици.

Можем да създаваме персонализирани XML-базирани езици за специфични приложения, като дефинираме собствени тагове.

Съществуват XML парсери за всички популярни езици за програмиране и платформи.

Едно от най-големите предимства на XML, освен XSD схемите, е неговата стандартизация, която е далеч по-устойчива в сравнение с JSON.
### XML Disadvantages
Данните в XML са по-големи и заемат повече място в сравнение с бинарни формати или JSON. Това означава по-голямо изразходване на памет, мрежови трафик, повече пространство на твърдия диск и по-висока консумация на ресурси като цяло.

Обработката на XML изисква повече изчислителни ресурси. Това включва повече време за парсване и конструиране на XML таговете, което може да доведе до забавяне на производителността, особено при големи обеми от данни.

XML не е оптимален формат за всички видове данни, особено за бинарни данни като графики, снимки, видео и т.н. Макар че XML може да съдържа такива данни, има други специализирани формати, които са много по-подходящи за тях. Няма универсален storage или база данни, които да са подходящи за всички типове данни. Поради това има различни модели на съхранение, като например polyglot persistence, който използва различни бази данни за различните типове данни. Например, ако трябва да съхраняваме отношения между приятели в социална мрежа, тогава базата данни, която използваме, трябва да бъде графова.
## XML vs JSON
| **Характеристика**    | **XML**                          | **JSON**                       |
| --------------------- | -------------------------------- | ------------------------------ |
| **Типове данни**      | Данните са без тип               | Обектите имат тип              |
| **Поддържани типове** | Всички данни трябва да са стринг | string, number, array, Boolean |
| **Достъп до данни**   | Данните трябва да се парсват     | Данните трябва да се парсват   |
| **Коментари**         | Поддържа коментари               | Не поддържа                    |
| **Енкодиране**        | Поддържа различни енкодирания    | Поддържа само UTF-8            |
Макар че данните в XML се съхраняват като стринг, може да посочим техния тип, използвайки атрибутите. Благодарение на тях, може да кажем, че даден елемент е от тип "кола". С други думи, в самите данни не се забелязва разлика, но чрез мета информацията (атрибути), можем да посочим техния тип.

При работа с JSON не е задължително да използваме DTO класове, тъй като можем да сериализираме и десериализираме директно обекти, включително анонимни типове. Въпреки това, при XML винаги е необходимо да дефинираме DTO класове, които използват атрибути като `XmlRoot` и `XmlElement`, за да опишат структурата на данните. Това прави XML по-строг и изисква повече конфигурация в сравнение с JSON, което е по-гъвкаво и не изисква толкова стриктно моделиране на данните.
### Gatewaying
XML се ползва по-рядко в уеб среда, но намира широко приложение в Desktop и Server приложения.

Понякога възниква нуждата от нодове в мрежата, които да могат да превеждат данни от един формат в друг. Желателно е да имаме един нод, който да може да получава данни в JSON формат и да ги изпраща в XML, както и обратното – да получава данни в XML и да ги изпраща в JSON. Понякога е необходимо да поддържаме и двата формата. Функцията, при която четем сериализирани данни в един формат и ги преобразуваме без промени в друг формат, се нарича Gatewaying, а модулите, които осигуряват тази функционалност, се наричат Gateway. В Gateway модулите има routing paths, които указват откъде идват данните, накъде отиват и как да се извършва преобразуването.

Все още има специфични приложения или legacy приложения, които използват XML, и затова често се налага, дори новите приложения, които разработваме, да могат да gateway-ват информацията към по-стари, които работят с XML. Това позволява да пишем приложенията си изцяло с JSON формат и когато се наложи, да изпращат информация към по-стар модул, преминавайки през Gateway.
### Complex Data Types
При изпращане на комплексни данни (например масиви), трябва да инструктираме XML сериализатора, че тези данни не са обикновени XML елементи, а комплексни типове. Това е необходимо, за да бъдат сериализирани правилно:

- Масивите трябва да се третират като колекции.
- Обектите трябва да се третират като колекции от пропъртита.

При JSON такова инструктиране не е необходимо, дори когато работим с комплексни типове данни.
### Data Size
XML предлага възможността да добавяме мета данни чрез:

- Атрибути – компактни и подходящи за малки мета данни.
- Елементи – по-подходящи за по-големи или по-сложни мета данни.

Атрибутите в XML са по-компактни от елементите, но добавянето на много атрибути също може да увеличи размера на XML файла.

При JSON всички мета данни се представят като пропъртита на обекта, което може да доведе до по-голям обем от данни при сложни структури.

**Заключение:**  

При малко количество мета данни JSON често е по-компактен, тъй като не включва отварящи и затварящи тагове за всеки елемент.

При голямо количество мета данни XML може да е по-ефективен, ако ползваме атрибути вместо отделни елементи.
## Parsing XML
### LINQ-to-XML
LINQ се използва за достъп до XML.

Позволява лесно четене, търсене, писане и модифициране на XML документи. Обикновено е по-удобно да се десериализират XML или JSON данните в POCO (Plain Old CLR Objects), да се обработят и след това да се сериализират отново. При XML обаче, това не винаги е възможно, когато са необходими специфични криптографски операции.

**LINQ-to-XML classes:

- `XDocument` - представлява LINQ-активиран XML документ, който съдържа препратка към заглавния ред и основния елемент.
- `XElement` - основният компонент, който съдържа информацията в XML.
- `XAttribute` - използва се за работа с атрибутите.

`XDocument` и `XElement` класовете, въпреки че ни позволяват достъп до определени части на XML документа, запазват оригиналната XML структура така, както е, включително всеки един символ. При десериализация на XML данни се запазват данните, но се губи оригиналният обект – точната криптографска репрезентация. Тези класове се използват, когато е необходимо да се запази оригиналният XML, но ако не е нужно запазването на структурата, а работим с DTO, по-добре е да ги десериализираме, обработим и сериализираме отново.
### Reading XML
Може да зареждаме XML по различни начини — от файл, от HTTP заявка или от стринг. Когато XML е стринг, кавичките се escape-ват автоматично.

**To process an XML String:**

```csharp
string str = @"<?xml version=""1.0""?>
<!-- comment at the root level -->
<Root>
	<Child>Content</Child>
</Root>";
XDocument doc = XDocument.Parse(str);
```

**Loading XML directly from file:**

```csharp
XDocument xmlDoc = XDocument.Load("../../books.xml");
```

**Loading XML from an HTTP request:**

Можем също така да заредим XML чрез HTTP заявка, като използваме `HttpClient`, ако данните идват от външен източник.

```csharp
using System.Net.Http;
using System.Threading.Tasks;
using System.Xml.Linq;

public async Task LoadXmlFromHttpRequest()
{
    using (HttpClient client = new HttpClient())
    {
        // Изпращаме GET заявка към URL, който връща XML
        string url = "https://example.com/data.xml";
        string xmlString = await client.GetStringAsync(url);

        // Зареждаме XML от стринг
        XDocument xmlDoc = XDocument.Parse(xmlString);

        // Пример: Извличане на елементите от XML документа
        var rootElement = xmlDoc.Element("Root");
        var childElement = rootElement?.Element("Child");

        if (childElement != null)
        {
            Console.WriteLine($"Child content: {childElement.Value}");
        }
    }
}
```
### Working with `XDocument`
Всеки XML има коренен елемент, който може да достъпим и от който можем да извлечем всички негови деца с помощта на `Elements`. Това ще ни даде колекция от елементи, с която можем да работим по-нататък, например с LINQ. След като вземем елементите, можем да ги обходим в `foreach` цикъл и да извлечем стойностите на под-елементите чрез техните имена.

Пример с достъпване на елементи `make` и `model`:

```csharp
XDocument xmlDoc = XDocument.Load("../../books.xml");

var cars = xmlDoc.Root.Elements(); // access root element and get collection of children
foreach (var car in cars)
{
// Access elements by name and get their values
	 string make = car.Element("make").Value;
	 string model = car.Element("model").Value;
	 Console.WriteLine($"{make} {model}");
}
```

Можем също да използваме вътрешен `foreach`, за да достъпим и вложените елементи:

```csharp
var cars = xmlDoc.Root.Elements(); // Access the root element and get all child elements

foreach (var car in cars)
{ 
    // Inner foreach to access the nested elements of car
    foreach (var element in car.Elements())
    {
        Console.WriteLine($"{element.Name}: {element.Value}");
    }
}
```

Това ще ни даде всички вложени елементи на всеки автомобил (`car`), като например `make`, `model` и други, и техните стойности.

Списък с методи за работа с `XDocument` има във файла за EF Core в папката с ресурси.
### LINQ-to-XML
Търсенето в XML с LINQ е подобно на търсенето в колекции с LINQ:

```csharp
XDocument xmlDoc = XDocument.Load("cars.xml");

var cars = xmlDoc.Root.Elements()
 .Where(e => e.Element("make").Value == "Opel" &&
             long.Parse(e.Element("travelled-distance").Value) >= 30000)
 .Select(c => new
 {
     Model = c.Element("model").Value,
     Traveled = c.Element("travelled-distance").Value
 })
 .ToList();
 
foreach (var car in cars)
 Console.WriteLine(car.Model + " " + car.Traveled);
```

Тук използваме LINQ за извличане на елементи от XML документа. Първо филтрираме елементите според условията (например, марка и минимално изминато разстояние), след което селектираме съответните стойности и ги извеждаме в конзолата.
### Creating XML with `XElement`
Можем да създаваме `XDocuments` по следния начин:

```xml
<books>
  <book>
    <author>Don Box</author>
    <title lang="en">ASP.NET</title>
  </book>
</books>

```

```csharp
XDocument xmlDoc = new XDocument(
    new XElement("books",  // Root element <books>
        new XElement("book",  // Child element <book>
            new XElement("author", "Don Box"),  // Element <author> with value "Don Box"
            new XElement("title", "ASP.NET", new XAttribute("lang", "en"))  // Element <title> with value "ASP.NET" and an attribute "lang"
        )
    )
);

// Save or print the XML document
Console.WriteLine(xmlDoc);
```
### Saving `XDocument` to File
За да запишем `XDocument` във файл със стандартни настройки:

```csharp
xmlDoc.Save("myBooks.xml");
```

За да деактивираме автоматичната индентация:

```csharp
xmlDoc.Save("myBooks.xml", SaveOptions.DisableFormatting);
```
### Serialize DTO to XML
Това е процесът, при който обект (например DTO) се преобразува в XML формат, който може да бъде записан във файл или изпратен към външен източник.

```csharp
var serializer = new XmlSerializer(typeof(ProductDTO));
using (var writer = new StreamWriter("myProduct.xml"))
{
    serializer.Serialize(writer, product);
}
```

**Обяснение:**

- **`XmlSerializer`**: Това е класът, който използваме за сериализация на обекти в XML. В този случай, той е инициализиран за типа `ProductDTO`.

- **`StreamWriter`**: Това е обект, който позволява писане в текстови файлове. В примера се използва за записване на резултата от сериализацията в XML файл с име "myProduct.xml".

- **`serializer.Serialize`**: Това е методът, който извършва самото сериализиране. Той приема два параметъра:

    - Първият е **`writer`**, който указва къде да запишем резултата (в нашия случай във файл).
    - Вторият е самият обект, който искаме да сериализираме (тук това е обект от типа `ProductDTO`).

Когато този код бъде изпълнен, обектът `product` ще бъде преобразуван в XML формат и записан във файл "myProduct.xml".

Ако искаме да сериализираме DTO обект в XML и да го запишем в **стринг**, вместо във файл, можем да използваме `StringWriter`, който позволява записване в паметта, вместо във файл. Това ще генерира XML представяне на обекта като стринг.

Пример:

```csharp
var serializer = new XmlSerializer(typeof(ProductDTO));
using (var stringWriter = new StringWriter())
{
    serializer.Serialize(stringWriter, product);
    string xmlString = stringWriter.ToString();
    Console.WriteLine(xmlString);
}
```

**Обяснение:**

- **`StringWriter`**: Това е клас, който работи по същия начин като `StreamWriter`, но вместо да записва във файл, той записва в паметта и генерира текстов низ. В този случай той съхранява XML представянето на обекта като стринг.

- **`serializer.Serialize`**: Този метод сериализира обекта, като вместо да записва във файл, записва в `stringWriter`, който ще съдържа XML съдържанието.

- **`stringWriter.ToString()`**: След сериализацията, извикваме `ToString()` върху `stringWriter`, за да получим самия XML като текстов низ.

След като този код бъде изпълнен, ще имаме XML представянето на обекта като стринг, който можем да използваме за по-нататъшна обработка или изпращане.
### Deserialize XML to DTO
Пример за десериализиране на XML стринг:

```csharp
var serializer = new XmlSerializer(typeof(OrderDto[]), new XmlRootAttribute("Orders"));
var deserializedOrders = (OrderDto[])serializer.Deserialize(new StringReader(xmlString));

// Convert the DTO objects to entity objects
var orders = deserializedOrders.Select(dto => new Order
{
    CustomerName = dto.CustomerName,
    OrderDate = dto.OrderDate,
    TotalAmount = dto.TotalAmount
}).ToList();

// Save the entity objects to the database
using (var context = new YourDbContext())
{
    context.Orders.AddRange(orders);
    context.SaveChanges();
}
```

**Обяснение:**

- **`XmlSerializer`**: Използва се за десериализиране на XML в съответния обектен тип. Тук типът е `OrderDto[]`, което означава, че очакваме масив от обекти от тип `OrderDto`.

- **`XmlRootAttribute("Orders")`**: Указва, че XML коренният елемент е `"Orders"`. Това е полезно, когато XML съдържа различни коренни елементи и трябва да посочим конкретния.

- **`StringReader(xmlString)`**: Използваме `StringReader` за да предоставим XML низа, който ще бъде десериализиран в обекти.

- **`Deserialize()`**: Метод за преобразуване на XML данни в обект от тип `OrderDto[]`.
### Exception Handling and Potential Issues
При работа със сериализация и десериализация на XML може да срещнем различни проблеми, които трябва да обработим правилно. Ето някои от тях:

1. **Невалиден XML формат**

Ако XML данните не са в правилен формат (например липсващ или неправилен коренен елемент, или неправилна структура), ще бъде хвърлена грешка по време на десериализацията. В такъв случай е добре да използваме обработка на изключения с `try-catch`, за да можем да уловим и да се справим с грешката.

**Пример за обработка на грешка при десериализация:**

```csharp
try
{
    var serializer = new XmlSerializer(typeof(OrderDto[]), new XmlRootAttribute("Orders"));
    var deserializedOrders = (OrderDto[])serializer.Deserialize(new StringReader(xmlString));
}
catch (InvalidOperationException ex)
{
    Console.WriteLine("Error during deserialization: " + ex.Message);
}
```

В този случай, ако XML е невалиден, ще бъде хвърлена грешка от типа `InvalidOperationException`, която може да съдържа подробности относно причината за невалидността.

2. **Проблеми с атрибутите на DTO обектите**

Ако има проблеми с атрибутите на DTO обектите (например, ако даден атрибут от XML не съвпада с наличния в DTO обекта), десериализацията може да не работи както очакваме. Възможно е да получим празни стойности или дори да не можем да десериализираме целия XML.

**Пример за обработка на грешка при несъответствие в DTO:**

```csharp
try
{
    var serializer = new XmlSerializer(typeof(ProductDTO));
    using (var reader = new StringReader(xmlString))
    {
        var product = (ProductDTO)serializer.Deserialize(reader);
    }
}
catch (InvalidOperationException ex)
{
    Console.WriteLine("Error during DTO deserialization: " + ex.Message);
}
```

3. **Валидация на данни**

Важно е да извършим валидация на десериализираните данни, особено когато се работи с DTO обекти, които ще бъдат използвани за по-нататъшна обработка (като запис в база данни). Ако има проблеми със стойностите на данните (например, липсваща или невалидна стойност), валидацията може да хвърли грешка. В такива случаи е полезно да използваме отделни валидатор класове за проверка на данните, преди да продължим с тяхната обработка.

**Пример за валидация на десериализиран DTO:**

```csharp
var validator = new OrderDtoValidator();
var validationResults = validator.Validate(deserializedOrders);

if (!validationResults.IsValid)
{
    foreach (var failure in validationResults.Errors)
    {
        Console.WriteLine($"Error: {failure.ErrorMessage}");
    }
}
else
{
    // Continue with processing the valid data
}
```

4. **Проблеми със специфични атрибути за сериализация**

При сериализацията на обекти с атрибути като `XmlElement`, `XmlAttribute` и други, може да се появят проблеми, ако тези атрибути не са правилно конфигурирани или ако XML форматът не съвпада с очакванията. Тези проблеми може да изискват допълнителна настройка или корекция на атрибутите върху DTO класовете.
## XML Attributes
Data annotation атрибути, които носят мета информация за ролята на дадено пропърти в XML-а. Това е необходимо за правилната сериализация и десериализация.

Атрибути за контрол на сериализацията към XML:

`[XmlType("Name")]` – задава типа на кореновия елемент в XML.

`[XmlAttribute("name")]` – пропъртито в модела ще бъде сериализирано като атрибут.

`[XmlElement("ElementName")]` – сериализира пропъртито като XML елемент.

`[XmlIgnore]` – пропъртито няма да се сериализира.

`[XmlArray("ArrayName")]` – този атрибут обгръща колекция от елементи в общ контейнер с името `"ArrayName"`. Заедно с него често се ползва и `[XmlArrayItem("ItemName")]`, който указва името на всеки елемент в колекцията.

```csharp
[XmlRoot("Library")]
public class Library
{
    [XmlArray("Books")]
    [XmlArrayItem("Book")]
    public List<string> Books { get; set; }
}
```

Резултатен XML:

```xml
<Library>
    <Books>
        <Book>C# in Depth</Book>
        <Book>Clean Code</Book>
        <Book>ASP.NET Core</Book>
    </Books>
</Library>
```

`[XmlRoot("RootName")]` – задава името на кореновия елемент.

`[XmlText]` – сериализира съдържанието на пропъртито като текст в рамките на елемент.

**Example:**

Можем да ползваме няколко XML атрибута за да контролираме сериализацията:

```csharp
[XmlType("Book")]
public class BookDto
{
    [XmlAttribute("name")]
    public string Name { get; set; }

    [XmlElement("Author")]
    public string Author { get; set; }

    [XmlIgnore]
    public decimal Price { get; set; }
}
```

**Обяснение на примера:**

- `[XmlType("Book")]` – кореновият елемент в XML ще бъде `<Book>`.

- `[XmlAttribute("name")]` – свойството `Name` ще се сериализира като атрибут `<Book name="...">`.

- `[XmlElement("Author")]` – свойството `Author` ще се сериализира като вложен елемент `<Author>`.

- `[XmlIgnore]` – свойството `Price` няма да бъде сериализирано.

Тази структура ще се преобразува в следния XML:

```xml
<Book name="C# in Depth">
    <Author>Jon Skeet</Author>
</Book>
```
# Misc
# ChatGPT
# Bookmarks
Completion: 14.03.2025