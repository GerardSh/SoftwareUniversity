# General
## Relational and Non-Relational Databases Differences
### Relational Database
Организира данните в една или повече таблици с колони и редове.

Уникален ключ, който идентифицира всеки ред данни.

Почти всички релационни бази данни използват диалект на SQL за извличане на данни.

Връзките между таблиците се реализират чрез чужди ключове (FK).

Примери за такива бази данни са Oracle, MySQL, SQL Server и други.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250404133257.png)

Връзката е Foreign Key в едната таблица, който сочи към Primary Key в другата таблица.
### Non-relational Database (NoSQL)
NoSQL бази данни са нетаблични и съхраняват данни по различен начин от релационните таблици.

Storage от тип ключ-стойност.

```
{  
"_id": ObjectId("59d3fe7ed81452db0933a871"),  
"email": "p  
}
```

SQL заявки не се използват в NoSQL системи.

По-скалируеми и осигуряват по-добро представяне.
## Database Scalability
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250404140827.png)

Възможността на базата данни на системата да се мащабира нагоре или надолу в зависимост от изискванията.

- Позволява на базата данни да се разширява до по-голям размер, за да поддържа повече транзакции.
- Има два типа възможности за разширяване на базите данни:

    - **Vertical Scaling** или **Scale-up** увеличава производителността на самата машина, но това е ограничено до определена граница. Също така, това може да бъде скъпа операция.

    - **Horizontal Scaling** или **Scale-out** е много по-евтино, може да се извършва и на виртуални машини, без да е нужно да се добавят отделни хостове.

Релационните бази данни обикновено не поддържат хоризонтално мащабиране, тъй като те са проектирани с фокус върху вертикалното скалиране.
### Vertical Scaling
Отнася се до процеса на добавяне на повече физически ресурси към съществуващия сървър на базата данни с цел подобряване на производителността, като например:

- Съхранение
- Памет
- CPU

Това помага за увеличаване на капацитета на съществуващия сървър на базата данни.

**Предимства:**

- Консумира по-малко енергия.
- Трябва да управляваме и обработваме само една система.
- Разходите за охлаждане са по-малки от тези при хоризонталното мащабиране.
- Изпълнението не е сложно.

**Недостатъци:**

- Риск от отказ на хардуера, което може да доведе до по-големи прекъсвания.
- Ограничена възможност за бъдещи ъпгрейди.
### Horizontal Scaling
Добавя повече сървъри с по-малко RAM и процесори.

- Възможността да се увеличи капацитетът чрез свързване на множество софтуерни или хардуерни единици по такъв начин, че да функционират като една логична единица.
- Ако клъстерът изисква повече ресурси за подобряване на производителността и осигуряване на висока наличност, администраторът може да направи мащабиране чрез добавяне на още сървъри към клъстера.

**Предимства:

- Лесно се ъпгрейдва.
- Устойчивостта е подобрена поради наличието на отделни, множество системи.
- Поддържа линейни увеличения на капацитета.

**Недостатъци:**

- Заема по-голямо пространство в дата центъра.
- Добавя сложност към системата.
- Възникват проблеми със синхронизацията на данни.
- Зависимо от CAP теоремата.
## CAP Theorem
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250404145717.png)

**CAP теоремата** гласи, че една разпределена система може да осигури само две от трите желани характеристики:

- **Последователност (Consistency)** – всички възли в системата виждат едни и същи данни по едно и също време.

- **Наличност (Availability)** – системата винаги отговаря на заявки, дори ако някои възли са офлайн.

- **Толерантност към мрежови разделения (Partition Tolerance)** – системата продължава да функционира, дори ако има загуба на комуникация между отделни части от нея.

**Последователност (Consistency)**

- Всички клиенти виждат едни и същи данни по едно и също време, независимо към кой възел се свързват.
- Когато данните се записват в един възел, те трябва незабавно да бъдат препратени или репликирани към всички останали възли в системата, преди записът да се счита за „успешен“.

**Наличност (Availability)**

- Всеки клиент, който прави заявка за данни, получава отговор, дори ако един или повече възли са недостъпни.

**Толерантност към мрежови разделения (Partition Tolerance)**

- Клъстерът трябва да продължи да работи, независимо от броя на прекъсванията в комуникацията между възлите в системата.
## Distributed Systems
**Разпределена мрежа**

- Мрежа, която съхранява данни на повече от една физическа или виртуална машина едновременно.
- NoSQL базите данни често са разпределени и данните се съхраняват на множество компютри.

**8 Fallacies of Distributed Systems**

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250404173311.png)

- Мрежата е надеждна и хомогенна.
- Латентността е нулева.
- Пропускателната способност е безкрайна.
- Мрежата е сигурна.
- Топологията не се променя.
- Има само един администратор.
- Транспортните разходи са нулеви.
## Key-Value Databases
Работят чрез съхраняване и управление на асоциативни масиви.

**Ключовете (Keys)** служат като уникални идентификатори за извличане на съответната стойност.

**Стойностите (Values)** могат да бъдат всичко – от прости обекти като цели числа или низове до по-сложни обекти.
## Document-Oriented Databases
NoSQL бази данни, които съхраняват данни под формата на документи.

Представляват вид **key-value storages**, където всеки документ има **уникален идентификатор**.

Самият **документ служи като стойност**.

Обикновено се съхраняват във формати като **JSON, XML, Proto-Buff** и др.
## Replication
Група от **`mongod`** инстанции, които поддържат едни и същи данни.

Ако **първичният възел (primary)** стане недостъпен, **вторичен възел (secondary)**, който отговаря на условията, ще проведе избори, за да стане новият **първичен възел**.

Всички **четения и записвания** се извършват през **първичния възел** (може да се конфигурира).
## `Sharding`
Метод за **разпределяне на данни** между множество машини.

MongoDB използва **`sharding`**, за да поддържа среди с **много големи набори от данни** и **операции с висока производителност**.

Базите данни с **големи обеми данни** или **интензивен трафик** могат да надхвърлят капацитета на един сървър.
### Sharded Cluster
**Sharded клъстер в MongoDB** се състои от следните компоненти:

**Shard** – всеки съдържа подмножество от разпределените данни.  
**Mongos** – рутер за заявки, който осигурява интерфейс между клиентските приложения и sharded клъстера.  
**Config Servers** – съхраняват метаданни и конфигурационни настройки за клъстера.
## Columnar Databases
**Колонни бази данни** са системи за бази данни, които съхраняват данни по колони.

Всяка колона се съхранява в отделен файл или регион в storage-a на системата.

Примери за колонни бази данни са **Cassandra**, **Hbase**, **Redshift** и други.

**Основни предимства на колонните бази данни включват:**

- По-бързо представяне при зареждане, търсене и агрегатни функции.
- Колонно ориентираните организации са по-ефективни, когато трябва да се изчисли агрегат върху много редове, но само за по-малък набор от всички колони от данни.
- Не са ефективни, когато много колони от един ред се изискват едновременно.

Това се дължи на факта, че при колонните бази данни данните от различни колони се съхраняват поотделно, което позволява да се оптимизира достъпът и обработката на малък набор от атрибути. Но ако се изискват данни от множество колони в един ред, тогава това може да не бъде толкова ефективно, защото данните трябва да бъдат извлечени от различни места.
## Cassandra
Обикновено се счита за **AP (в CAP)**

Всеки възел в клъстера има същата роля. Няма единна точка на отказ.

Данните се разпределят между възлите в клъстера (така че всеки възел съдържа различни данни).

Неработещите възли поради възникнал проблем могат да бъдат заменени без прекъсване на работата.

**В крайна сметка консистентни** (може да се конфигурира).

Използва **CQL** за заявки.

Това означава, че в тези системи не е гарантирана незабавна консистентност, но те осигуряват висока наличност и partition tolerance, като в крайна сметка данните ще бъдат синхронизирани между възлите.

През ноември 2015 г. **Discord** преминава от **MongoDB** към **Cassandra** за съхранение на милиарди съобщения.

**Netflix** използва **Cassandra** като своя backend база данни за стрийминг услугите си.

**Apple** използва **100,000 възела Cassandra**.

**Uber** използва **Cassandra** за съхранение на около 10,000 характеристики (features).

Много други приложения също използват **Cassandra** за scaling и висока наличност при работа с големи обеми от данни.

Това показва, че **Cassandra** е предпочитан избор за големи, разпределени системи, които изискват висока производителност, scaling и наличност.
## Graph Database
Графова база данни съдържа колекция от възли и edges (ребра).

Възелът представлява обект.

Edge-a представлява връзката или отношението между два обекта.

Позволяват бързо и лесно извличане на сложни йерархични структури, които са трудни за моделиране в релационни системи.

Няма универсален език за заявки за графови бази данни (като SQL). Всяка база данни има собствена имплементация на заявки.

Всеки възел е идентифициран чрез уникален идентификатор, който изразява двойки ключ-стойност.

Всеки edge е дефиниран чрез уникален идентификатор, който указва началния или крайния възел, заедно с набор от свойства.
## MongoDB Overview
MongoDB е документна база данни.

Тя съхранява данни в гъвкави BSON документи.

Моделът на документите съвпада с обектите в приложния код, което прави работата с данни лесна.

MongoDB е разпределена база данни в основата си.

Може да изтеглим от: [Download MongoDB Community Server | MongoDB](https://www.mongodb.com/try/download/community)

След като инсталираме MongoDB, ще е необходим драйвер.
- Един за използване с Node.js, .NET, Java и други  
- MongoDB C#/.NET драйвер: [MongoDB C# Driver - C#/.NET Driver v3.3 - MongoDB Docs](https://www.mongodb.com/docs/drivers/csharp/current/)
### Working with MongoDB GUI
Може да изберем, като има голям избор, например: 

[Robo 3T | Free, open-source MongoDB GUI (formerly Robomongo)](https://robomongo.org/) - Robo 3T

[NoSQLBooster - The Smartest GUI Tool and IDE for MongoDB](https://nosqlbooster.com/) - NoSQLBooster
 
[MongoDB Compass | MongoDB](https://www.mongodb.com/products/tools/compass) - Compass
### Working with MongoDB Shell Client
Start the MongoDB Shell from the Command Line Interface (CLI).

Type the following command:

```
mongo
```

Once the shell is running, we can execute queries such as:

Display all databases:

```
show dbs
```

Select a database:

```
use mytestdb
```

Insert a document into a collection:

```
db.mycollection.insert({"name":"George"})
```

Find documents with the name "George":

```
db.mycollection.find({"name":" George"})
```

Find all documents in the collection:

```
db.mycollection.find({})
```

[What is MongoDB? - Database Manual v8.0 - MongoDB Docs](https://www.mongodb.com/docs/manual/)
### CRUD Operations
To connect to a MongoDB cluster, use the connection string for your cluster

```csharp
using MongoDB.Bson;
using MongoDB.Driver;
…
var client = new MongoClient(
"mongodb+srv://<username>:<password>@<cluster-address>/test?w=majority"
);
var database = client.GetDatabase("Example");
var collection = database.GetCollection<Interactions>("Interactions");
```

To select a document use LINQ:

```csharp
var result = IMongoCollectionExtensions
 .AsQueryable(collection)
 .FirstOrDefault(s => s.SiteName == "Example");
```

`FindOneAndUpdate()`

```csharp
var update = MongoDB.Driver.Builders.Update.Set(s => s.SiteName,
"New Example");
collection.FindOneAndUpdate(s => s.SiteName == "Example",
update);
```

`DeleteOne()`

```csharp
// Deletes the first document that meets the filter

collection.DeleteOne(e => e.Name =="Example");
```

`InsertOne()`

```csharp
collection.InsertOne(newItem);
```
# Misc
## Polyglot Persistence
Не е достатъчно да познаваме само релационните бази данни, за да работим ефективно с всички налични типове данни. Martin Fowler популяризира термина _polyglot persistence_, който подчертава, че една единствена база данни не винаги е достатъчна.

Съвременните приложения обработват различни видове данни, като всеки тип работи оптимално с различни бази данни. Например, в уеб магазин:

- **Каталогът на продуктите и потребителите** могат да се съхраняват в релационна база данни, тъй като структурата им е добре дефинирана.
    
- **Потребителската количка** може да бъде съхранявана в _key-value store_, което позволява бърз достъп и лесно управление на състоянието.
    
- **Рекомeндациите** (например свързани продукти на база предишни покупки) могат да бъдат съхранявани в _графова база данни_, тъй като тя е оптимизирана за работа със сложни връзки между обекти.
    
- **Допълнителни данни, като динамични описания и атрибути на продукти**, могат да се съхраняват в _документно-ориентирана база данни_, което позволява по-гъвкава структура.

Често една база данни не е достатъчна – приложенията обикновено изискват два или три вида, като основно се използват релационни бази данни (RDBMS). Има и вариант да се използва _multi-paradigm_ база данни, каквато е Cosmos DB, която съчетава различни типове бази данни в едно решение.

Използването на различни типове бази данни според конкретните нужди подобрява производителността, гъвкавостта и възможностите за разширяване на системата.

[Polyglot Persistence](https://martinfowler.com/bliki/PolyglotPersistence.html)
# ChatGPT
# Bookmarks
[Polyglot Persistence](https://martinfowler.com/bliki/PolyglotPersistence.html)

**MongoDB:**

[What is MongoDB? - Database Manual v8.0 - MongoDB Docs](https://www.mongodb.com/docs/manual/)

[Download MongoDB Community Server | MongoDB](https://www.mongodb.com/try/download/community)

[MongoDB C# Driver - C#/.NET Driver v3.3 - MongoDB Docs](https://www.mongodb.com/docs/drivers/csharp/current/)

[Robo 3T | Free, open-source MongoDB GUI (formerly Robomongo)](https://robomongo.org/)

[NoSQLBooster - The Smartest GUI Tool and IDE for MongoDB](https://nosqlbooster.com/)
 
[MongoDB Compass | MongoDB](https://www.mongodb.com/products/tools/compass)

Completion: 04.04.2025