# General
## Layered Architecture
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250319141406.png)

Архитектурата на приложението е изградена върху няколко слоя, всеки от които има специфична роля:

1. **Data Layer**

    Това е слой, който съдържа моделите, които осъществяват директната комуникация с базата данни. Той отговаря за извършване на заявки, манипулиране на данни и взаимодействие с базата. Този слой е свързан с конкретната имплементация на базата данни и е отговорен за всичко, свързано с нея.

2. **Web Layer**

	Този слой на приложението, е напълно независим от базата данни. Приложението се изгражда на база наличните данни в базата. Например, ако базата съдържа информация за филми, създаваме приложение за управление на филми. Важното е, че типът на базата данни не трябва да има значение — приложението трябва да работи независимо от това коя база е използвана. Основната му задача е да осигури визуализация на данни и взаимодействие с потребителите чрез UI/UX, без да се интересува откъде идват тези данни. Независимо дали данните идват от база данни, файл или памет, Web слоя знае, че трябва да чете и записва данни и да предоставя възможности за взаимодействие на потребителите. Голямото предимство тук е, че Web слоя не зависи от източника на данни — ако сменим базата данни или технологиите, всичко, което трябва да променим, е съответният слой, докато Web слоя остава същият. Това прави приложението много по-гъвкаво и лесно за пренасяне към различни среди и източници на данни.

3. **Service / Business Logic Layer**  

	Layer-a за бизнес логика се намира между слоя за данни (Data) и уеб приложението (Web) и играе ключова роля в комуникацията между тях. Например, когато уеб приложението трябва да покаже на потребителя всички филми, то изпраща заявка към съответната услуга (service). Тази услуга знае какви стъпки да предприеме, за да извлече необходимите данни.

	В случая, уеб приложението извиква услуга като **`GetAllMovies`**, която съдържа бизнес логика, определяща как правилно да се извлекат всички филми чрез заявка към базата данни. Получените резултати се връщат обратно към уеб приложението във вид на **`MoviesViewModel`**. Уеб приложението след това представя тези данни във визуален формат (UI/UX), без да се налага допълнително преобразуване.

	Цялата логика, свързана с това кои филми да се извлекат (например изключване на изтритите филми), се реализира в слоя за бизнес логика. Именно тук се изграждат заявките (например чрез LINQ), които се предават към слоя за данни (Data). Data моделите от своя страна генерират съответните SQL заявки, които се изпълняват върху базата данни.

	Резултатите се връщат чрез **`DbContext`** под формата на **`IEnumerable<T>`** или **`IQueryable<T>`**. В слоя за бизнес логика може да се прецени кога заявката трябва да бъде материализирана или дали даден обект трябва да бъде закачен или разкачен към контекста.

	Основната цел на слоя за бизнес логика не е просто да извлече данните, а и да ги трансформира в подходящ формат, така че уеб приложението да ги получи в готов вид за визуализация.

	В идеалния случай уеб приложението не трябва да преобразува данните – неговата задача е само да ги валидира и подаде на по-долните слоеве. Същото важи и в обратната посока – когато данните се връщат към уеб приложението, то просто ги визуализира в изгледа (View), без да се налага допълнителна обработка. Тази структура осигурява ясен разделение на отговорностите и улеснява поддръжката и разширяемостта на системата.

4. **Common Layer**  

	Този слой съдържа споделена информация и ресурси, достъпни за всички останали слоеве на приложението. Той обикновено включва глобални конфигурации, общи данни и функционалности, които осигуряват консистентност в работата на системата. Поради своята роля тези ресурси често се наричат „глобалки“ и са предназначени да бъдат достъпни от всеки слой в приложението.

**Предимства на архитектурата:**

- **Лесна разширяемост**: Архитектурата позволява лесно добавяне на нови приложения, като например конзолни приложения, които се свързват през сървисите. Това означава, че можем да добавяме нови функционалности без да променяме базата данни - можем да създадем приложение само за дебъгване на базата данни, без да добавяме допълнителни функционалности.
    
- **Преносимост**: Приложението може лесно да бъде пренесено към различни среди. Ако променим базата данни или някаква друга технология, единственото, което трябва да променим, е съответният слой (Data Layer), докато останалите слоеве остават непроменени.
    
- **Отделяне на отговорностите**: Всеки слой има ясно дефинирана роля и отговорности, което прави кода по-разбираем, по-лесен за поддръжка и разширяване.

Тази архитектура е особено полезна при необходимост от дебъгване на базата данни или други операции, които изискват изпълнение извън Web слоя. Например, създаването на отделно конзолно приложение, което да работи като дебъг инструмент, може да бъде много удобно за тестове и проверка на правилната работа на базата данни или на функционалността на сървисите, без да се налага да работим с цялото приложение.
## Identity
Data слоят съдържа начална миграция, която включва всички таблици от Identity системата на ASP.NET. 
ASP.NET предоставя много функционалности наготово, включително тази система за удостоверяване и управление на потребители.

Identity системата позволява на потребителите да създават акаунти, да се вписват, да възстановяват забравени пароли и да получават имейли за потвърждение или възстановяване на достъп. Тази система функционира като вграден framework във framework-а.

Когато посочим, че искаме да ползваме Identity, ASP.NET автоматично генерира необходимите таблици. Те включват:

- Потребители
- Роли на потребителите
- История на влизанията
- Асоциация между потребители и техните роли
- Таблици за токъни и други свързани данни

Този подход улеснява значително внедряването на система за удостоверяване в приложенията.
### `ApplicationUser` Model
```csharp
public class ApplicationUser : IdentityUser<Guid>
{
    public ApplicationUser()
    {
        Id = Guid.NewGuid();
    }
}
```

Този модел разширява стандартния клас `IdentityUser` на Entity Framework, което позволява промяна на типа на **Primary Key** му, който по подразбиране е от тип **string**. Използването на **GUID** за основен ключ е било необходимо, защото по-старите версии на EF Core не са поддържали **GUID** като тип за Primary Key. В миналото е било практика да се използва **GUID**, като се извиква методът `ToString()`. Въпреки това, с по-новите версии на EF Core вече е възможно да се използва директно **GUID**, което осигурява по-голяма сигурност и уникалност на идентификаторите.
## DbContext Constructor
```csharp
        public CinemaDbContext(DbContextOptions<CinemaDbContext> options)
            : base(options)
        {
        }
```

Този конструктор се използва от уеб приложението чрез dependency injection, което автоматично подава необходимите опции за конфигурация на контекста.
## Comment Attributes
Коментарите, които добавяме в ентити моделите чрез атрибути, представляват специални коментари, които Entity Framework третира и включва в базата данни като коментари към съответните колони или таблици. Това дава възможност на DB инженерите да разбират защо даден елемент е създаден по този начин в контекста на Code First модела, което помага за по-доброто поддържане и разширяване на базата данни.
## Entity Level Filters
```csharp
entity.HasQueryFilter(e => e.IsDeleted == false)
```

Можем да добавяме **query filters** на глобално ниво, така че всички заявки към дадено ентити автоматично да взимат само тези записи, които отговарят на условието. При използване на **soft delete**, обикновено искаме да извличаме само записите, за които `IsDeleted` е `false`. За да постигнем това, в бизнес логиката, където правим заявки, трябва да извършваме филтрация. Това може да се осигури глобално, на ниво запитване, като добавим филтър към всички заявки за съответното ентити/таблица в метода **`OnModelCreating`** на контекста на базата данни.
## Best Practices for Code Clarity and Specification Reference
За да подобрим яснотата и поддръжката на кода, е добра практика да се избягва използването на магически низове и числа в кода. Вместо това, трябва да дефинираме константи или конфигурационни настройки за стойности, които се използват многократно, като например дължини на колони, формати на числа и т.н. Този подход улеснява актуализирането на стойности и осигурява яснота относно тяхното значение.

Освен това, когато следваме определени спецификации, стандарти или изисквания (като вътрешни насоки на компанията, регулаторни правила или клиентски спецификации), е добра идея да добавим препратка към съответната спецификация или документ в кода. Това осигурява контекст за използваната стойност и гарантира, че бъдещи разработчици могат лесно да проследят оригиналната спецификация, ако е необходимо.

Ето как може да изглежда такъв коментар:

```csharp
// It's good to avoid magic strings and numbers in the code
// Also, cite the specification or standard that justifies this value
/// <summary>
/// SWS_Cinema_EntityValidation_700152878: Cinema name should be able to store text with length up to 256
/// </summary>
public const int NameMaxLength = 256;
```

В този пример:

- Коментарът обяснява стойността и защо е избрана така.
- Коментарът в `summary` предоставя препратка към конкретна спецификация (в случая `SWS_Cinema_EntityValidation_700152878`), която ясно показва причината за избор на дължината `256` за името на киното.

Тази практика прави кода самодокументиращ се и помага на бъдещите разработчици лесно да разберат контекста на взетите решения, както и че кодът остава в съответствие с външни спецификации и стандарти.
## Seeding
Имаме няколко начина за seed-ване на данни:

1. **`Fluent API`** — Използва се методът `.HasData()` във Fluent API, който генерира миграция, съдържаща seed данните за базата.
    
    **Предимства:**
    
    - След като apply-нем миграциите, данните автоматично ще бъдат добавени в базата.
    - Ако приложението се стартира на друга машина, миграциите ще се apply-нат и данните ще се seed-нат автоматично.
    
    **Недостатък:**
    
    - Този подход е по-подходящ за development среда. В production не е препоръчителен, тъй като seed-натите данни може да създадат ненужен шум в базата.
2. **Custom Seed Method / Custom Seed Class** — При този подход импортваме данни от външен източник (например файл или мрежа), десериализираме ги и създаваме нови ентитети в базата.
    
    **Предимства:**
    
    - Много гъвкав и конфигурируем подход.
    - Подходящ за production среда, тъй като може да се управлява условно — например да се изпълнява само в development среда или при нужда.
    - Не създава излишен шум в базата при production разгръщане.

Този подход предлага по-голям контрол и се препоръчва за по-сложни сценарии или когато работим с големи обеми от данни.
## Web Application Builder
В ASP.NET Core файлът `Program.cs` съдържа метода `WebApplication.CreateBuilder()`, който създава уеб приложение, базирано на определени настройки и параметри. След като приложението бъде конфигурирано чрез този метод, тези параметри не могат да бъдат променяни.

**Конфигурация**

Един от ключовите параметри е **`ConfigurationManager`**, който извлича конфигурационни данни от конфигурационни файлове като:

- `appsettings.json` — използва се при разгръщане на приложението.
- `appsettings.Development.json` — съдържа настройки за development среда.
- **Secret Storage** — предпочитаният вариант за съхранение на чувствителна информация като connection strings, тъй като е локален за машината и по-сигурен от `appsettings.json`.

> [!NOTE]
> Ако една и съща конфигурационна стойност съществува и в `appsettings.json`, и в `secrets.json`, ще бъде взета стойността от `secrets.json`.

**Регистриране на услуги (Services)**

ASP.NET Core разчита на механизма **Dependency Injection** (DI) за управление на зависимостите.

- Услугите (services) се регистрират в **Service Collection** — голяма колекция, подобна на речник (dictionary), която съдържа всички инстанции на обектите, необходими на приложението.
- Тази колекция съдържа както стандартни ASP.NET услуги, така и наши собствени custom услуги.

Пример за регистриране на `DbContext` в Service Collection:

```csharp
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));
```

**Как работи Dependency Injection**

Когато ASP.NET Core изпълнява метод или конструктор, който очаква параметър от определен тип (например `DbContext`), той търси този тип в Service Collection.

Примерен метод с DI:

```csharp
public void MyMethod(AppDbContext dbContext)
{
    // Използване на dbContext
}
```

ASP.NET Core ще потърси в Service Collection ключ, съответстващ на типа `AppDbContext`. Ако го намери, ще подаде инстанцията като стойност на параметъра.

- Ако типът не е регистриран в Service Collection, ще бъде генерирана грешка за unresolved зависимост.

**Жизнени цикли на услугите (Service Lifetimes)**

Услугите могат да бъдат регистрирани с различен обхват (lifetime):

- **Singleton** — Една-единствена инстанция се създава за целия живот на приложението.
- **Transient** — Нова инстанция се създава при всяко заявяване на услугата, дори в рамките на един и същи обхват.
- **Scoped** — В рамките на една заявка се създава само една инстанция. При следваща заявка ще бъде създадена нова инстанция.

Пример за регистрация на услуги с различен обхват:

```csharp
builder.Services.AddSingleton<ISingletonService, SingletonService>();
builder.Services.AddTransient<ITransientService, TransientService>();
builder.Services.AddScoped<IScopedService, ScopedService>();
```

Този модел осигурява гъвкавост и контрол върху жизнения цикъл на обектите в приложението, което е ключово за ефективното управление на ресурсите.

**`AddDatabaseDeveloperPageExceptionFilter()`**

`AddDatabaseDeveloperPageExceptionFilter` се използва за добавяне на филтър за изключения, когато приложението е в режим на разработка (Development). Този филтър осигурява подробна информация за изключенията, които се случват в базата данни, и показва допълнителна информация за грешките, свързани с Entity Framework Core.

Това е полезно за разработчиците, тъй като позволява да се получат подробни съобщения за грешки и стек трасировки, свързани с операциите върху базата данни, което улеснява откриването на проблеми по време на разработка.

Този филтър трябва да се използва само в режим на разработка и не трябва да бъде включен в производствената среда, защото може да разкрие чувствителна информация за базата данни или структурата на приложението.

**`AddDefaultIdentity<T>()`**

`AddDefaultIdentity` е метод в ASP.NET Core, който конфигурира стандартната система за идентификация и управление на потребители (authentication и authorization). Той автоматично добавя необходимите услуги за управление на потребители, роли и сигурност, включително пароли и удостоверяване. Методът също така предоставя готов интерфейс за регистрация и вход, който може да се персонализира. Методът `AddEntityFrameworkStores` се използва за конфигуриране на конкретен `DbContext`, който да се използва от системата за идентификация. По подразбиране, когато се добавя идентификация, се създава собствен `DbContext` за потребителите и ролите. Чрез `AddEntityFrameworkStores`, можем да посочим конкретен контекст, който да бъде използван за съхранение на данни за потребители, роли и други свързани със сигурността елементи.

**`AddControllersWithViews()`**

Методът `builder.Services.AddControllersWithViews()` в ASP.NET Core се използва за добавяне на поддръжка за контролери и изгледи (views) към приложението. Това означава, че приложението ще бъде настроено да работи с MVC архитектура, като се осигурява възможност за използване на контролери, които обработват HTTP заявки, и връщат изгледи за рендиране на потребителите.

След добавянето на необходимите услуги, методът `Build()` се използва за изграждане на конфигурирания `WebApplication`, който е готов за стартиране и изпълнение. Този процес създава финалния обект на приложението, който съдържа всички конфигурации и регистрирани услуги.

Същността на този процес е да се добавят всички необходими услуги за MVC и след това да се създаде приложението чрез `Build()`, което позволява стартирането на уеб приложението.
## Copy files to Output Directory on Build
Когато работим върху реален проект, който ще бъде деплойнат, е важно да създадем папка с файловете, които ще използваме и да зададем правилните **Build Action** за тези файлове.

По-точно:

1. **Създаване на папка с файлове**: Тези файлове могат да бъдат ресурси, конфигурационни файлове или други необходими файлове за приложението.

2. **Настройване на Build Action**: За да гарантираме, че файловете ще бъдат включени в build процеса, трябва да отидем в Properties на файловете и да зададем **Build Action** на "Copy Always" или "Copy if newer". Това означава, че файловете ще бъдат копирани в директорията, където се събира крайният output на приложението (работната директория). Това променя `.csproj` файла, като добавя информация за копирането на файловете в изходната директория при билдване на проекта.

3. **Работна директория**: При изграждането на проекта, тези файлове ще бъдат копирани в работната директория на приложението, което е важно за достъпването им чрез относителни пътища. Така когато приложението се изпълнява, ще може да достъпва файловете в работната директория, а не в директорията на изходния код.

4. **Проблем при деплойване**: Когато деплойваме приложението, ние обикновено деплойваме само **работната директория** и нейното съдържание. Ако файловете са част от изходния код (в source code директорията), те няма да бъдат включени в деплоймента и ще възникне проблем, ако се опитваме да ги достъпим по пътя към тях. Затова е важно да ги преместим в работната директория и да ги настроим така, че да се копират по време на build процеса.
# ChatGPT
## Using "Paste Special" in Visual Studio to Quickly Create DTO Objects from JSON or XML

In Visual Studio, you can use the **"Paste Special"** feature to quickly generate DTO (Data Transfer Object) classes from JSON or XML data. This allows you to avoid manually defining classes for complex structures.

**Steps to Generate DTO Classes from JSON or XML:**

1. **Copy the JSON or XML data**:
    
    - Copy the structure of the JSON or XML that you want to convert into a C# DTO class.
2. **Paste Special in Visual Studio**:
    
    - In Visual Studio, right-click where you want the DTO class to be created (usually in your `Models` or `DTOs` folder).
    - From the context menu, select **Edit** > **Paste Special** > **Paste JSON as Classes** (for JSON) or **Paste XML as Classes** (for XML).
3. **Automatically Generated Classes**:
    
    - Visual Studio will generate the corresponding C# class or classes with properties that map to the structure of the JSON or XML data.
4. **Usage**:
    
    - You can now use these generated classes to deserialize incoming JSON or XML into C# objects using `JsonSerializer.Deserialize<T>` for JSON or `XmlSerializer.Deserialize<T>` for XML.

**Example:**

For JSON:

1. **JSON data**:
    
```json
{
  "id": "123",
  "name": "Movie Title",
  "genre": "Action",
  "releaseDate": "2023-01-01"
}
```
    
2. **Generated DTO class** using **Paste JSON as Classes**:
    
```csharp
public class RootObject
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string Genre { get; set; }
    public DateTime ReleaseDate { get; set; }
}
```
    

Now you can easily deserialize the JSON data into the `RootObject` class:

```csharp
string jsonString = "{\"id\":\"123\",\"name\":\"Movie Title\",\"genre\":\"Action\",\"releaseDate\":\"2023-01-01\"}";
RootObject movie = JsonSerializer.Deserialize<RootObject>(jsonString);
```

Benefits:

- **Saves time**: Automatically generates DTOs based on the structure of JSON/XML data.
- **Consistency**: Ensures that the class structure matches the data format, reducing human error.
- **Flexibility**: Easily adapts to any new JSON or XML structure.

This approach is great when working with external APIs or large datasets where defining DTO classes manually can be cumbersome.
# Bookmarks