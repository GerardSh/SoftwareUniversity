# General
## Layered Architecture
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250319141406.png)

Архитектурата на приложението е изградена върху няколко слоя, всеки от които има специфична роля:

1. **Data Layer**

    Това е слой, който съдържа моделите, които осъществяват директната комуникация с базата данни. Той отговаря за извършване на заявки, манипулиране на данни и взаимодействие с базата. Този слой е свързан с конкретната имплементация на базата данни и е отговорен за всичко, свързано с нея.

2. **Web Layer**

	Този слой на приложението, е напълно независим от базата данни. Приложението се изгражда на база наличните данни в базата. Например, ако базата съдържа информация за филми, създаваме приложение за управление на филми. Важното е, че типът на базата данни не трябва да има значение — приложението трябва да работи независимо от това коя база е използвана. Основната му задача е да осигури визуализация на данни и взаимодействие с потребителите чрез UI/UX, без да се интересува откъде идват тези данни. Независимо дали данните идват от база данни, файл или памет, Web слоя знае, че трябва да чете и записва данни и да предоставя възможности за взаимодействие на потребителите. Голямото предимство тук е, че Web слоя не зависи от източника на данни — ако сменим базата данни или технологиите, всичко, което трябва да променим, е съответният слой, докато Web слоя остава същият. Това прави приложението много по-гъвкаво и лесно за пренасяне към различни среди и източници на данни.

3. **Service / Business Logic Layer**  

	Layer-a за бизнес логика се намира между слоя за данни (Data) и уеб приложението (Web) и играе ключова роля в комуникацията между тях. Например, когато уеб приложението трябва да покаже на потребителя всички филми, то изпраща заявка към съответната услуга (service). Тази услуга знае какви стъпки да предприеме, за да извлече необходимите данни.

	В случая, уеб приложението извиква услуга като **`GetAllMovies`**, която съдържа бизнес логика, определяща как правилно да се извлекат всички филми чрез заявка към базата данни. Получените резултати се връщат обратно към уеб приложението във вид на **`MoviesViewModel`**. Уеб приложението след това представя тези данни във визуален формат (UI/UX), без да се налага допълнително преобразуване.

	Цялата логика, свързана с това кои филми да се извлекат (например изключване на изтритите филми), се реализира в слоя за бизнес логика. Именно тук се изграждат заявките (например чрез LINQ), които се предават към слоя за данни (Data). Data моделите от своя страна генерират съответните SQL заявки, които се изпълняват върху базата данни.

	Резултатите се връщат чрез **`DbContext`** под формата на **`IEnumerable<T>`** или **`IQueryable<T>`**. В слоя за бизнес логика може да се прецени кога заявката трябва да бъде материализирана или дали даден обект трябва да бъде закачен или разкачен към контекста.

	Основната цел на слоя за бизнес логика не е просто да извлече данните, а и да ги трансформира в подходящ формат, така че уеб приложението да ги получи в готов вид за визуализация.

	В идеалния случай уеб приложението не трябва да преобразува данните – неговата задача е само да ги валидира и подаде на по-долните слоеве. Същото важи и в обратната посока – когато данните се връщат към уеб приложението, то просто ги визуализира в изгледа (View), без да се налага допълнителна обработка. Тази структура осигурява ясен разделение на отговорностите и улеснява поддръжката и разширяемостта на системата.

4. **Common Layer**  

	Този слой съдържа споделена информация и ресурси, достъпни за всички останали слоеве на приложението. Той обикновено включва глобални конфигурации, общи данни и функционалности, които осигуряват консистентност в работата на системата. Поради своята роля тези ресурси често се наричат „глобалки“ и са предназначени да бъдат достъпни от всеки слой в приложението.

**Предимства на архитектурата:**

- **Лесна разширяемост**: Архитектурата позволява лесно добавяне на нови приложения, като например конзолни приложения, които се свързват през сървисите. Това означава, че можем да добавяме нови функционалности без да променяме базата данни - можем да създадем приложение само за дебъгване на базата данни, без да добавяме допълнителни функционалности.
    
- **Преносимост**: Приложението може лесно да бъде пренесено към различни среди. Ако променим базата данни или някаква друга технология, единственото, което трябва да променим, е съответният слой (Data Layer), докато останалите слоеве остават непроменени.
    
- **Отделяне на отговорностите**: Всеки слой има ясно дефинирана роля и отговорности, което прави кода по-разбираем, по-лесен за поддръжка и разширяване.

Тази архитектура е особено полезна при необходимост от дебъгване на базата данни или други операции, които изискват изпълнение извън Web слоя. Например, създаването на отделно конзолно приложение, което да работи като дебъг инструмент, може да бъде много удобно за тестове и проверка на правилната работа на базата данни или на функционалността на сървисите, без да се налага да работим с цялото приложение.
## Identity
Data слоят съдържа начална миграция, която включва всички таблици от Identity системата на ASP.NET. 
ASP.NET предоставя много функционалности наготово, включително тази система за удостоверяване и управление на потребители.

Identity системата позволява на потребителите да създават акаунти, да се вписват, да възстановяват забравени пароли и да получават имейли за потвърждение или възстановяване на достъп. Тази система функционира като вграден framework във framework-а.

Когато посочим, че искаме да ползваме Identity, ASP.NET автоматично генерира необходимите таблици. Те включват:

- Потребители
- Роли на потребителите
- История на влизанията
- Асоциация между потребители и техните роли
- Таблици за токъни и други свързани данни

Този подход улеснява значително внедряването на система за удостоверяване в приложенията.
### `ApplicationUser` Model
```csharp
public class ApplicationUser : IdentityUser<Guid>
{
    public ApplicationUser()
    {
        Id = Guid.NewGuid();
    }
}
```

Този модел разширява стандартния клас `IdentityUser` на Entity Framework, което позволява промяна на типа на **Primary Key** му, който по подразбиране е от тип **string**. Използването на **GUID** за основен ключ е било необходимо, защото по-старите версии на EF Core не са поддържали **GUID** като тип за Primary Key. В миналото е било практика да се използва **GUID**, като се извиква методът `ToString()`. Въпреки това, с по-новите версии на EF Core вече е възможно да се използва директно **GUID**, което осигурява по-голяма сигурност и уникалност на идентификаторите.
## DbContext Constructor
```csharp
        public CinemaDbContext(DbContextOptions<CinemaDbContext> options)
            : base(options)
        {
        }
```

Този конструктор се използва от уеб приложението чрез dependency injection, което автоматично подава необходимите опции за конфигурация на контекста.
## Comment Attributes
Коментарите, които добавяме в ентити моделите чрез атрибути, представляват специални коментари, които Entity Framework третира и включва в базата данни като коментари към съответните колони или таблици. Това дава възможност на DB инженерите да разбират защо даден елемент е създаден по този начин в контекста на Code First модела, което помага за по-доброто поддържане и разширяване на базата данни.
## Entity Level Filters

```csharp
entity.HasQueryFilter(e => e.IsDeleted == false)
```

Можем да добавяме **query filters** на глобално ниво, така че всички заявки към дадено ентити автоматично да взимат само тези записи, които отговарят на условието. При използване на **soft delete**, обикновено искаме да извличаме само записите, за които `IsDeleted` е `false`. За да постигнем това, в бизнес логиката, където правим заявки, трябва да извършваме филтрация. Това може да се осигури глобално, на ниво запитване, като добавим филтър към всички заявки за съответното ентити/таблица в метода **`OnModelCreating`** на контекста на базата данни.
# Misc
# ChatGPT
# Bookmarks