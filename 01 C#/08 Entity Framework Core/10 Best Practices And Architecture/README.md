# General
## Project Structure
SOLID принципите са изключително важни, тъй като осигуряват стабилна основа за разработката на софтуер. Спазвайки ги, можем да създаваме приложения, които растат и се променят, без това да засяга тяхната стабилност и функционалност.

Освен SOLID принципите, съществуват още два изключително важни принципа - DRY (Don't Repeat Yourself) и KISS (Keep It Simple, Stupid). Те трябва да бъдат водещи при изграждането на структурата на приложението.

Принципът DRY е валиден както за кода, така и за архитектурата. Стремим се да създадем решение, при което да избегнем ненужно повтаряне на елементи.

Още по-важен е принципът KISS, който трябва да бъде основен приоритет във всичко, което правим. Въпреки че всички принципи са значими, понякога тяхното прилагане е трудно или невъзможно. KISS обаче е фундаментален и не бива да усложняваме решенията повече от необходимото.

Приложенията притежават няколко изключително важни характеристики:

**Scalability** – Целта ни е не само да излезем на пазара, но и да се задържим там. Ако продуктът ни се окаже успешен и привлече голям брой потребители, системата трябва да е способна да поеме този ръст, без да се срине.

**Maintainability** – Необходимо е да можем ефективно да поддържаме разработеното приложение, като реагираме своевременно на проблеми и реализираме нови идеи за развитие. Архитектурата трябва да е изградена така, че да позволява лесно разширяване и поддръжка, както и достатъчна прозрачност, за да можем бързо да разберем какво се случва при възникване на проблем.

**Manageability** – Системата трябва да бъде лесна за управление, така че да можем бързо и ефективно да реагираме на предизвикателства.

**Testability** – Приложението трябва да позволява лесно и ефективно тестване на неговата функционалност.
## Project Organization

Структурата на проекта зависи от целите, които искаме да постигнем, избраните технологии и архитектурния подход, който сме възприели.

Кодът на приложението може да бъде разделен на следните секции:

**Data Layer** - Този слой съдържа `DbContext`, който представлява базата данни в обектно-ориентирания модел. Основната му роля е да управлява достъпа до данните и тяхната персистентност.

**Domain Models** - Този слой трябва да съдържа ентити класовете. Съществува мнение, че тъй като ентити класовете са част от контекста и носят конкретни характеристики на слоя за данни (като дали дадено поле е nullable, какъв е неговият тип и т.н.), те следва да бъдат част от **Data Layer**.

В този контекст, под **domain model** трябва да се разбира **бизнес-ориентиран модел**, който често се различава от структурата на базата данни. DTO (Data Transfer Objects) обикновено се включват в слоя с домейн моделите, тъй като представляват форматирани обекти, подходящи за трансфер на данни в приложението.

**Client** - Клиентът оперира с данните и може да бъде реализиран по различни начини. Клиенти са всички компоненти, които използват бизнес логиката и взаимодействат с крайния потребител. Част от тях може да бъдат:

- Уеб страница
- Мобилно приложение
- Езиков модел
- Viber бот
- Хардуерно устройство

**Business Logic** - Без значение по какъв канал се осъществява взаимодействието, бизнес логиката остава една и съща и трябва да бъде **споделена** между различните клиенти.

Има различни подходи за споделяне на бизнес логиката:

1. **Отделен слой за бизнес логика** - В този случай логиката се отделя в самостоятелен слой, до който всички клиенти имат достъп. Това улеснява поддръжката и осигурява спазването на принципа **DRY** (Don't Repeat Yourself).
    
2. **Разпределена логика** - В някои случаи логиката може да бъде разпределена в множество независими компоненти. Според градска легенда, например, **Netflix** няма единен слой за бизнес логика, а вместо това работи с над **5000 отделни модула**, които обслужват специфични части от функционалността.

Дали ще изберем да обединим бизнес логиката в един централен слой към който да се обръщат всички клиенти или да я разпределим на множество парченца и всички клиенти ще се обръщат към парченцето което им трябва в момента, зависи от мащаба, изискванията и архитектурните решения на проекта. Важно е обаче и в двата случая да се придържаме към принципа **DRY**, за да избегнем излишно дублиране на логика и да улесним поддръжката.

Една от ползите при разделянето на кода е, че значително улеснява намирането на файлове по време на поддръжка.

Друга съществена полза е, че ако структурата е изградена правилно, няма да се налага да компилираме цялата кодова база при промяна (включително DLL файловете).

За да избегнем необходимостта от повторно компилиране на всички проекти при всяка промяна, е важно да няма **директни зависимости** между тях. Вместо това, комуникацията трябва да се осъществява по **индиректен начин**, например чрез интерфейси, събития или съобщения, а не чрез директни референции. Този подход подобрява модулността и улеснява поддръжката на системата, но изисква повече усилия при проектиране и имплементация.
## Usage Optimization
### Expression Trees and Materialization
LINQ заявките са **дървета на изрази** (expression trees) и сами по себе си не заемат ресурси, нито натоварват приложението. Важно е обаче да знаем, че те **не могат да бъдат ползвани като данни**, докато не се материализират.

Има няколко случая, в които материализацията се случва, и ние трябва да сме наясно **кога** и **дали** я правим на правилното място. Няма универсално решение за това — много зависи от фактори като:

- конкретния доставчик на базата данни (database provider)
- конкретните данни
- връзките между тях

Материализацията настъпва в два основни случая:

1. **Когато достъпим данните** — например чрез `foreach`.
2. **Когато извикаме метод, който материализира заявката, включително агрегиращи функции** — например `.ToList()`, `.ToArray()`, `.First()`, `.Count()`, `.Average()` и т.н.

Типът на едно **дърво на изразите** е `IQueryable<T>`. Ако се опитаме да го преобразуваме в друг тип (независимо дали **explicit** или **implicit**), заявката се материализира.

Пример:

- **Explicit материализиране** — `.ToList()`, `.ToArray()`
- **Implicit материализиране** — `foreach`

Когато въведем `IQueryable` в `foreach`, това води до заявка към неговия enumerator. Понеже самото **дърво на изразите** няма собствен enumerator, а само имплементация на `IEnumerable`, компилаторът автоматично го преобразува в `IEnumerable` и материализира заявката.

Този процес е важен, защото ако не сме внимателни, може да материализираме заявката твърде рано или на неподходящо място, което може да влоши производителността на приложението.

Материализирането всъщност е изпълнение на заявка върху базата и попълване на данните в паметта. Това включва преминаване през Object-Relational Mapper (ORM), който изтегляйки релационните данни, ги превръща в обектни и ни ги предоставя в паметта на машината.

Идеята е, че взаимодействието с клиента е процес и докато клиентът не вземе някакво решение, не е хубаво да се изтеглят данните.

Например:

- Ако цъкнем на даден продукт на даден сайт и сайтът веднага върне всички продукти, това може да доведе до излишно зареждане на информация.
- Ако след това добавим допълнителен филтър (например по марка или по ценови диапазон), сайтът ще изпълни нова заявка и ще върне по-малко продукти.

Проблемът е, че в случая са направени излишни заявки, които хабят повече RAM, повече процесор и мрежови ресурси.

По-добрият вариант е заявката да се изгради постепенно и вместо да се изпълнява при всяка промяна на филтъра, да се изпълни накрая, след като всички филтри са приложени.

Така вместо да извлечем няколко пъти хиляди продукти, може да спестим заявката до само няколко продукта, което е много по-оптимално.

Обикновено нашата цел е да материализираме колекцията в последния възможен момент, когато знаем всичко необходимо, за да я изведем.
### Express Profiler
Може да ползваме **Express Profiler**, за да следим кога се изпълняват заявките, но това е подходящо само докато се учим и не е приложимо в работна среда. Чрез него можем да видим точния момент на материализиране на заявката, когато сме в режим на дебъг.
### Select
Добре е винаги да правим **проекция**, а не да извличаме целия обект. Обикновено ни трябва или само част от даден **entity model**, или комбинация от части на няколко модела. Много рядко бизнес необходимостта съвпада едно към едно със структурата на таблицата.
### Find
Препоръчително е да ползваме **Find**, защото е по-бърз — той първо проверява за кеширани данни, докато **Where** винаги ще направи заявка към базата.

Ако искаме максимално бързодействие, е добре временно да изключим **`AutoDetectChangesEnabled`**, като след това го включим отново:

```csharp
try
{
    context.ChangeTracker.AutoDetectChangesEnabled = false;
    var entity = context.DbSetCollection.Find(entityId);
    // ...
}
finally
{
    context.ChangeTracker.AutoDetectChangesEnabled = true;
}
```
### `DetectChanges`
Когато добавяме, променяме или премахваме нещо, EF задължително извиква `DetectChanges()`, за да разбере за направените промени. Проблемът е, че това е бавен процес и ако се извиква за всеки елемент, става в пъти по-бавно.

Ако обаче работи с група от елементи, е значително по-бързо. Затова е препоръчително, ако имаме `foreach`, в който добавяме елементи към таблица, първо да ги съберем в лист и след това да ги добавим наведнъж чрез `.AddRange()`. Същото важи и при премахване с `.RemoveRange()`.

Така `DetectChanges()` ще се изпълни върху цялата група, а не върху всеки елемент поотделно, което ще подобри значително производителността.

Ако просто искаме да покажем информация без да я променяме — което е често срещан сценарий — не е нужно да извличаме целия обект.

Когато четем данни, е грешно да вземаме целия обект само с идеята, че може да се наложи да го редактираме по-късно. След като го върнем към браузъра, контекстът изчезва и няма как да се ползва отново. Затова, при първоначалното прочитане, е по-добре да се ползва `.AsNoTracking()`.

Ако по-късно се наложи да правим промени, тогава вече трябва да работим с обект, който е проследяван от контекста.

```csharp
context.DbSetCollection
    .AsNoTracking()
    .Where(x => x.Property == value)
    .ToList();
```

>[!IMPORTANT]
>Ползването на `.AsNoTracking()` спира кеширането, което ще се отрази на `.Find()`. При тази конфигурация `.Find()` винаги ще изпраща заявка към базата.
## Loading Methods
Размерът на полезния товар (payload) и броят на заявките към базата са обратно пропорционални.

**Lazy** – по-малко данни, повече заявки

**Eager** – повече данни, по-малко заявки

Няма универсално най-добро решение – производителността зависи от конкретния сценарий на ползване.
# Misc
# ChatGPT
# Bookmarks
Completion: 21.03.2025