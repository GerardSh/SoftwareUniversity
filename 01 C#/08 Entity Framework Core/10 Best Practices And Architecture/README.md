# General
## Project Structure
SOLID принципите са изключително важни, тъй като осигуряват стабилна основа за разработката на софтуер. Спазвайки ги, можем да създаваме приложения, които растат и се променят, без това да засяга тяхната стабилност и функционалност.

Освен SOLID принципите, съществуват още два изключително важни принципа - DRY (Don't Repeat Yourself) и KISS (Keep It Simple, Stupid). Те трябва да бъдат водещи при изграждането на структурата на приложението.

Принципът DRY е валиден както за кода, така и за архитектурата. Стремим се да създадем решение, при което да избегнем ненужно повтаряне на елементи.

Още по-важен е принципът KISS, който трябва да бъде основен приоритет във всичко, което правим. Въпреки че всички принципи са значими, понякога тяхното прилагане е трудно или невъзможно. KISS обаче е фундаментален и не бива да усложняваме решенията повече от необходимото.

Приложенията притежават няколко изключително важни характеристики:

**Scalability** – Целта ни е не само да излезем на пазара, но и да се задържим там. Ако продуктът ни се окаже успешен и привлече голям брой потребители, системата трябва да е способна да поеме този ръст, без да се срине.

**Maintainability** – Необходимо е да можем ефективно да поддържаме разработеното приложение, като реагираме своевременно на проблеми и реализираме нови идеи за развитие. Архитектурата трябва да е изградена така, че да позволява лесно разширяване и поддръжка, както и достатъчна прозрачност, за да можем бързо да разберем какво се случва при възникване на проблем.

**Manageability** – Системата трябва да бъде лесна за управление, така че да можем бързо и ефективно да реагираме на предизвикателства.

**Testability** – Приложението трябва да позволява лесно и ефективно тестване на неговата функционалност.
## Project Organization

Структурата на проекта зависи от целите, които искаме да постигнем, избраните технологии и архитектурния подход, който сме възприели.

Кодът на приложението може да бъде разделен на следните секции:

**Data Layer** - Този слой съдържа `DbContext`, който представлява базата данни в обектно-ориентирания модел. Основната му роля е да управлява достъпа до данните и тяхната персистентност.

**Domain Models** - Този слой трябва да съдържа ентити класовете. Съществува мнение, че тъй като ентити класовете са част от контекста и носят конкретни характеристики на слоя за данни (като дали дадено поле е nullable, какъв е неговият тип и т.н.), те следва да бъдат част от **Data Layer**.

В този контекст, под **domain model** трябва да се разбира **бизнес-ориентиран модел**, който често се различава от структурата на базата данни. DTO (Data Transfer Objects) обикновено се включват в слоя с домейн моделите, тъй като представляват форматирани обекти, подходящи за трансфер на данни в приложението.

**Client** - Клиентът оперира с данните и може да бъде реализиран по различни начини. Клиенти са всички компоненти, които използват бизнес логиката и взаимодействат с крайния потребител. Част от тях може да бъдат:

- Уеб страница
- Мобилно приложение
- Езиков модел
- Viber бот
- Хардуерно устройство

**Business Logic** - Без значение по какъв канал се осъществява взаимодействието, бизнес логиката остава една и съща и трябва да бъде **споделена** между различните клиенти.

Има различни подходи за споделяне на бизнес логиката:

1. **Отделен слой за бизнес логика** - В този случай логиката се отделя в самостоятелен слой, до който всички клиенти имат достъп. Това улеснява поддръжката и осигурява спазването на принципа **DRY** (Don't Repeat Yourself).
    
2. **Разпределена логика** - В някои случаи логиката може да бъде разпределена в множество независими компоненти. Според градска легенда, например, **Netflix** няма единен слой за бизнес логика, а вместо това работи с над **5000 отделни модула**, които обслужват специфични части от функционалността.

Дали ще изберем да обединим бизнес логиката в един централен слой към който да се обръщат всички клиенти или да я разпределим на множество парченца и всички клиенти ще се обръщат към парченцето което им трябва в момента, зависи от мащаба, изискванията и архитектурните решения на проекта. Важно е обаче и в двата случая да се придържаме към принципа **DRY**, за да избегнем излишно дублиране на логика и да улесним поддръжката.

Една от ползите при разделянето на кода е, че значително улеснява намирането на файлове по време на поддръжка.

Друга съществена полза е, че ако структурата е изградена правилно, няма да се налага да компилираме цялата кодова база при промяна (включително DLL файловете).

За да избегнем необходимостта от повторно компилиране на всички проекти при всяка промяна, е важно да няма **директни зависимости** между тях. Вместо това, комуникацията трябва да се осъществява по **индиректен начин**, например чрез интерфейси, събития или съобщения, а не чрез директни референции. Този подход подобрява модулността и улеснява поддръжката на системата, но изисква повече усилия при проектиране и имплементация.
## Usage Optimization

# Misc
# ChatGPT
# Bookmarks
Completion: 21.03.2025