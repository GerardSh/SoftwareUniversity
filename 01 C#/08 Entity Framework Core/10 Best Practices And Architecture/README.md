# General
## Project Structure
SOLID принципите са изключително важни, тъй като осигуряват стабилна основа за разработката на софтуер. Спазвайки ги, можем да създаваме приложения, които растат и се променят, без това да засяга тяхната стабилност и функционалност.

Освен SOLID принципите, съществуват още два изключително важни принципа - DRY (Don't Repeat Yourself) и KISS (Keep It Simple, Stupid). Те трябва да бъдат водещи при изграждането на структурата на приложението.

Принципът DRY е валиден както за кода, така и за архитектурата. Стремим се да създадем решение, при което да избегнем ненужно повтаряне на елементи.

Още по-важен е принципът KISS, който трябва да бъде основен приоритет във всичко, което правим. Въпреки че всички принципи са значими, понякога тяхното прилагане е трудно или невъзможно. KISS обаче е фундаментален и не бива да усложняваме решенията повече от необходимото.

Приложенията притежават няколко изключително важни характеристики:

**Scalability** – Целта ни е не само да излезем на пазара, но и да се задържим там. Ако продуктът ни се окаже успешен и привлече голям брой потребители, системата трябва да е способна да поеме този ръст, без да се срине.

**Maintainability** – Необходимо е да можем ефективно да поддържаме разработеното приложение, като реагираме своевременно на проблеми и реализираме нови идеи за развитие. Архитектурата трябва да е изградена така, че да позволява лесно разширяване и поддръжка, както и достатъчна прозрачност, за да можем бързо да разберем какво се случва при възникване на проблем.

**Manageability** – Системата трябва да бъде лесна за управление, така че да можем бързо и ефективно да реагираме на предизвикателства.

**Testability** – Приложението трябва да позволява лесно и ефективно тестване на неговата функционалност.
## Project Organization

Структурата на проекта зависи от целите, които искаме да постигнем, избраните технологии и архитектурния подход, който сме възприели.

Кодът на приложението може да бъде разделен на следните секции:

**Data Layer** - Този слой съдържа `DbContext`, който представлява базата данни в обектно-ориентирания модел. Основната му роля е да управлява достъпа до данните и тяхната персистентност.

**Domain Models** - Този слой трябва да съдържа ентити класовете. Съществува мнение, че тъй като ентити класовете са част от контекста и носят конкретни характеристики на слоя за данни (като дали дадено поле е nullable, какъв е неговият тип и т.н.), те следва да бъдат част от **Data Layer**.

В този контекст, под **domain model** трябва да се разбира **бизнес-ориентиран модел**, който често се различава от структурата на базата данни. DTO (Data Transfer Objects) обикновено се включват в слоя с домейн моделите, тъй като представляват форматирани обекти, подходящи за трансфер на данни в приложението.

**Client** - Клиентът оперира с данните и може да бъде реализиран по различни начини. Клиенти са всички компоненти, които използват бизнес логиката и взаимодействат с крайния потребител. Част от тях може да бъдат:

- Уеб страница
- Мобилно приложение
- Езиков модел
- Viber бот
- Хардуерно устройство

**Business Logic** - Без значение по какъв канал се осъществява взаимодействието, бизнес логиката остава една и съща и трябва да бъде **споделена** между различните клиенти.

Има различни подходи за споделяне на бизнес логиката:

1. **Отделен слой за бизнес логика** - В този случай логиката се отделя в самостоятелен слой, до който всички клиенти имат достъп. Това улеснява поддръжката и осигурява спазването на принципа **DRY** (Don't Repeat Yourself).
    
2. **Разпределена логика** - В някои случаи логиката може да бъде разпределена в множество независими компоненти. Според градска легенда, например, **Netflix** няма единен слой за бизнес логика, а вместо това работи с над **5000 отделни модула**, които обслужват специфични части от функционалността.

Дали ще изберем да обединим бизнес логиката в един централен слой към който да се обръщат всички клиенти или да я разпределим на множество парченца и всички клиенти ще се обръщат към парченцето което им трябва в момента, зависи от мащаба, изискванията и архитектурните решения на проекта. Важно е обаче и в двата случая да се придържаме към принципа **DRY**, за да избегнем излишно дублиране на логика и да улесним поддръжката.

Една от ползите при разделянето на кода е, че значително улеснява намирането на файлове по време на поддръжка.

Друга съществена полза е, че ако структурата е изградена правилно, няма да се налага да компилираме цялата кодова база при промяна (включително DLL файловете).

За да избегнем необходимостта от повторно компилиране на всички проекти при всяка промяна, е важно да няма **директни зависимости** между тях. Вместо това, комуникацията трябва да се осъществява по **индиректен начин**, например чрез интерфейси, събития или съобщения, а не чрез директни референции. Този подход подобрява модулността и улеснява поддръжката на системата, но изисква повече усилия при проектиране и имплементация.
## Usage Optimization
### Expression Trees and Materialization
LINQ заявките са **дървета на изрази** (expression trees) и сами по себе си не заемат ресурси, нито натоварват приложението. Важно е обаче да знаем, че те **не могат да бъдат ползвани като данни**, докато не се материализират.

Има няколко случая, в които материализацията се случва, и ние трябва да сме наясно **кога** и **дали** я правим на правилното място. Няма универсално решение за това - много зависи от фактори като:

- конкретния доставчик на базата данни (database provider)
- конкретните данни
- връзките между тях

Материализацията настъпва в два основни случая:

1. **Когато достъпим данните** - например чрез `foreach`.
2. **Когато извикаме метод, който материализира заявката, включително агрегиращи функции** - например `.ToList()`, `.ToArray()`, `.First()`, `.Count()`, `.Average()` и т.н.

Типът на едно **дърво на изразите** е `IQueryable<T>`. Ако се опитаме да го преобразуваме в друг тип (независимо дали **explicit** или **implicit**), заявката се материализира.

Пример:

- **Explicit материализиране** - `.ToList()`, `.ToArray()`
- **Implicit материализиране** - `foreach`

Когато въведем `IQueryable` в `foreach`, това води до заявка към неговия enumerator. Понеже самото **дърво на изразите** няма собствен enumerator, а само имплементация на `IEnumerable`, компилаторът автоматично го преобразува в `IEnumerable` и материализира заявката.

Този процес е важен, защото ако не сме внимателни, може да материализираме заявката твърде рано или на неподходящо място, което може да влоши производителността на приложението.

Материализирането всъщност е изпълнение на заявка върху базата и попълване на данните в паметта. Това включва преминаване през Object-Relational Mapper (ORM), който изтегляйки релационните данни, ги превръща в обектни и ни ги предоставя в паметта на машината.

Идеята е, че взаимодействието с клиента е процес и докато клиентът не вземе някакво решение, не е хубаво да се изтеглят данните.

Например:

- Ако цъкнем на даден продукт на даден сайт и сайтът веднага върне всички продукти, това може да доведе до излишно зареждане на информация.
- Ако след това добавим допълнителен филтър (например по марка или по ценови диапазон), сайтът ще изпълни нова заявка и ще върне по-малко продукти.

Проблемът е, че в случая са направени излишни заявки, които хабят повече RAM, повече процесор и мрежови ресурси.

По-добрият вариант е заявката да се изгради постепенно и вместо да се изпълнява при всяка промяна на филтъра, да се изпълни накрая, след като всички филтри са приложени.

Така вместо да извлечем няколко пъти хиляди продукти, може да спестим заявката до само няколко продукта, което е много по-оптимално.

Обикновено нашата цел е да материализираме колекцията в последния възможен момент, когато знаем всичко необходимо, за да я изведем.
### Express Profiler
Може да ползваме **Express Profiler**, за да следим кога се изпълняват заявките, но това е подходящо само докато се учим и не е приложимо в работна среда. Чрез него можем да видим точния момент на материализиране на заявката, когато сме в режим на дебъг.
### Select
Добре е винаги да правим **проекция**, а не да извличаме целия обект. Обикновено ни трябва или само част от даден **entity model**, или комбинация от части на няколко модела. Много рядко бизнес необходимостта съвпада едно към едно със структурата на таблицата.
### Find
Препоръчително е да ползваме **Find**, защото е по-бърз - той първо проверява за кеширани данни, докато **Where** винаги ще направи заявка към базата.

Ако искаме максимално бързодействие, е добре временно да изключим **`AutoDetectChangesEnabled`**, като след това го включим отново:

```csharp
try
{
    context.ChangeTracker.AutoDetectChangesEnabled = false;
    var entity = context.DbSetCollection.Find(entityId);
    // ...
}
finally
{
    context.ChangeTracker.AutoDetectChangesEnabled = true;
}
```
### `DetectChanges`
Когато добавяме, променяме или премахваме нещо, EF задължително извиква `DetectChanges()`, за да разбере за направените промени. Проблемът е, че това е бавен процес и ако се извиква за всеки елемент, става в пъти по-бавно.

Ако обаче работи с група от елементи, е значително по-бързо. Затова е препоръчително, ако имаме `foreach`, в който добавяме елементи към таблица, първо да ги съберем в лист и след това да ги добавим наведнъж чрез `.AddRange()`. Същото важи и при премахване с `.RemoveRange()`.

Така `DetectChanges()` ще се изпълни върху цялата група, а не върху всеки елемент поотделно, което ще подобри значително производителността.

Ако просто искаме да покажем информация без да я променяме - което е често срещан сценарий - не е нужно да извличаме целия обект.

Когато четем данни, е грешно да вземаме целия обект само с идеята, че може да се наложи да го редактираме по-късно. След като го върнем към браузъра, контекстът изчезва и няма как да се ползва отново. Затова, при първоначалното прочитане, е по-добре да се ползва `.AsNoTracking()`.

Ако по-късно се наложи да правим промени, тогава вече трябва да работим с обект, който е проследяван от контекста.

```csharp
context.DbSetCollection
    .AsNoTracking()
    .Where(x => x.Property == value)
    .ToList();
```

>[!IMPORTANT]
>Ползването на `.AsNoTracking()` спира кеширането, което ще се отрази на `.Find()`. При тази конфигурация `.Find()` винаги ще изпраща заявка към базата.
## Loading Methods
Размерът на полезния товар (payload) и броят на заявките към базата са обратно пропорционални.

**Lazy** – по-малко данни, повече заявки

**Eager** – повече данни, по-малко заявки

Няма универсално най-добро решение – производителността зависи от конкретния сценарий на ползване.

**Уточняващи въпроси:**

Трябва ли да достъпваме много навигационни свойства от изтеглените ентитети? 
Не – Lazy за големи данни, Eager за малки.
Да – Eager зареждане за до три ентитета, Lazy за повече.

Знаем ли точно какви данни ще са необходими по време на изпълнение?
Не – Lazy  
Да – Eager първоначално, освен ако не зареждаме много данни, тогава Lazy.

Изпълнява ли се нашият код далеч от базата данни? (повишена латентност на мрежата)
Не – Lazy ще опрости кода ни; не трябва да приемаме близостта на базата данни за даденост.
Да – В зависимост от сценария, Eager ще изисква по-малко кръгови пътувания. 

Винаги трябва да тестваме производителността на приложението в цялост, оптимизираме само ако резултатите не са задоволителни.
## Design Patterns
Идеята им е да предоставят стандартно решение на често срещан проблем. Те ни дават възможност да използваме утвърдени решения, но в повечето случаи има различни вариации, които зависят от конкретната ситуация.

- **Singleton (Единичен обект)** – Гарантира, че класът има само една инстанция и предоставя глобална точка на достъп до нея.
- **Service Locator (Локатор на услуги)** – Прави услуга достъпна глобално и премахва връзката между извикващия клас и зависимия обект.
- **Dependency Injection (Инжектиране на зависимости)** – Не е необходимо клиентският код да бъде променян само защото обектът, от който зависи, трябва да бъде променен.
- **Command (Команда)** – Инкапсулира заявка като обект, което позволява забавено изпълнение, отменяне и повторно изпълнение.
- **Repository (Хранилище)** – Разделя логиката за достъп до данни и я мапира към ентититата в бизнес логиката.
- **Unit of Work (Единица работа)** – Използва се за групиране на една или повече операции в една транзакция или "единица работа", така че всички операции да преминат или неуспешно да приключат като едно цяло.
### Singleton
```csharp
public class Authenticator
{
    private static Authenticator instance;

    // Private constructor to prevent external instantiation
    private Authenticator() { }

    // Public static property to access the single instance
    public static Authenticator Instance
    {
        get
        {
            if (instance == null)
                instance = new Authenticator();
            return instance;
        }
    }
}
```

Вече стандартният начин за реализиране на **Singleton** в C# е чрез `Lazy<T>`, което осигурява по-добра производителност и гарантира безопасност при работа с няколко нишки (thread-safe).

По-съвременна имплементация на Singleton с `Lazy<T>`

```csharp
public class Authenticator
{
    private static readonly Lazy<Authenticator> _instance =
        new Lazy<Authenticator>(() => new Authenticator());

    // Private constructor to prevent external instantiation
    private Authenticator() { }

    // Public static property to access the single instance
    public static Authenticator Instance => _instance.Value;
}
```

Тази версия не изисква допълнителна проверка за `null` и е по-надеждна при многопоточност.

Използването на `Lazy<T>` е предпочитаният подход в C#, защото предоставя отложено създаване на инстанцията и е по-сигурен в многопоточна среда.

Не е нужно да се имплементира отделен клас, тъй като в C# вече имаме вграден такъв. 
### Service Locator
Инжектирането на зависимости може да се извърши по няколко начина:

- **Constructor Injection** – Подаваме зависимостите чрез конструктора на класа.
- **Method Injection** – Предаваме зависимостите директно на метод при неговото извикване.
- **Property Injection** – Присвояваме зависимостите чрез публично свойство на класа.

Въпреки това, ако се нуждаем от дадена зависимост в конкретна част от метода, тези подходи може да не са най-удобните. В такъв случай **Service Locator** предлага решение, като открива и връща желаната инстанция в момента на нуждата.

Този подход може да бъде полезен в сценарии, когато:

- Искаме да достъпим зависимост, която не сме получили чрез конструктора или методите.
- Имаме сложна логика за създаване на обекти, която е централизирана в Service Locator-а.

Примерна имплементация на Service Locator:

```csharp
public interface IService { void Execute(); }

public class SampleService : IService
{
    public void Execute() => Console.WriteLine("Service Executed");
}

public class ServiceLocator
{
    private static readonly Dictionary<Type, object> services = new();

    public static void Register<T>(T service) where T : class
    {
        services[typeof(T)] = service;
    }

    public static T GetService<T>() where T : class
    {
        services.TryGetValue(typeof(T), out var service);
        return service as T ?? throw new InvalidOperationException("Service not found");
    }
}

// Usage example
class Program
{
    static void Main(string[] args)
    {
        ServiceLocator.Register<IService>(new SampleService());

// Invoke the service in an arbitrary part of the code
        var service = ServiceLocator.GetService<IService>();
        service.Execute();
    }
}
```

**Предимства на Service Locator**

Позволява динамично извикване на зависимости, без да се налага да ги предаваме чрез конструктора.  
Улеснява достъпа до услуги в ситуации, когато конструкционното инжектиране не е удобно.

**Недостатъци на Service Locator**

Затруднява откриването на зависимости по време на компилация.  
Води до по-силно обвързване между компонентите, което намалява прозрачността на кода.

Препоръчително е **Service Locator** да се използва с повишено внимание и само в случаите, когато другите подходи за инжектиране не са подходящи.
### Command
Даваме определена команда, която се обработва от парсер. Парсерът анализира командата и извлича от нея необходимите действия, които трябва да бъдат изпълнени. Командата сама си осигурява нужните зависимости, изпълнява се и предоставя възможност за различни сценарии.

Например, можем да приложим **отложено изпълнение** (delayed execution) - стартираме команда, която се изпълнява по-късно, когато натоварването на сървъра намалее или в определен час, като например 3:42 сутринта, ако така сме решили.

Освен това можем да създадем механизъм за контрол - след изпълнението на дадена команда да проверим дали резултатът е удовлетворителен. Ако не е, командата може автоматично да върне извършените промени.

Пример: добавяме данни в базата, след което правим справка дали тези данни са коректно добавени. Ако нещо не е както трябва, командата връща направените промени, като премахва добавените данни.

Този подход предоставя допълнителна гъвкавост и контрол при изпълнението на команди.
# Misc
# ChatGPT
# Bookmarks
Completion: 21.03.2025