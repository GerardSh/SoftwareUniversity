# General
## Authentication vs Authorization
**Удостоверяване (Authentication)**

Процесът на проверка на самоличността на потребител или компютър.

Предпоставка за оторизация, няма как да имаме оторизация без автентикация.

Въпроси: Кой си ти? Как го доказваш?

Удостоверяващи данни могат да бъдат парола, смарт карта, външен токен и др.

**Оторизация (Authorization)**

Процесът на определяне какво е позволено на потребителя да прави на компютър или мрежа.

Въпроси: Какво имаш право да правиш? Можеш ли да видиш тази страница?

Не можем да оторизираме потребител преди да го удостоверим.
## ASP.NET Core Identity
Това е система за удостоверяване и оторизация за ASP.NET Core. Можем да удостоверяваме и оторизираме потребителите, тоест да им разрешаваме да правят определени неща в нашата система. Най-лесният вариант е чрез роли, а по-сложният — чрез политики.

Поддържа ASP.NET Core MVC, Pages, Web API (JWT), SignalR.

Управлява потребителите, техните профили, вход/изход от системата, роли и други.

Управлява съгласието за бисквитки и съответствието с GDPR.

Поддържа външни доставчици за вход. Можем да използваме Facebook, Google, Twitter и други.

Системата поддържа работа с бази данни, Azure, Active Directory, Windows потребители и други.

Обикновено съхраняваме данните за ASP.NET Core Identity в релационна база данни.

Използваме Entity Framework Core за съхранение на данните.

Имаме известен контрол върху вътрешната структура на базата данни.
### Internal Database Schema
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250502181502.png)

**`AspNetUsers`**

Основната таблица е `AspNetUsers`, в която се съхраняват потребителите. Идентификаторът на таблицата е задължителен, а всичко останало може да бъде изтрито.

Имената се съхраняват в нормализиран вид, т.е. всички букви са или големи, или малки, за да се подобри бързината на търсенето.

В ASP.NET има готов механизъм за потвърждаване на имейли.

`ConcurrencyStamp` това е уникален идентификатор (обикновено GUID), който се използва за обработка на конкуренцията. Той помага да се избегнат проблеми при едновременни промени в базата данни, като гарантира, че само последната актуализация на данни ще бъде записана, ако има конфликти.

`SecurityStamp` това е стойност, която се използва за маркиране на състоянието на сигурността на потребителя. Той обикновено се променя при всяка значителна промяна в потребителския акаунт, като например при промяна на паролата или обновяване на информацията за потребителя. Това помага да се предотвратят сесии с изтекла автентикация, като например при отказ от сесия или за сигурност в процеса на удостоверяване.

`LockoutEnd`, `LockoutEnabled` и `AccessFailedCount` се използват за заключване на акаунта след прекалено много неуспешни опити за вход. Това осигурява защита срещу brute force атаки.

Ако искаме да свържем наша таблица с потребителската таблица `AspNetUsers`, трябва да добавим колона `UserId`, която да съхранява идентификатора на потребителя, и навигационно свойство от тип **`ApplicationUser`** (или клас, който разширява `IdentityUser`, ако сме създали такъв), за да реализираме връзката между двете таблици. Няма нужда да се създава навигационна колекция в `AspNetUsers`, тъй като по подразбиране таблицата за потребители (`AspNetUsers`) не съдържа колекции от свързани обекти.

**`AspNetRoles`**  
Съдържа ролите, които могат да бъдат присвоени на нашите потребители.

Всеки потребител може да има множество роли, като връзката между потребители и роли е от тип много към много.

**`AspNetRoleClaims`**  
Всяка роля може да съдържа клеймове. Това означава, че когато даден потребител получи определена роля (например „Администратор“), той автоматично получава и клеймовете, свързани с тази роля.

**`AspNetUserClaims`**  
Клеймове могат да бъдат задавани и директно на потребителя, без да е необходимо да минават през роля.

**`AspNetUserLogins`**  
Тази таблица е необходима за външните провайдъри. Когато потребител се впише чрез външен провайдър, системата използва тази таблица, за да направи съпоставяне по име и ключ на провайдъра.

Външен провайдър означава външна услуга, чрез която потребителите могат да се вписват (логват) в нашето приложение, вместо да използват локална регистрация с потребителско име и парола.

Примери за външни провайдъри са: Google, Facebook, Microsoft, Twitter, GitHub, Apple и тн.

Когато потребител избере да се впише чрез външен провайдър, приложението ни го пренасочва към съответния сайт (напр. Google), където той потвърждава самоличността си. След това външният провайдър ни връща потвърдена информация (напр. имейл), която използваме, за да създадем или заредим потребителски профил.

Това улеснява входа за потребителите и премахва нуждата да запомнят нова парола.

**`AspNetUserTokens`**  
Таблица за съхранение на токени. Въпреки това, по принцип не е препоръчително токените да се съхраняват в базата.
### System Setup
Добре е, когато създаваме ASP.NET проекта, да изберем `Authentication type` => `Individual Accounts`, което ще активира Identity, след което можем лесно да го персонализираме. Добавянето на Identity впоследствие, след като проектът вече е създаден е по-трудно.

Може да се направи и ръчно. Тогава трябва да инсталираме нужните NuGet пакети, да направим конфигурациите.

Необходимият NuGet пакет е: `Microsoft.AspNetCore.Identity.EntityFrameworkCore`.

Когато изберем Identity, out of the box получаваме папка `Data` с `ApplicationDbContext.cs` - файла отговарящ за нашата база данни. Наследява `IdentityDbContext`, където се намират таблиците на Identity и това е достатъчно за да може да достъпваме данните на нашите потребители. Създава се и папка `Migrations` където е миграцията, която създава таблиците
# Misc
# ChatGPT
# Bookmarks
[Introduction to Identity on ASP.NET Core | Microsoft Learn](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-9.0&tabs=visual-studio)

Completion: 03.05.2025