# General
## Authentication vs Authorization
**–£–¥–æ—Å—Ç–æ–≤–µ—Ä—è–≤–∞–Ω–µ (Authentication)**

–ü—Ä–æ—Ü–µ—Å—ä—Ç –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–∞–º–æ–ª–∏—á–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –∏–ª–∏ –∫–æ–º–ø—é—Ç—ä—Ä.

–ü—Ä–µ–¥–ø–æ—Å—Ç–∞–≤–∫–∞ –∑–∞ –æ—Ç–æ—Ä–∏–∑–∞—Ü–∏—è, –Ω—è–º–∞ –∫–∞–∫ –¥–∞ –∏–º–∞–º–µ –æ—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –±–µ–∑ –∞–≤—Ç–µ–Ω—Ç–∏–∫–∞—Ü–∏—è.

–í—ä–ø—Ä–æ—Å–∏: –ö–æ–π —Å–∏ —Ç–∏? –ö–∞–∫ –≥–æ –¥–æ–∫–∞–∑–≤–∞—à?

–£–¥–æ—Å—Ç–æ–≤–µ—Ä—è–≤–∞—â–∏ –¥–∞–Ω–Ω–∏ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –ø–∞—Ä–æ–ª–∞, —Å–º–∞—Ä—Ç –∫–∞—Ä—Ç–∞, –≤—ä–Ω—à–µ–Ω —Ç–æ–∫–µ–Ω –∏ –¥—Ä.

**–û—Ç–æ—Ä–∏–∑–∞—Ü–∏—è (Authorization)**

–ü—Ä–æ—Ü–µ—Å—ä—Ç –Ω–∞ –æ–ø—Ä–µ–¥–µ–ª—è–Ω–µ –∫–∞–∫–≤–æ –µ –ø–æ–∑–≤–æ–ª–µ–Ω–æ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è –¥–∞ –ø—Ä–∞–≤–∏ –Ω–∞ –∫–æ–º–ø—é—Ç—ä—Ä –∏–ª–∏ –º—Ä–µ–∂–∞.

–í—ä–ø—Ä–æ—Å–∏: –ö–∞–∫–≤–æ –∏–º–∞—à –ø—Ä–∞–≤–æ –¥–∞ –ø—Ä–∞–≤–∏—à? –ú–æ–∂–µ—à –ª–∏ –¥–∞ –≤–∏–¥–∏—à —Ç–∞–∑–∏ —Å—Ç—Ä–∞–Ω–∏—Ü–∞?

–ù–µ –º–æ–∂–µ–º –¥–∞ –æ—Ç–æ—Ä–∏–∑–∏—Ä–∞–º–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –ø—Ä–µ–¥–∏ –¥–∞ –≥–æ —É–¥–æ—Å—Ç–æ–≤–µ—Ä–∏–º.
## ASP.NET Core Identity
–¢–æ–≤–∞ –µ —Å–∏—Å—Ç–µ–º–∞ –∑–∞ —É–¥–æ—Å—Ç–æ–≤–µ—Ä—è–≤–∞–Ω–µ –∏ –æ—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∑–∞ ASP.NET Core. –ú–æ–∂–µ–º –¥–∞ —É–¥–æ—Å—Ç–æ–≤–µ—Ä—è–≤–∞–º–µ –∏ –æ—Ç–æ—Ä–∏–∑–∏—Ä–∞–º–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ, —Ç–æ–µ—Å—Ç –¥–∞ –∏–º —Ä–∞–∑—Ä–µ—à–∞–≤–∞–º–µ –¥–∞ –ø—Ä–∞–≤—è—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏ –Ω–µ—â–∞ –≤ –Ω–∞—à–∞—Ç–∞ —Å–∏—Å—Ç–µ–º–∞. –ù–∞–π-–ª–µ—Å–Ω–∏—è—Ç –≤–∞—Ä–∏–∞–Ω—Ç –µ —á—Ä–µ–∑ —Ä–æ–ª–∏, –∞ –ø–æ-—Å–ª–æ–∂–Ω–∏—è—Ç ‚Äî —á—Ä–µ–∑ –ø–æ–ª–∏—Ç–∏–∫–∏.

–ü–æ–¥–¥—ä—Ä–∂–∞ ASP.NET Core MVC, Pages, Web API (JWT), SignalR.

–£–ø—Ä–∞–≤–ª—è–≤–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ, —Ç–µ—Ö–Ω–∏—Ç–µ –ø—Ä–æ—Ñ–∏–ª–∏, –≤—Ö–æ–¥/–∏–∑—Ö–æ–¥ –æ—Ç —Å–∏—Å—Ç–µ–º–∞—Ç–∞, —Ä–æ–ª–∏ –∏ –¥—Ä—É–≥–∏.

–£–ø—Ä–∞–≤–ª—è–≤–∞ —Å—ä–≥–ª–∞—Å–∏–µ—Ç–æ –∑–∞ –±–∏—Å–∫–≤–∏—Ç–∫–∏ –∏ —Å—ä–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ—Ç–æ —Å GDPR.

–ü–æ–¥–¥—ä—Ä–∂–∞ –≤—ä–Ω—à–Ω–∏ –¥–æ—Å—Ç–∞–≤—á–∏—Ü–∏ –∑–∞ –≤—Ö–æ–¥. –ú–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ Facebook, Google, Twitter –∏ –¥—Ä—É–≥–∏.

–°–∏—Å—Ç–µ–º–∞—Ç–∞ –ø–æ–¥–¥—ä—Ä–∂–∞ —Ä–∞–±–æ—Ç–∞ —Å –±–∞–∑–∏ –¥–∞–Ω–Ω–∏, Azure, Active Directory, Windows –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏ –∏ –¥—Ä—É–≥–∏.

–û–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞–º–µ –¥–∞–Ω–Ω–∏—Ç–µ –∑–∞ ASP.NET Core Identity –≤ —Ä–µ–ª–∞—Ü–∏–æ–Ω–Ω–∞ –±–∞–∑–∞ –¥–∞–Ω–Ω–∏.

–ò–∑–ø–æ–ª–∑–≤–∞–º–µ Entity Framework Core –∑–∞ —Å—ä—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞ –¥–∞–Ω–Ω–∏—Ç–µ.

–ò–º–∞–º–µ –∏–∑–≤–µ—Å—Ç–µ–Ω –∫–æ–Ω—Ç—Ä–æ–ª –≤—ä—Ä—Ö—É –≤—ä—Ç—Ä–µ—à–Ω–∞—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –Ω–∞ –±–∞–∑–∞—Ç–∞ –¥–∞–Ω–Ω–∏.
### Internal Database Schema
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250502181502.png)

**`AspNetUsers`**

–û—Å–Ω–æ–≤–Ω–∞—Ç–∞ —Ç–∞–±–ª–∏—Ü–∞ –µ `AspNetUsers`, –≤ –∫–æ—è—Ç–æ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ. –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ä—Ç –Ω–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ –µ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–µ–Ω, –∞ –≤—Å–∏—á–∫–æ –æ—Å—Ç–∞–Ω–∞–ª–æ –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –∏–∑—Ç—Ä–∏—Ç–æ.

–ò–º–µ–Ω–∞—Ç–∞ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç –≤ –Ω–æ—Ä–º–∞–ª–∏–∑–∏—Ä–∞–Ω –≤–∏–¥, —Ç.–µ. –≤—Å–∏—á–∫–∏ –±—É–∫–≤–∏ —Å–∞ –∏–ª–∏ –≥–æ–ª–µ–º–∏, –∏–ª–∏ –º–∞–ª–∫–∏, –∑–∞ –¥–∞ —Å–µ –ø–æ–¥–æ–±—Ä–∏ –±—ä—Ä–∑–∏–Ω–∞—Ç–∞ –Ω–∞ —Ç—ä—Ä—Å–µ–Ω–µ—Ç–æ.

–í ASP.NET –∏–º–∞ –≥–æ—Ç–æ–≤ –º–µ—Ö–∞–Ω–∏–∑—ä–º –∑–∞ –ø–æ—Ç–≤—ä—Ä–∂–¥–∞–≤–∞–Ω–µ –Ω–∞ –∏–º–µ–π–ª–∏.

`ConcurrencyStamp` —Ç–æ–≤–∞ –µ —É–Ω–∏–∫–∞–ª–µ–Ω –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä (–æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ GUID), –∫–æ–π—Ç–æ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –∑–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ü–∏—è—Ç–∞. –¢–æ–π –ø–æ–º–∞–≥–∞ –¥–∞ —Å–µ –∏–∑–±–µ–≥–Ω–∞—Ç –ø—Ä–æ–±–ª–µ–º–∏ –ø—Ä–∏ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–∏ –ø—Ä–æ–º–µ–Ω–∏ –≤ –±–∞–∑–∞—Ç–∞ –¥–∞–Ω–Ω–∏, –∫–∞—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞, —á–µ —Å–∞–º–æ –ø–æ—Å–ª–µ–¥–Ω–∞—Ç–∞ –∞–∫—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –¥–∞–Ω–Ω–∏ —â–µ –±—ä–¥–µ –∑–∞–ø–∏—Å–∞–Ω–∞, –∞–∫–æ –∏–º–∞ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∏.

`SecurityStamp` —Ç–æ–≤–∞ –µ —Å—Ç–æ–π–Ω–æ—Å—Ç, –∫–æ—è—Ç–æ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –∑–∞ –º–∞—Ä–∫–∏—Ä–∞–Ω–µ –Ω–∞ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –Ω–∞ —Å–∏–≥—É—Ä–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è. –¢–æ–π –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Å–µ –ø—Ä–æ–º–µ–Ω—è –ø—Ä–∏ –≤—Å—è–∫–∞ –∑–Ω–∞—á–∏—Ç–µ–ª–Ω–∞ –ø—Ä–æ–º—è–Ω–∞ –≤ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∏—è –∞–∫–∞—É–Ω—Ç, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä –ø—Ä–∏ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ –ø–∞—Ä–æ–ª–∞—Ç–∞ –∏–ª–∏ –æ–±–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è—Ç–∞ –∑–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è. –¢–æ–≤–∞ –ø–æ–º–∞–≥–∞ –¥–∞ —Å–µ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç—è—Ç —Å–µ—Å–∏–∏ —Å –∏–∑—Ç–µ–∫–ª–∞ –∞–≤—Ç–µ–Ω—Ç–∏–∫–∞—Ü–∏—è, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä –ø—Ä–∏ –æ—Ç–∫–∞–∑ –æ—Ç —Å–µ—Å–∏—è –∏–ª–∏ –∑–∞ —Å–∏–≥—É—Ä–Ω–æ—Å—Ç –≤ –ø—Ä–æ—Ü–µ—Å–∞ –Ω–∞ —É–¥–æ—Å—Ç–æ–≤–µ—Ä—è–≤–∞–Ω–µ.

`LockoutEnd`, `LockoutEnabled` –∏ `AccessFailedCount` —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –∑–∞ –∑–∞–∫–ª—é—á–≤–∞–Ω–µ –Ω–∞ –∞–∫–∞—É–Ω—Ç–∞ —Å–ª–µ–¥ –ø—Ä–µ–∫–∞–ª–µ–Ω–æ –º–Ω–æ–≥–æ –Ω–µ—É—Å–ø–µ—à–Ω–∏ –æ–ø–∏—Ç–∏ –∑–∞ –≤—Ö–æ–¥. –¢–æ–≤–∞ –æ—Å–∏–≥—É—Ä—è–≤–∞ –∑–∞—â–∏—Ç–∞ —Å—Ä–µ—â—É brute force –∞—Ç–∞–∫–∏.

–ê–∫–æ –∏—Å–∫–∞–º–µ –¥–∞ —Å–≤—ä—Ä–∂–µ–º –Ω–∞—à–∞ —Ç–∞–±–ª–∏—Ü–∞ —Å –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∞—Ç–∞ —Ç–∞–±–ª–∏—Ü–∞ `AspNetUsers`, —Ç—Ä—è–±–≤–∞ –¥–∞ –¥–æ–±–∞–≤–∏–º –∫–æ–ª–æ–Ω–∞ `UserId`, –∫–æ—è—Ç–æ –¥–∞ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è, –∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω–æ —Å–≤–æ–π—Å—Ç–≤–æ –æ—Ç —Ç–∏–ø **`IdentityUser`** (–∏–ª–∏ –∫–ª–∞—Å, –∫–æ–π—Ç–æ —Ä–∞–∑—à–∏—Ä—è–≤–∞ `IdentityUser`, –∞–∫–æ —Å–º–µ —Å—ä–∑–¥–∞–ª–∏ —Ç–∞–∫—ä–≤, –ø—Ä–∏–º–µ—Ä–Ω–æ `ApplicationUser`), –∑–∞ –¥–∞ —Ä–µ–∞–ª–∏–∑–∏—Ä–∞–º–µ –≤—Ä—ä–∑–∫–∞—Ç–∞ –º–µ–∂–¥—É –¥–≤–µ—Ç–µ —Ç–∞–±–ª–∏—Ü–∏. –ù—è–º–∞ –Ω—É–∂–¥–∞ –¥–∞ —Å–µ —Å—ä–∑–¥–∞–≤–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω–∞ –∫–æ–ª–µ–∫—Ü–∏—è –≤ `AspNetUsers`, —Ç—ä–π –∫–∞—Ç–æ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ –∑–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏ (`AspNetUsers`) –Ω–µ —Å—ä–¥—ä—Ä–∂–∞ –∫–æ–ª–µ–∫—Ü–∏–∏ –æ—Ç —Å–≤—ä—Ä–∑–∞–Ω–∏ –æ–±–µ–∫—Ç–∏.

**`AspNetRoles`**  
–°—ä–¥—ä—Ä–∂–∞ —Ä–æ–ª–∏—Ç–µ, –∫–æ–∏—Ç–æ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –ø—Ä–∏—Å–≤–æ–µ–Ω–∏ –Ω–∞ –Ω–∞—à–∏—Ç–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏.

–í—Å–µ–∫–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –º–æ–∂–µ –¥–∞ –∏–º–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Ä–æ–ª–∏, –∫–∞—Ç–æ –≤—Ä—ä–∑–∫–∞—Ç–∞ –º–µ–∂–¥—É –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏ –∏ —Ä–æ–ª–∏ –µ –æ—Ç —Ç–∏–ø –º–Ω–æ–≥–æ –∫—ä–º –º–Ω–æ–≥–æ.

**`AspNetRoleClaims`**  
–í—Å—è–∫–∞ —Ä–æ–ª—è –º–æ–∂–µ –¥–∞ —Å—ä–¥—ä—Ä–∂–∞ –∫–ª–µ–π–º–æ–≤–µ. –¢–æ–≤–∞ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ –∫–æ–≥–∞—Ç–æ –¥–∞–¥–µ–Ω –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –ø–æ–ª—É—á–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ —Ä–æ–ª—è (–Ω–∞–ø—Ä–∏–º–µ—Ä ‚Äû–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä‚Äú), —Ç–æ–π –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–æ–ª—É—á–∞–≤–∞ –∏ –∫–ª–µ–π–º–æ–≤–µ—Ç–µ, —Å–≤—ä—Ä–∑–∞–Ω–∏ —Å —Ç–∞–∑–∏ —Ä–æ–ª—è.

**`AspNetUserClaims`**  
–ö–ª–µ–π–º–æ–≤–µ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –∑–∞–¥–∞–≤–∞–Ω–∏ –∏ –¥–∏—Ä–µ–∫—Ç–Ω–æ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è, –±–µ–∑ –¥–∞ –µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–∞ –º–∏–Ω–∞–≤–∞—Ç –ø—Ä–µ–∑ —Ä–æ–ª—è.

**`AspNetUserLogins`**  
–¢–∞–∑–∏ —Ç–∞–±–ª–∏—Ü–∞ –µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞ –∑–∞ –≤—ä–Ω—à–Ω–∏—Ç–µ –ø—Ä–æ–≤–∞–π–¥—ä—Ä–∏. –ö–æ–≥–∞—Ç–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª —Å–µ –≤–ø–∏—à–µ —á—Ä–µ–∑ –≤—ä–Ω—à–µ–Ω –ø—Ä–æ–≤–∞–π–¥—ä—Ä, —Å–∏—Å—Ç–µ–º–∞—Ç–∞ –∏–∑–ø–æ–ª–∑–≤–∞ —Ç–∞–∑–∏ —Ç–∞–±–ª–∏—Ü–∞, –∑–∞ –¥–∞ –Ω–∞–ø—Ä–∞–≤–∏ —Å—ä–ø–æ—Å—Ç–∞–≤—è–Ω–µ –ø–æ –∏–º–µ –∏ –∫–ª—é—á –Ω–∞ –ø—Ä–æ–≤–∞–π–¥—ä—Ä–∞.

–í—ä–Ω—à–µ–Ω –ø—Ä–æ–≤–∞–π–¥—ä—Ä –æ–∑–Ω–∞—á–∞–≤–∞ –≤—ä–Ω—à–Ω–∞ —É—Å–ª—É–≥–∞, —á—Ä–µ–∑ –∫–æ—è—Ç–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ –º–æ–≥–∞—Ç –¥–∞ —Å–µ –≤–ø–∏—Å–≤–∞—Ç (–ª–æ–≥–≤–∞—Ç) –≤ –Ω–∞—à–µ—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, –≤–º–µ—Å—Ç–æ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –ª–æ–∫–∞–ª–Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Å –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–æ –∏–º–µ –∏ –ø–∞—Ä–æ–ª–∞.

–ü—Ä–∏–º–µ—Ä–∏ –∑–∞ –≤—ä–Ω—à–Ω–∏ –ø—Ä–æ–≤–∞–π–¥—ä—Ä–∏ —Å–∞: Google, Facebook, Microsoft, Twitter, GitHub, Apple –∏ —Ç–Ω.

–ö–æ–≥–∞—Ç–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –∏–∑–±–µ—Ä–µ –¥–∞ —Å–µ –≤–ø–∏—à–µ —á—Ä–µ–∑ –≤—ä–Ω—à–µ–Ω –ø—Ä–æ–≤–∞–π–¥—ä—Ä, –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –Ω–∏ –≥–æ –ø—Ä–µ–Ω–∞—Å–æ—á–≤–∞ –∫—ä–º —Å—ä–æ—Ç–≤–µ—Ç–Ω–∏—è —Å–∞–π—Ç (–Ω–∞–ø—Ä. Google), –∫—ä–¥–µ—Ç–æ —Ç–æ–π –ø–æ—Ç–≤—ä—Ä–∂–¥–∞–≤–∞ —Å–∞–º–æ–ª–∏—á–Ω–æ—Å—Ç—Ç–∞ —Å–∏. –°–ª–µ–¥ —Ç–æ–≤–∞ –≤—ä–Ω—à–Ω–∏—è—Ç –ø—Ä–æ–≤–∞–π–¥—ä—Ä –Ω–∏ –≤—Ä—ä—â–∞ –ø–æ—Ç–≤—ä—Ä–¥–µ–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è (–Ω–∞–ø—Ä. –∏–º–µ–π–ª), –∫–æ—è—Ç–æ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ, –∑–∞ –¥–∞ —Å—ä–∑–¥–∞–¥–µ–º –∏–ª–∏ –∑–∞—Ä–µ–¥–∏–º –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∏ –ø—Ä–æ—Ñ–∏–ª.

–¢–æ–≤–∞ —É–ª–µ—Å–Ω—è–≤–∞ –≤—Ö–æ–¥–∞ –∑–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ –∏ –ø—Ä–µ–º–∞—Ö–≤–∞ –Ω—É–∂–¥–∞—Ç–∞ –¥–∞ –∑–∞–ø–æ–º–Ω—è—Ç –Ω–æ–≤–∞ –ø–∞—Ä–æ–ª–∞.

**`AspNetUserTokens`**  
–¢–∞–±–ª–∏—Ü–∞ –∑–∞ —Å—ä—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞ —Ç–æ–∫–µ–Ω–∏. –í—ä–ø—Ä–µ–∫–∏ —Ç–æ–≤–∞, –ø–æ –ø—Ä–∏–Ω—Ü–∏–ø –Ω–µ –µ –ø—Ä–µ–ø–æ—Ä—ä—á–∏—Ç–µ–ª–Ω–æ —Ç–æ–∫–µ–Ω–∏—Ç–µ –¥–∞ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç –≤ –±–∞–∑–∞—Ç–∞.
### System Setup
–î–æ–±—Ä–µ –µ, –∫–æ–≥–∞—Ç–æ —Å—ä–∑–¥–∞–≤–∞–º–µ ASP.NET –ø—Ä–æ–µ–∫—Ç–∞, –¥–∞ –∏–∑–±–µ—Ä–µ–º `Authentication type` => `Individual Accounts`, –∫–æ–µ—Ç–æ —â–µ –∞–∫—Ç–∏–≤–∏—Ä–∞ Identity, —Å–ª–µ–¥ –∫–æ–µ—Ç–æ –º–æ–∂–µ–º –ª–µ—Å–Ω–æ –¥–∞ –≥–æ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–∞–º–µ. –î–æ–±–∞–≤—è–Ω–µ—Ç–æ –Ω–∞ Identity –≤–ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏–µ, —Å–ª–µ–¥ –∫–∞—Ç–æ –ø—Ä–æ–µ–∫—Ç—ä—Ç –≤–µ—á–µ –µ —Å—ä–∑–¥–∞–¥–µ–Ω –µ –ø–æ-—Ç—Ä—É–¥–Ω–æ.

–ú–æ–∂–µ –¥–∞ —Å–µ –Ω–∞–ø—Ä–∞–≤–∏ –∏ —Ä—ä—á–Ω–æ. –¢–æ–≥–∞–≤–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–Ω—Å—Ç–∞–ª–∏—Ä–∞–º–µ –Ω—É–∂–Ω–∏—Ç–µ NuGet –ø–∞–∫–µ—Ç–∏, –¥–∞ –Ω–∞–ø—Ä–∞–≤–∏–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏—Ç–µ.

–ù–µ–æ–±—Ö–æ–¥–∏–º–∏—è—Ç NuGet –ø–∞–∫–µ—Ç –µ: `Microsoft.AspNetCore.Identity.EntityFrameworkCore`.

–ö–æ–≥–∞—Ç–æ –∏–∑–±–µ—Ä–µ–º Identity, out of the box –ø–æ–ª—É—á–∞–≤–∞–º–µ –ø–∞–ø–∫–∞ `Data` —Å —Ñ–∞–π–ª–∞ `ApplicationDbContext.cs`, –∫–æ–π—Ç–æ –æ—Ç–≥–æ–≤–∞—Ä—è –∑–∞ –Ω–∞—à–∞—Ç–∞ –±–∞–∑–∞ –¥–∞–Ω–Ω–∏. –¢–æ–π –Ω–∞—Å–ª–µ–¥—è–≤–∞ `IdentityDbContext`, –∫—ä–¥–µ—Ç–æ —Å–µ –Ω–∞–º–∏—Ä–∞—Ç —Ç–∞–±–ª–∏—Ü–∏—Ç–µ –Ω–∞ Identity, –∏ —Ç–æ–≤–∞ –µ –¥–æ—Å—Ç–∞—Ç—ä—á–Ω–æ, –∑–∞ –¥–∞ –º–æ–∂–µ–º –¥–∞ –¥–æ—Å—Ç—ä–ø–≤–∞–º–µ –¥–∞–Ω–Ω–∏—Ç–µ –Ω–∞ –Ω–∞—à–∏—Ç–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏. –°—ä–∑–¥–∞–≤–∞ —Å–µ –∏ –ø–∞–ø–∫–∞ `Migrations`, –≤ –∫–æ—è—Ç–æ —Å–µ –Ω–∞–º–∏—Ä–∞ –º–∏–≥—Ä–∞—Ü–∏—è—Ç–∞, —Å—ä–∑–¥–∞–≤–∞—â–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–∏—Ç–µ —Ç–∞–±–ª–∏—Ü–∏.
### Template Authentication
**`ApplicationDbContext.cs`**

–°—ä–¥—ä—Ä–∂–∞ EF data context-–∞.

–û—Å–∏–≥—É—Ä—è–≤–∞ –¥–æ—Å—Ç—ä–ø –¥–æ –¥–∞–Ω–Ω–∏—Ç–µ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ —á—Ä–µ–∑ –º–æ–¥–µ–ª–Ω–∏ –æ–±–µ–∫—Ç–∏.

–ü—Ä–∏–Ω—Ü–∏–ø–Ω–æ –Ω–µ –±–∏ —Ç—Ä—è–±–≤–∞–ª–æ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ Identity —Ç–∞–±–ª–∏—Ü–∏—Ç–µ –¥–∏—Ä–µ–∫—Ç–Ω–æ —á—Ä–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞. –ö–æ–Ω—Ç–µ–∫—Å—Ç—ä—Ç —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ —Å–∞–º–æ –∑–∞ –¥–æ—Å—Ç—ä–ø –¥–æ –Ω–∞—à–∏—Ç–µ —Å–æ–±—Å—Ç–≤–µ–Ω–∏ —Ç–∞–±–ª–∏—Ü–∏. –¢–∞–±–ª–∏—Ü–∏—Ç–µ –Ω–∞ Identity –Ω–µ —Å–µ –¥–æ—Å—Ç—ä–ø–≤–∞—Ç –¥–∏—Ä–µ–∫—Ç–Ω–æ, –∞ —á—Ä–µ–∑ —Å–ø–µ—Ü–∏–∞–ª–Ω–∏ –ø–æ–º–æ—â–Ω–∏ –∫–ª–∞—Å–æ–≤–µ, –Ω–∞—Ä–µ—á–µ–Ω–∏ –º–µ–Ω–∏–¥–∂—ä—Ä–∏.

**`Program.cs`**

–ú–æ–∂–µ –¥–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–º–µ –∞–≤—Ç–µ–Ω—Ç–∏–∫–∞—Ü–∏—è —á—Ä–µ–∑ –±–∏—Å–∫–≤–∏—Ç–∫–∏ (–∏–ª–∏ JWT). –ò–º–∞ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞, –Ω–æ —Å–µ –Ω–∞–ª–∞–≥–∞ –¥–∞ –Ω–∞–ø—Ä–∞–≤–∏–º –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.

–ú–æ–∂–µ –¥–∞ –∞–∫—Ç–∏–≤–∏—Ä–∞–º–µ –≤—Ö–æ–¥ —á—Ä–µ–∑ –≤—ä–Ω—à–Ω–∏ –ø—Ä–æ–≤–∞–π–¥—ä—Ä–∏ (–Ω–∞–ø—Ä. Facebook).

–ú–æ–∂–µ–º –¥–∞ –ø—Ä–æ–º–µ–Ω—è–º–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ –Ω–∞ Identity.

Password settings:

```csharp
builder.Services.AddDefaultIdentity<IdentityUser>(options =>
{
    // Password, lockout, emails, etc.
    options.SignIn.RequireConfirmedAccount = true;
    options.Password.RequireDigit = true;
    options.Password.RequireLowercase = true;
    options.Password.RequireUppercase = true;
    options.Password.RequireNonAlphanumeric = true;
    options.Password.RequiredLength = 10;
}).AddEntityFrameworkStores<ApplicationDbContext>();
```

–¢–µ–∑–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –∏–∑–Ω–µ—Å–µ–Ω–∏ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–µ–Ω —Ñ–∞–π–ª –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä `appsettings.json`, –∑–∞ –¥–∞ –Ω–µ —Å–µ –Ω–∞–ª–∞–≥–∞ —Å–ø–∏—Ä–∞–Ω–µ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ, –∞–∫–æ —Å–µ –ø—Ä–∞–≤—è—Ç –ø—Ä–æ–º–µ–Ω–∏.

–ü–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ `SignIn.RequireConfirmedAccount = true`, –Ω–æ –¥–æ–∫–∞—Ç–æ —Ä–∞–∑—Ä–∞–±–æ—Ç–≤–∞–º–µ –Ω–∞—à–µ—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, –Ω—è–º–∞ —Ä–µ–∞–ª–µ–Ω –º–µ—Ö–∞–Ω–∏–∑—ä–º, –∫–æ–π—Ç–æ –¥–∞ –∏–∑–ø—Ä–∞—â–∞ –º–µ–π–ª–∏. –ü–æ—Ä–∞–¥–∏ —Ç–æ–≤–∞, —Å–ª–µ–¥ –∫–∞—Ç–æ —Å—ä–∑–¥–∞–¥–µ–º –∞–∫–∞—É–Ω—Ç, –Ω–µ –º–æ–∂–µ–º –¥–∞ —Å–µ –≤–ø–∏—à–µ–º. –û—Å–≤–µ–Ω –¥–∞ –∏–∑–∫–ª—é—á–∏–º —Ç–∞–∑–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞ —Ü—è–ª–æ—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–∞ –∞–∫–∞—É–Ω—Ç —Å–µ –ø–æ–∫–∞–∑–≤–∞ –ª–∏–Ω–∫, —á—Ä–µ–∑ –∫–æ–π—Ç–æ –º–æ–∂–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –¥–∞ –ø–æ—Ç–≤—ä—Ä–¥–∏–º –∞–∫–∞—É–Ω—Ç–∞. –¢–æ–∑–∏ –ª–∏–Ω–∫ –µ –¥–æ–±–∞–≤–µ–Ω —Å–∞–º–æ –∑–∞ –µ—Ç–∞–ø–∞ –Ω–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞ –∏ —Ç—Ä—è–±–≤–∞ –¥–∞ –±—ä–¥–µ –ø—Ä–µ–º–∞—Ö–Ω–∞—Ç, –∫–æ–≥–∞—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –ø—Ä–µ–º–∏–Ω–µ –≤ –ø—Ä–æ–¥—É–∫—Ü–∏–æ–Ω–Ω–∞ —Å—Ä–µ–¥–∞.
## Scaffolding Identity
### Razor Pages
Razor Pages –≤ ASP.NET Core —Å–µ —Ä–∞–∑–ª–∏—á–∞–≤–∞—Ç –æ—Ç —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–∏—è MVC –º–æ–¥–µ–ª, –∫–∞—Ç–æ –≤ —Ç—è—Ö –Ω–µ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä –∑–∞ –≤—Å—è–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞. –í–º–µ—Å—Ç–æ —Ç–æ–≤–∞, –≤—Å—è–∫–∞ Razor Page (—Å —Ä–∞–∑—à–∏—Ä–µ–Ω–∏–µ `.cshtml`) –∏–º–∞ —Å–≤—ä—Ä–∑–∞–Ω `.cshtml.cs` —Ñ–∞–π–ª, –∫–æ–π—Ç–æ –∏–∑–ø—ä–ª–Ω—è–≤–∞ —Ä–æ–ª—è—Ç–∞ –Ω–∞ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä.

–ü–æ —Å—ä—â–µ—Å—Ç–≤–æ, Razor Page –µ –∫–æ–º–±–∏–Ω–∞—Ü–∏—è –æ—Ç –∏–∑–≥–ª–µ–¥ (view) –∏ –∫–æ–¥-–±–∏—Ö–µ–π–≤–∏–æ—Ä (code-behind). –¢–∞–∑–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ–∑–≤–æ–ª—è–≤–∞ –Ω–∞ –ª–æ–≥–∏–∫–∞—Ç–∞ –∑–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ –∑–∞—è–≤–∫–∏—Ç–µ –¥–∞ –±—ä–¥–µ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–∞–Ω–∞ –¥–∏—Ä–µ–∫—Ç–Ω–æ —Å –∏–∑–≥–ª–µ–¥–∞.

- `.cshtml` —Ñ–∞–π–ª—ä—Ç —Å—ä–¥—ä—Ä–∂–∞ HTML –∏ Razor —Å–∏–Ω—Ç–∞–∫—Å–∏—Å, –∫–∞–∫—Ç–æ –∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –∑–∞ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏.
- `.cshtml.cs` —Ñ–∞–π–ª—ä—Ç —Å—ä–¥—ä—Ä–∂–∞ –∫–æ–¥, –∫–æ–π—Ç–æ –æ–±—Ä–∞–±–æ—Ç–≤–∞ HTTP –∑–∞—è–≤–∫–∏—Ç–µ –∏ –≤—Ä—ä—â–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ (–æ–±—Ä–∞–±–æ—Ç–≤–∞–Ω–µ –Ω–∞ —Ñ–æ—Ä–º—É–ª—è—Ä–∏, –∏–∑–≤–ª–∏—á–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏ –æ—Ç –±–∞–∑–∞ –¥–∞–Ω–Ω–∏ –∏ —Ç.–Ω.).

–ö–æ–≥–∞—Ç–æ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ Razor Page, —Ä–µ–∞–ª–Ω–æ –∏–º–∞–º–µ –¥–≤–∞ —Ñ–∞–π–ª–∞: –µ–¥–∏–Ω –∑–∞ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è (`cshtml`) –∏ –µ–¥–∏–Ω –∑–∞ –ª–æ–≥–∏–∫–∞—Ç–∞ (`cshtml.cs`), –∫–∞—Ç–æ –≤—Ç–æ—Ä–∞—Ç–∞ —á–∞—Å—Ç —Å—ä–¥—ä—Ä–∂–∞ –ª–æ–≥–∏–∫–∞—Ç–∞, –∫–æ—è—Ç–æ –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ –±–∏ –±–∏–ª–∞ –≤ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∞ –≤ –∫–ª–∞—Å–∏—á–µ—Å–∫–∏—Ç–µ MVC –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.

–¢–æ–≤–∞ –ø—Ä–∞–≤–∏ Razor Pages –ø–æ-–º–∞–ª–∫–æ –∑–∞–≤–∏—Å–∏–º–∏ –æ—Ç –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∏ –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è –ø–æ-–∏–Ω—Ç—É–∏—Ç–∏–≤–µ–Ω –Ω–∞—á–∏–Ω –∑–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, –æ—Å–æ–±–µ–Ω–æ –∫–æ–≥–∞—Ç–æ –Ω–µ –µ –Ω—É–∂–Ω–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –ª–æ–≥–∏–∫–∞—Ç–∞ –º–µ–∂–¥—É –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∏ –∏ –∏–∑–≥–ª–µ–¥–∏.
### Scaffolding ASP.NET Core Identity
–û—Ç ASP.NET Core 2.2, Identity –µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–µ–Ω –∫–∞—Ç–æ Razor Class Library. –¢–æ–≤–∞ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ —á–∞—Å—Ç –æ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–æ—Å—Ç—Ç–∞ –∑–∞ —É–¥–æ—Å—Ç–æ–≤–µ—Ä—è–≤–∞–Ω–µ –∏ –æ—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –µ –æ–±–≤–∏—Ç–∞ –≤ Razor –±–∏–±–ª–∏–æ—Ç–µ–∫–∞, –∫–æ—è—Ç–æ –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–∞ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è—Ç–∞. 

–í ASP.NET Core Identity —Å—Ç—Ä–∞–Ω–∏—Ü–∏—Ç–µ —Å–µ –Ω–∞–º–∏—Ä–∞—Ç –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞—Ç–∞ Razor Class Library –∏ –Ω–µ –º–æ–≥–∞—Ç –¥–∞ —Å–µ –ø—Ä–æ–º–µ–Ω—è—Ç –¥–∏—Ä–µ–∫—Ç–Ω–æ, –æ—Å–≤–µ–Ω –∞–∫–æ –Ω–µ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –ø—Ä–æ—Ü–µ—Å–∞ –Ω–∞ "scaffolding" (–≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –∫–æ–¥).

–ü—Ä–æ—Ü–µ—Å—ä—Ç –Ω–∞ scaffolding –ø–æ–∑–≤–æ–ª—è–≤–∞ –¥–∞ –≥–µ–Ω–µ—Ä–∏—Ä–∞–º–µ –∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–∞–º–µ Identity —Å—Ç—Ä–∞–Ω–∏—Ü–∏—Ç–µ (–∫–∞—Ç–æ –ª–æ–≥–∏–Ω, —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è, –ø–æ—Ç–≤—ä—Ä–∂–¥–µ–Ω–∏–µ –Ω–∞ –∏–º–µ–π–ª, –∏ —Ç.–Ω.) —Å–ø–æ—Ä–µ–¥ –Ω—É–∂–¥–∏—Ç–µ –Ω–∞ –Ω–∞—à–µ—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ. –ï—Ç–æ –∫–∞–∫ —Ä–∞–±–æ—Ç–∏ –ø—Ä–æ—Ü–µ—Å—ä—Ç:

1. –©—Ä–∞–∫–≤–∞–º–µ —Å –¥–µ—Å–µ–Ω –±—É—Ç–æ–Ω –≤—ä—Ä—Ö—É –ø—Ä–æ–µ–∫—Ç–∞ –≤ **Solution Explorer**.

2. –ò–∑–±–∏—Ä–∞–º–µ **Add** -> **New Scaffolded Item**.

3. –í –æ—Ç–≤–æ—Ä–µ–Ω–æ—Ç–æ –º–µ–Ω—é –∏–∑–±–∏—Ä–∞–º–µ **Identity**.

4. –¢—Ä—è–±–≤–∞ –¥–∞ –ø–æ—Å–æ—á–∏–º **DbContext** –∫–ª–∞—Å, –∫–æ–π—Ç–æ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∏—Ç–µ, –∫–æ–∏ —Ç–æ—á–Ω–æ Identity Razor —Å—Ç—Ä–∞–Ω–∏—Ü–∏ –∏—Å–∫–∞–º–µ –¥–∞ –¥–æ–±–∞–≤–∏–º (–º–æ–∂–µ–º –¥–∞ –∏–∑–±–µ—Ä–µ–º –≤—Å–∏—á–∫–∏ –∏–ª–∏ –¥–∞ –ø–æ—Å–æ—á–∏–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏), –∫–∞–∫—Ç–æ –∏ –¥–∞ –∏–∑–±–µ—Ä–µ–º **Layout** —Ñ–∞–π–ª.

5. –°–ª–µ–¥ –∫–∞—Ç–æ –∑–∞–≤—ä—Ä—à–∏ –ø—Ä–æ—Ü–µ—Å—ä—Ç –Ω–∞ scaffolding, –∏–∑–±—Ä–∞–Ω–∏—Ç–µ Razor Pages —â–µ —Å–µ –ø–æ—è–≤—è—Ç –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ç–∞ **Areas/Identity/Pages/Account**.

–°–ª–µ–¥ –∫–∞—Ç–æ —Å–º–µ –¥–æ–±–∞–≤–∏–ª–∏ –∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–∞–ª–∏ —Ç–µ–∑–∏ —Å—Ç—Ä–∞–Ω–∏—Ü–∏, –º–æ–∂–µ–º –¥–∞ –≥–∏ –ø—Ä–æ–º–µ–Ω—è–º–µ –∫–∞–∫—Ç–æ –∏—Å–∫–∞–º–µ. –í —Ç–æ–∑–∏ –ø—Ä–æ—Ü–µ—Å —Å–µ –≥–µ–Ω–µ—Ä–∏—Ä–∞—Ç —Ñ–∞–π–ª–æ–≤–µ –∑–∞ –∏–∑–≥–ª–µ–¥–∏—Ç–µ –∏ –∫–æ–¥-–±–∏—Ö–µ–π–≤–∏–æ—Ä–∞, –∫–æ–∏—Ç–æ –º–æ–∂–µ–º –¥–∞ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–∞–º–µ —Å–ø—Ä—è–º–æ –∏–∑–∏—Å–∫–≤–∞–Ω–∏—è—Ç–∞ –Ω–∞ –ø—Ä–æ–µ–∫—Ç–∞.

–° –ø–æ–º–æ—â—Ç–∞ –Ω–∞ —Å–∫–µ–ª–µ—Ç–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä (scaffolder) –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–Ω –∑–∞ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –∏–∑—Ö–æ–¥–µ–Ω –∫–æ–¥. –¢–æ–≤–∞ –µ –ø–æ–ª–µ–∑–Ω–æ, –∞–∫–æ —Ç—Ä—è–±–≤–∞ –¥–∞ –ø—Ä–æ–º–µ–Ω–∏–º –∏–ª–∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–∞–º–µ —á–∞—Å—Ç –æ—Ç –ª–æ–≥–∏–∫–∞—Ç–∞, —Å–≤—ä—Ä–∑–∞–Ω–∞ —Å Identity.

–ü–æ–≤–µ—á–µ—Ç–æ –æ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–∏—Ç–µ –∫–æ–¥–æ–≤–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –∑–∞ Identity —Å–µ –≥–µ–Ω–µ—Ä–∏—Ä–∞—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —á—Ä–µ–∑ —Å–∫–µ–ª–µ—Ç–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä, –∫–∞—Ç–æ —Ç–æ–≤–∞ —É–ª–µ—Å–Ω—è–≤–∞ –≤–Ω–µ–¥—Ä—è–≤–∞–Ω–µ—Ç–æ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ç–∞ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∞—Ç–∞ –∞–≤—Ç–µ–Ω—Ç–∏–∫–∞—Ü–∏—è –∏ –æ—Ç–æ—Ä–∏–∑–∞—Ü–∏—è.
## `IdentityUser`
### Extending Identity Models
–í ASP.NET Core –Ω–µ —Ä–∞–±–æ—Ç–∏–º –¥–∏—Ä–µ–∫—Ç–Ω–æ —Å Identity —Ç–∞–±–ª–∏—Ü–∏—Ç–µ –≤ –±–∞–∑–∞—Ç–∞. –í–º–µ—Å—Ç–æ —Ç–æ–≤–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–∏ –º–µ–Ω–∏–¥–∂—ä—Ä–∏:

- `UserManager<TUser>` ‚Äì –∑–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ.
- `SignInManager<TUser>` ‚Äì –∑–∞ –ª–æ–≥–≤–∞–Ω–µ –∏ –∏–∑–ª–∏–∑–∞–Ω–µ –æ—Ç —Å–∏—Å—Ç–µ–º–∞—Ç–∞.
- `RoleManager<TRole>` ‚Äì –∑–∞ —Ä–∞–±–æ—Ç–∞ —Å —Ä–æ–ª–∏.

–ß—Ä–µ–∑ —Ç–µ—Ö–Ω–∏—Ç–µ –º–µ—Ç–æ–¥–∏ –º–æ–∂–µ–º –¥–∞:

- —Å—ä–∑–¥–∞–≤–∞–º–µ, –Ω–∞–º–∏—Ä–∞–º–µ, –ø—Ä–æ–º–µ–Ω—è–º–µ –∏–ª–∏ –∏–∑—Ç—Ä–∏–≤–∞–º–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏.
- –ø—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –ø–∞—Ä–æ–ª–∏, –¥–æ–±–∞–≤—è–º–µ —Ä–æ–ª–∏ –∏ —Ç.–Ω.

–ú–∞–∫–∞—Ä —á–µ –∏–º–∞–º–µ –¥–æ—Å—Ç—ä–ø –¥–æ —Ç–∞–±–ª–∏—Ü–∏—Ç–µ, **–Ω–µ —Ç—Ä—è–±–≤–∞ –¥–∞ –≥–∏ –ø—Ä–æ–º–µ–Ω—è–º–µ –¥–∏—Ä–µ–∫—Ç–Ω–æ**, –∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ —Ç–µ–∑–∏ –º–µ–Ω–∏–¥–∂—ä—Ä–∏.
### Customizing `IdentityUser`
–ü–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ ASP.NET Core Identity –∏–∑–ø–æ–ª–∑–≤–∞ –∫–ª–∞—Å–∞ `IdentityUser`, –∫–æ–π—Ç–æ **–æ—Ç–≥–æ–≤–∞—Ä—è –Ω–∞ —Ç–∞–±–ª–∏—Ü–∞—Ç–∞ `AspNetUsers`** –≤ –±–∞–∑–∞—Ç–∞. –ê–∫–æ –∏—Å–∫–∞–º–µ –¥–∞ –¥–æ–±–∞–≤–∏–º –Ω–æ–≤–∏ –ø–æ–ª–µ—Ç–∞ –∫—ä–º –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä **–∏–º–µ**, **—Ñ–∞–º–∏–ª–∏—è** –∏ —Ç–Ω), —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–∏ —Å—ä–∑–¥–∞–¥–µ–º —Å–æ–±—Å—Ç–≤–µ–Ω –∫–ª–∞—Å:

```csharp
public class ApplicationUser : IdentityUser
{
    [PersonalData]
    [MaxLength(255)]
    [Comment("The first name of the user.")]
    public string? FirstName { get; set; }

    [PersonalData]
    [MaxLength(255)]
    [Comment("The last name of the user.")]
    public string? LastName { get; set; }
}
```

- **–ò–º–µ—Ç–æ –Ω–∞ –∫–ª–∞—Å–∞ –º–æ–∂–µ –¥–∞ –µ –ø—Ä–æ–∏–∑–≤–æ–ª–Ω–æ**, –≤–∞–∂–Ω–æ—Ç–æ –µ –¥–∞ **–Ω–∞—Å–ª–µ–¥—è–≤–∞ `IdentityUser`**.

–°–ª–µ–¥ —Ç–æ–≤–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ –≥–æ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–∞–º–µ:

- –í `Program.cs`:

```csharp
builder.Services.AddDefaultIdentity<ApplicationUser>(...)  
```

- –í `ApplicationDbContext`:

```csharp
public class ApplicationDbContext : IdentityDbContext<ApplicationUser>
```

>[!WARNING]
>–ê–∫–æ –ø–ª–∞–Ω–∏—Ä–∞–º–µ –¥–∞ –Ω–∞–ø—Ä–∞–≤–∏–º scaffold –Ω–∞ –±–∞–∑–æ–≤–∏—Ç–µ Identity —Å—Ç—Ä–∞–Ω–∏—Ü–∏ –∏ —Å—ä—â–µ–≤—Ä–µ–º–µ–Ω–Ω–æ –∏—Å–∫–∞–º–µ –¥–∞ —Ä–∞–∑—à–∏—Ä–∏–º Identity —Ç–∞–±–ª–∏—Ü–∏—Ç–µ (–Ω–∞–ø—Ä. —Å `ApplicationUser`), —Ç—Ä—è–±–≤–∞ –ø—ä—Ä–≤–æ –¥–∞ –Ω–∞–ø—Ä–∞–≤–∏–º —Ä–∞–∑—à–∏—Ä–µ–Ω–∏–µ—Ç–æ, –∞ —á–∞–∫ —Å–ª–µ–¥ —Ç–æ–≤–∞ –¥–∞ –∏–∑–ø—ä–ª–Ω–∏–º scaffolding-a.
>
>–ö–æ–≥–∞—Ç–æ –ø—ä—Ä–≤–æ –Ω–∞–ø—Ä–∞–≤–∏–º scaffold –ø—Ä–µ–¥–∏ –¥–∞ —Å—ä–∑–¥–∞–¥–µ–º `ApplicationUser`, –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏—è—Ç –∫–æ–¥ –∏–∑–ø–æ–ª–∑–≤–∞ `IdentityUser`. –ê–∫–æ —Å–ª–µ–¥ —Ç–æ–≤–∞ –ø—Ä–æ–º–µ–Ω–∏–º DI –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è—Ç–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞ `ApplicationUser`, —â–µ –≤—ä–∑–Ω–∏–∫–Ω–∞—Ç **–≥—Ä–µ—à–∫–∏ –ø—Ä–∏ –≤–Ω–µ–¥—Ä—è–≤–∞–Ω–µ –Ω–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ (dependency injection)**, –∑–∞—â–æ—Ç–æ ASP.NET –≤–µ—á–µ –Ω–µ –∑–Ω–∞–µ –∫–∞–∫ –¥–∞ –ø–æ–¥–∞–¥–µ `UserManager<IdentityUser>`, –∞ –≤ —Å–∏—Å—Ç–µ–º–∞—Ç–∞ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞ —Å–∞–º–æ `UserManager<ApplicationUser>`.
### Customizing Other Identity Tables
–ê–∫–æ –∏—Å–∫–∞–º–µ –¥–∞ **—Ä–∞–∑—à–∏—Ä–∏–º –∏ –¥—Ä—É–≥–∏ Identity —Ç–∞–±–ª–∏—Ü–∏** (–Ω–∞–ø—Ä. —Ä–æ–ª–∏, claim-–∏, login-–∏), —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –ø—ä–ª–Ω–∞—Ç–∞ —Ñ–æ—Ä–º–∞ –Ω–∞ `IdentityDbContext`, –∫–æ—è—Ç–æ –ø—Ä–∏–µ–º–∞ –ø–æ–≤–µ—á–µ generic –ø–∞—Ä–∞–º–µ—Ç—Ä–∏:

```csharp
public class ApplicationDbContext : IdentityDbContext<
    ApplicationUser,       // User
    ApplicationRole,       // Role
    string,                 // Primary key type
    IdentityUserClaim<string>,
    IdentityUserRole<string>,
    IdentityUserLogin<string>,
    IdentityRoleClaim<string>,
    IdentityUserToken<string>>
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }
}
```

- –í —Ç–æ–∑–∏ —Å–ª—É—á–∞–π –º–æ–∂–µ–º –¥–∞ —Å—ä–∑–¥–∞–¥–µ–º –∏ —Å–æ–±—Å—Ç–≤–µ–Ω –∫–ª–∞—Å `ApplicationRole : IdentityRole` –∏ –¥–∞ –¥–æ–±–∞–≤–∏–º –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ —Å–≤–æ–π—Å—Ç–≤–∞ (–Ω–∞–ø—Ä. –æ–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Ä–æ–ª—è—Ç–∞).

–¢–æ–≤–∞ –µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ **—Å–∞–º–æ –∞–∫–æ –∏—Å–∫–∞–º–µ –¥–∞ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–∞–º–µ –¥—Ä—É–≥–∏ Identity —Ç–∞–±–ª–∏—Ü–∏**, –Ω–µ —Å–∞–º–æ `AspNetUsers`.

>[!IMPORTANT]
>–ê–∫–æ —Ä–∞–∑—à–∏—Ä—è–≤–∞–º–µ —Å–∞–º–æ `AspNetUsers`, –ø–æ–ª–∑–≤–∞–º–µ `IdentityDbContext<ApplicationUser>`.  
>–ê–∫–æ —Ä–∞–∑—à–∏—Ä—è–≤–∞–º–µ –¥—Ä—É–≥–∞ —Ç–∞–±–ª–∏—Ü–∞, –¥–æ—Ä–∏ —Å–∞–º–æ –µ–¥–Ω–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä `AspNetRoles`), —Ç—Ä—è–±–≤–∞ –¥–∞ –ø—Ä–µ–º–∏–Ω–µ–º –∫—ä–º –ø—ä–ª–Ω–∞—Ç–∞ —Ñ–æ—Ä–º–∞ —Å –≤—Å–∏—á–∫–∏ generic —Ç–∏–ø–æ–≤–µ.
### `AddDefaultIdentity<TUser>()` vs `AddIdentity<TUser, TRole>()`
–†–∞–∑–ª–∏–∫–∞—Ç–∞ –º–µ–∂–¥—É `AddDefaultIdentity<TUser>()` –∏ `AddIdentity<TUser, TRole>()` –µ **–∫–ª—é—á–æ–≤–∞**, –∫–æ–≥–∞—Ç–æ —Ä–µ—à–∞–≤–∞–º–µ –¥–∞–ª–∏ —â–µ —Ä–∞–∑—à–∏—Ä–∏–º —Å–∞–º–æ `AspNetUsers` –∏–ª–∏ –∏ –¥—Ä—É–≥–∏ Identity —Ç–∞–±–ª–∏—Ü–∏.

1. **–ê–∫–æ —Ä–∞–∑—à–∏—Ä—è–≤–∞–º–µ —Å–∞–º–æ `AspNetUsers`**

```csharp
builder.Services.AddDefaultIdentity<ApplicationUser>(options => {
    // options.Password.RequireDigit = ...
})
.AddEntityFrameworkStores<ApplicationDbContext>();
```

`AddDefaultIdentity<TUser>()` –µ **—Å—ä–∫—Ä–∞—Ç–µ–Ω –≤–∞—Ä–∏–∞–Ω—Ç**, —É–¥–æ–±–µ–Ω –∫–æ–≥–∞—Ç–æ **—Ä–∞–∑—à–∏—Ä—è–≤–∞–º–µ —Å–∞–º–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ**.

2. **–ê–∫–æ —Ä–∞–∑—à–∏—Ä—è–≤–∞–º–µ –∏ –¥—Ä—É–≥–∏ —Ç–∞–±–ª–∏—Ü–∏** (–Ω–∞–ø—Ä. `AspNetRoles`, `UserClaims` –∏ —Ç.–Ω.)

**–ù–µ –º–æ–∂–µ–º –¥–∞ –ø–æ–ª–∑–≤–∞–º–µ `AddDefaultIdentity()`** ‚Äì —Ç—Ä—è–±–≤–∞ –¥–∞ –ø—Ä–µ–º–∏–Ω–µ–º –∫—ä–º:

```csharp
builder.Services.AddIdentity<ApplicationUser, ApplicationRole>(options => {
    // options.Password.RequireDigit = ...
})
.AddEntityFrameworkStores<ApplicationDbContext>()
```

`AddIdentity<TUser, TRole>()` –µ **–ø–æ-–≥—ä–≤–∫–∞–≤**, –∫–æ–≥–∞—Ç–æ –∏–º–∞–º–µ –Ω—É–∂–¥–∞ –¥–∞ —Ä–∞–±–æ—Ç–∏–º —Å –ø–æ–≤–µ—á–µ –æ—Ç –µ–¥–Ω–∞ Identity —Ç–∞–±–ª–∏—Ü–∞.
### GDPR –∏ –ª–∏—á–Ω–∏ –¥–∞–Ω–Ω–∏
- –î–æ–±—Ä–∞ –ø—Ä–∞–∫—Ç–∏–∫–∞ –µ **–¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏—Ç–µ –ø–æ–ª–µ—Ç–∞ –¥–∞ –Ω–µ —Å–∞ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–∏**, –∑–∞ –¥–∞ –º–æ–≥–∞—Ç –ª–µ—Å–Ω–æ –¥–∞ —Å–µ –ø—Ä–µ–º–∞—Ö–≤–∞—Ç –ø—Ä–∏ GDPR –∑–∞—è–≤–∫–∏, –∫–∞—Ç–æ –º–æ–∂–µ —á—Ä–µ–∑ –ø—Ä–æ–≥—Ä–∞–º–Ω–∞ –ª–æ–≥–∏–∫–∞ –¥–∞ –∑–∞–¥—ä–ª–∂–∞–≤–∞–º–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è –¥–∞ –≥–∏ –≤—ä–≤–µ–¥–µ.
- –°–ª–∞–≥–∞–º–µ –∞—Ç—Ä–∏–±—É—Ç–∞ `[PersonalData]` –Ω–∞ –ø–æ–ª–µ—Ç–∞—Ç–∞, –∫–æ–∏—Ç–æ —Å–µ —Å—á–∏—Ç–∞—Ç –∑–∞ –ª–∏—á–Ω–∏ ‚Äì —Ç–∞–∫–∞ —Ç–µ —â–µ —Å–µ –∏–∑—Ç—Ä–∏–≤–∞—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø—Ä–∏ –∏–∑–∏—Å–∫–≤–∞–Ω–µ –∑–∞ ‚Äû–ø—Ä–∞–≤–æ—Ç–æ –¥–∞ –±—ä–¥–µ—à –∑–∞–±—Ä–∞–≤–µ–Ω‚Äú.
- –ú–æ–∂–µ–º –¥–∞ –¥–æ–±–∞–≤–∏–º –∏ `[Comment("...")]`, –∑–∞ –¥–∞ –æ–ø–∏—à–µ–º –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ—Ç–æ –Ω–∞ –ø–æ–ª–µ—Ç–æ ‚Äì —Ç–∞–∑–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –ø—Ä–∏ —Å—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ –±–∞–∑–∞—Ç–∞.
## Accessing Identity via Managers
–ò–¥–µ—è—Ç–∞ –Ω–∞ –º–µ–Ω–∏–¥–∂—ä—Ä–∏—Ç–µ –µ, —á–µ –∫–æ–≥–∞—Ç–æ –∏—Å–∫–∞–º–µ –¥–∞ –¥–æ—Å—Ç—ä–ø–≤–∞–º–µ –¥–∞–Ω–Ω–∏ –æ—Ç Identity –±–∞–∑–∞—Ç–∞, –Ω–µ –≥–æ –ø—Ä–∞–≤–∏–º –¥–∏—Ä–µ–∫—Ç–Ω–æ –ø—Ä–µ–∑ `DbContext`, –∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –º–µ—Ç–æ–¥–∏—Ç–µ –Ω–∞ —Å—ä–æ—Ç–≤–µ—Ç–Ω–∏—è –º–µ–Ω–∏–¥–∂—ä—Ä. –¢–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏ –º–µ—Ç–æ–¥–∏, –∫–æ–∏—Ç–æ —Å–∞ –∏–∑–≥—Ä–∞–¥–µ–Ω–∏ —Ç–∞–∫–∞, —á–µ –¥–∞ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç—è—Ç –≤—ä–∑–º–æ–∂–Ω–∏ –ø—Ä–æ–±–ª–µ–º–∏ –ø—Ä–∏ –º–∞–Ω–∏–ø—É–ª–∏—Ä–∞–Ω–µ—Ç–æ –Ω–∞ –¥–∞–Ω–Ω–∏.

**–ù–µ –µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä—ä—á–Ω–æ –¥–∞ –¥–æ–±–∞–≤—è–º–µ `UserManager`, `SignInManager`, `RoleManager` –∏ –ø–æ–¥–æ–±–Ω–∏ –≤ `builder.Services`** ‚Äî —Ç–µ —Å–µ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–∞—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø—Ä–∏ –∏–∑–≤–∏–∫–≤–∞–Ω–µ –Ω–∞ `AddIdentity` –∏–ª–∏ `AddDefaultIdentity`.

–°–ø–∏—Å—ä–∫ —Å –Ω–∞–ª–∏—á–Ω–∏ –º–µ—Ç–æ–¥–∏ —Å–µ –Ω–∞–º–∏—Ä–∞ –≤—ä–≤ —Ñ–∞–π–ª–∞ –∑–∞ ASP.NET –≤ –ø–∞–ø–∫–∞—Ç–∞ —Å —Ä–µ—Å—É—Ä—Å–∏.

**User Manager:**

–ü—Ä–µ–¥–æ—Å—Ç–∞–≤—è –º–Ω–æ–∂–µ—Å—Ç–≤–æ –º–µ—Ç–æ–¥–∏ –∑–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ –≤ –±–∞–∑–∞ –¥–∞–Ω–Ω–∏.  

**SignIn Manager:**

–ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ, –∫–æ–≥–∞—Ç–æ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –Ω–∞–ø—Ä–∞–≤–∏ login –∏–ª–∏ logout –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª. –û—Å–≤–µ–Ω —Ç–æ–≤–∞ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è —Ä–µ–¥–∏—Ü–∞ –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–æ—Å—Ç–∏ ‚Äî –Ω–∞–ø—Ä–∏–º–µ—Ä:

- –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –¥–∞–¥–µ–Ω –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –µ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ —Ä–æ–ª—è.
- –ü–æ—Ç–≤—ä—Ä–∂–¥–µ–Ω–∏–µ –Ω–∞ –∏–º–µ–π–ª.
- –ü—Ä–æ–º—è–Ω–∞ –∏ –Ω—É–ª–∏—Ä–∞–Ω–µ (reset) –Ω–∞ –ø–∞—Ä–æ–ª–∞.
- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –Ω–∞ –≤—Ö–æ–¥.

**Role Manager:**

–ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∑–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ —Ä–æ–ª–∏ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ ‚Äî —Å—ä–∑–¥–∞–≤–∞–Ω–µ, –∏–∑—Ç—Ä–∏–≤–∞–Ω–µ, –ø—Ä–µ–∏–º–µ–Ω—É–≤–∞–Ω–µ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞–Ω–µ –Ω–∞ —Ä–æ–ª–∏.
### Check the Currently Logged-In User
–ú–æ–∂–µ –¥–∞ –ø—Ä–æ–≤–µ—Ä–∏–º –¥–∞–ª–∏ –¥–∞–¥–µ–Ω –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª –µ –ª–æ–≥–Ω–∞—Ç, —á—Ä–µ–∑ –∞—Ç—Ä–∏–±—É—Ç–∞ `[Authorize]`. 

```csharp
// GET: /Account/Roles (for logged-in users only)
[Authorize]
public async Task<ActionResult> Roles()
{
    var currentUser = await userManager.GetUserAsync(this.User);
    var roles = await userManager.GetRolesAsync(currentUser);
    // Additional logic for roles...
}

// GET: /Account/Data (for logged-in users only)
[Authorize]
public async Task<ActionResult> Data()
{
    var currentUser = await userManager.GetUserAsync(this.User);
    var currentUserUsername = await userManager.GetUserNameAsync(currentUser);
    var currentUserId = await userManager.GetUserIdAsync(currentUser);
    // Additional logic for user data...
}
```
### Authorization
`[Authorize]` -  –ü–æ–∑–≤–æ–ª—è–≤–∞ –¥–æ—Å—Ç—ä–ø —Å–∞–º–æ –Ω–∞ –∞–≤—Ç–µ–Ω—Ç–∏–∫–∏—Ä–∞–Ω–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏. –ú–æ–∂–µ –¥–∞ —Å–µ –ø—Ä–∏–ª–æ–∂–∏ –∫–∞–∫—Ç–æ –Ω–∞ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä, —Ç–∞–∫–∞ –∏ –Ω–∞ –æ—Ç–¥–µ–ª–Ω–∏ –¥–µ–π—Å—Ç–≤–∏—è, –∑–∞ –¥–∞ —Å–µ –æ–≥—Ä–∞–Ω–∏—á–∏ –¥–æ—Å—Ç—ä–ø—ä—Ç —Å–∞–º–æ –∑–∞ –ª–æ–≥–Ω–∞—Ç–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏.

`[AllowAnonymous]` - –ü–æ–∑–≤–æ–ª—è–≤–∞ –¥–æ—Å—Ç—ä–ø –Ω–∞ –∞–Ω–æ–Ω–∏–º–Ω–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏ (—Ç.–µ. –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏, –∫–æ–∏—Ç–æ –Ω–µ —Å–∞ –ª–æ–≥–Ω–∞—Ç–∏), –∫–∞—Ç–æ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –∑–∞ –¥–µ–π—Å—Ç–≤–∏—è, –∫–æ–∏—Ç–æ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–∞ –¥–æ—Å—Ç—ä–ø–Ω–∏ –±–µ–∑ –ª–æ–≥–≤–∞–Ω–µ, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä –ª–æ–≥–∏–Ω —Å—Ç—Ä–∞–Ω–∏—Ü–∞.

```csharp
// The controller is accessible only to authenticated users
[Authorize]
public class AccountController : Controller
{
    // This action is accessible to anonymous users
    // GET: /Account/Login (for anonymous users)
    [AllowAnonymous]
    public async Task<IActionResult> Login(string returnUrl)
    {
        // Logic for login...
        return View();
    }

    // This action is accessible only to logged-in users
    // POST: /Account/LogOff (for logged-in users only)
    [HttpPost]
    public async Task<IActionResult> Logout()
    {
        // Logic for logging out...
        return RedirectToAction("Index", "Home");
    }
}
```

**–û–±—è—Å–Ω–µ–Ω–∏–µ –Ω–∞ –ø—Ä–∏–º–µ—Ä–∞:**

- **[Authorize]**: –ü—Ä–∏–ª–∞–≥–∞–º–µ –≥–æ –∫—ä–º –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∞, –∫–æ–µ—Ç–æ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ –≤—Å–∏—á–∫–∏ –¥–µ–π—Å—Ç–≤–∏—è –≤ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∞ –∏–∑–∏—Å–∫–≤–∞—Ç –∞–≤—Ç–µ–Ω—Ç–∏–∫–∞—Ü–∏—è, –æ—Å–≤–µ–Ω –∞–∫–æ –Ω–µ –µ —É–∫–∞–∑–∞–Ω–æ –¥—Ä—É–≥–æ.

- **[AllowAnonymous]**: –ü—Ä–∏–ª–∞–≥–∞–º–µ –≥–æ –∫—ä–º –¥–µ–π—Å—Ç–≤–∏–µ—Ç–æ `Login`, –∫–æ–µ—Ç–æ –ø–æ–∑–≤–æ–ª—è–≤–∞ –¥–æ—Å—Ç—ä–ø –¥–æ –ª–æ–≥–∏–Ω —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ç–∞ –±–µ–∑ –∏–∑–∏—Å–∫–≤–∞–Ω–µ –∑–∞ –ª–æ–≥–≤–∞–Ω–µ. –ü–æ —Ç–æ–∑–∏ –Ω–∞—á–∏–Ω –º–æ–∂–µ–º –¥–∞ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä–∞–º–µ –∫–æ–∏ –¥–µ–π—Å—Ç–≤–∏—è —Å–∞ –ø—É–±–ª–∏—á–Ω–∏, –∞ –∫–æ–∏ –∏–∑–∏—Å–∫–≤–∞—Ç –≤—Ö–æ–¥.

–ö–æ–≥–∞—Ç–æ –∏–∑–∏—Å–∫–≤–∞–º–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –¥–∞ –±—ä–¥–µ –ª–æ–≥–Ω–∞—Ç, –ø–æ–ª—É—á–∞–≤–∞–º–µ —Å–∞–º–∏—è `User`, –Ω–æ —Ç–æ–π –Ω–µ –µ –ø—ä–ª–µ–Ω. –¢–∏–ø—ä—Ç –º—É –µ `ClaimsPrincipal`, –∞ –Ω–µ `IdentityUser`. –ê–∫–æ –∏—Å–∫–∞–º–µ –¥–æ—Å—Ç—ä–ø –¥–æ –≤—Å–∏—á–∫–∏ –ø—Ä–æ–ø—ä—Ä—Ç–∏—Ç–∞ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è, –º–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –º–µ—Ç–æ–¥–∞ `GetUserAsync()`:

```csharp
public async Task<IActionResult> Privacy()
{
    // Get the current ClaimsPrincipal object (authenticated user)
    var user = this.User;

    // Retrieve the full IdentityUser object (with all properties like email, user ID, etc.)
    var identityUser = await userManager.GetUserAsync(user);

    // You can now access properties of IdentityUser like identityUser.Email, identityUser.UserName, etc.

    return View();
}
```

–¢–∞–∑–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–µ–Ω –Ω–∞—á–∏–Ω –∑–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –¥–æ—Å—Ç—ä–ø–∞ –≤ ASP.NET Core –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.
# Misc
# ChatGPT
## Razor Pages
Razor Pages is a **server-side** programming model in **ASP.NET Core**. It combines the **view** (`.cshtml`) with its corresponding **logic** (in a C# class). The core idea is that each page has its own **logic** and **UI** bundled together, so it's easier to work with in scenarios where you don‚Äôt need the full overhead of the MVC (Model-View-Controller) pattern.

So, while a **Razor Page** refers to the **`.cshtml` file**, it's **tightly coupled** with a **PageModel** (C# class) that contains the logic for handling requests to that page.

**Key Concepts of Razor Pages:**

1. **Razor Page (`.cshtml`)**: This is the view, just like an MVC view, and contains HTML mixed with Razor syntax (to make it dynamic). However, the main difference is that this view is tied to a specific **PageModel**, not a controller.
    
2. **PageModel (`.cshtml.cs`)**: This is the C# class that contains the logic (like what happens when the page loads or when a form is submitted). The PageModel acts like a **controller** but is directly tied to a specific page.

**How Does Razor Pages Work?**

1. **Request to a URL**: When a user visits a page, like `/Product/Details`, the server looks for a Razor Page in the `Pages` directory, such as `Pages/Product/Details.cshtml`.
    
2. **PageModel Class**: If the Razor Page exists, ASP.NET Core looks for a **PageModel class** associated with it. The class will be named `DetailsModel` if the page is `Details.cshtml`. This class contains methods like `OnGet()` for handling GET requests or `OnPost()` for handling POST requests.
    
3. **Binding Data**: The **PageModel** class can receive data (like form submissions or route parameters), process it, and provide it to the view. For example, it can receive an `id` from the URL query string (`/Product/Details?id=1`), fetch data, and pass it to the Razor view for rendering.
    
4. **Rendering the View**: The Razor view (`Details.cshtml`) is rendered with any dynamic data (from the PageModel) and returned to the browser.

**Comparing Razor Pages to MVC**

|**Aspect**|**Razor Pages**|**MVC (Model-View-Controller)**|
|---|---|---|
|**Routing**|Routes to a file (e.g., `/Product/Details`)|Routes to a controller action (e.g., `HomeController.Index`)|
|**Logic and View**|Logic is in the `PageModel` (same folder)|Logic is in the controller (separate from the view)|
|**File Structure**|`.cshtml` (view) + `.cshtml.cs` (logic)|`.cshtml` (view) + controller (logic)|
|**Page-specific logic**|Each page has its own `PageModel` for handling logic|Logic is shared across multiple views (controllers)|
|**Data Binding**|Uses `@Model` to bind data from the PageModel|Uses `ViewModel` or `ViewBag` to bind data to the view|

**Example Walkthrough of Razor Pages**

Let‚Äôs walk through a basic example of a Razor Page.

**File Structure:**

```css
Pages/
‚îú‚îÄ‚îÄ Product/
‚îÇ   ‚îú‚îÄ‚îÄ Details.cshtml          ‚Üê Razor Page (UI)
‚îÇ   ‚îî‚îÄ‚îÄ Details.cshtml.cs       ‚Üê PageModel (logic)
```

`Details.cshtml` (View):

```csharp
@page
@model DetailsModel

<h1>Product Details</h1>
<p>Product ID: @Model.ProductId</p>
```

`Details.cshtml.cs` (PageModel):

```csharp
public class DetailsModel : PageModel
{
    // This property will be automatically populated with data
    public int ProductId { get; set; }

    // The OnGet method handles GET requests
    public void OnGet(int id)
    {
        // Simulate fetching data based on 'id'
        ProductId = id;
    }
}
```

**The Flow:**

1. **When a user visits `/Product/Details?id=5`:**
    
    - The Razor Page `Details.cshtml` is rendered.
        
    - The `DetailsModel` class is used to handle the request.
        
    - The `OnGet` method receives the `id` parameter from the URL and assigns it to `ProductId`.
        
    - `ProductId` is then available in the Razor view (`Details.cshtml`), and the page shows "Product ID: 5".

**Key Points to Remember:**

- Razor Pages are like **MVC Views**, but each page has its own **logic** and **view** bundled together in the same folder.
    
- Instead of having a separate controller and view, the logic for handling requests (like processing a form or reading a URL parameter) is handled in a **PageModel** class, which is closely associated with a specific Razor Page.

**Conclusion:**

So, to summarize:

- **Razor Pages** **are** `.cshtml` files, but they're not static like regular HTML files. They combine both **dynamic logic** (handled by the `PageModel`) and **UI** (the Razor view) into one cohesive page.
    
- The **PageModel** class contains the logic (like receiving parameters, processing data, etc.), and it‚Äôs tied directly to the Razor Page itself.
## Razor Pages Model Structure
In **Razor Pages**, models are typically declared **inside the `PageModel` class itself**, such as with `InputModel` for form binding. This differs from **MVC**, where models (especially view models) are usually defined in **separate classes**, encouraging a more modular structure. Razor Pages favor a more **page-centric** and **self-contained** approach.

**Example:**

```csharp
[BindProperty]
public InputModel Input { get; set; }

public class InputModel
{
    [Required]
    [EmailAddress]
    public string Email { get; set; }

    [Required]
    [DataType(DataType.Password)]
    public string Password { get; set; }

    public bool RememberMe { get; set; }
}
```

**‚úÖ Key Differences from MVC:**

| Aspect             | Razor Pages                            | MVC                                                    |
| ------------------ | -------------------------------------- | ------------------------------------------------------ |
| **ViewModel**      | Often nested inside `PageModel`        | Usually a **separate class** in a `ViewModels` folder  |
| **Binding**        | Uses `[BindProperty]`                  | Uses method parameters or `[Bind]`, `[FromForm]`, etc. |
| **File structure** | `.cshtml` + `.cshtml.cs` in one folder | `.cshtml` view + Controller action elsewhere           |
| **Approach**       | Page-focused (one page = one handler)  | Controller-focused (routes to actions)                 |

**üîç Why Razor Pages Do This**

The goal of Razor Pages is **simplification**. Instead of having a separate controller and a separate view model file, you often keep the model and logic **together** ‚Äî more like a "code-behind" model in WebForms or Blazor.

Would you like an example where we refactor the `InputModel` out into a separate class, as in traditional MVC?
## `UserManager<TUser>` is like a service layer
You can think of `UserManager` as a **built-in service class** provided by ASP.NET Core Identity. Just like you'd create your own service class to encapsulate business logic for an entity (e.g., `ProductService` for `Product`), `UserManager` encapsulates all the logic related to **managing users**.

**What `UserManager` does:**

It handles:

- Creating users (`CreateAsync`)
    
- Updating users
    
- Deleting users
    
- Adding/removing roles
    
- Managing claims
    
- Checking passwords
    
- Confirming emails
    
- And much more...

All this is done **through abstraction** ‚Äî it talks to the database under the hood via EF Core, so **you don‚Äôt have to manually write queries**.

**In short:**

- **Controller** ‚Üí calls ‚Üí **UserManager** ‚Üí performs logic and database operations.
    
- You don‚Äôt touch the `DbContext` directly for user management.
    
- `SignInManager` is a similar service, but for **login/authentication logic.**
## Razor Pages vs MVC Controllers
‚úÖ **What‚Äôs the Same:**

- **Model Binding**: Both Razor Pages and Controllers use model binding to map form values to C# objects.
    
- **Validation**: Both support `ModelState`, data annotations, and validation errors.
    
- **Return Views**: Both return views (`View()` or `Page()`) that use the provided model.

‚ùóÔ∏è**What‚Äôs Different:**

1. **Where the Model Ends Up**

- **In Razor Pages**:
    
- You typically define a property like:
        
```csharp
[BindProperty]
public RegisterInputModel Input { get; set; }
```
        
- The framework binds the form data _directly to this property_.
        
- When you return `Page()`, the Razor view gets the entire `PageModel` instance ‚Äî so `@model` refers to the class containing `Input`.
        
- **In MVC Controllers**:
    
- You usually pass the model as a method parameter:
        
```csharp
public IActionResult Register(RegisterInputModel model)
```
        
- If validation fails, you need to return the view with:
        
```csharp
return View(model);
```
        
- If you don‚Äôt pass it manually, the view has no way of knowing what model to use.

2. **Return Value Mechanics**

- `return Page();` in Razor Pages automatically gives the view access to `this` (i.e., the PageModel instance and its properties).
    
- `return View();` in MVC needs a model to be explicitly passed (unless you're using `ViewBag` or `ViewData`).

üß† **Summary**

|Feature|Razor Pages|MVC Controllers|
|---|---|---|
|Where model is stored|As a property on `PageModel`|As a parameter in action method|
|Model binding target|Bound to `[BindProperty]` field|Bound to method parameter|
|How model reaches the view|Via `PageModel` (`@model`)|Must pass explicitly to `View()`|
|Code + View separation|Mixed (code-behind + view)|Separated (Controller + View)|

_Conceptually_ they do the same thing, but Razor Pages streamline the pattern by tightly coupling the model and view into one unit.
## Razor Pages Routing
**Razor Pages do _not_ use the `MapControllerRoute` mapping**.

Here‚Äôs the breakdown:

‚úÖ **Razor Pages**

- **Routing is file- and folder-based**.
    
- Defined by:
    
    - The physical location of `.cshtml` files inside the `Pages` or `Areas/.../Pages` folder.
        
    - The `@page` directive (which can also accept a route template, like `@page "{id?}"`).
        
- Razor Pages routing is enabled by calling:

```csharp
app.MapRazorPages();
```

- `MapControllerRoute` **does not affect Razor Pages** at all.

‚úÖ **MVC Controllers**

- Routing is defined by templates like:

```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```

- This is used **only** for controllers and their actions.

**In short:**

|Feature|Razor Pages|MVC Controllers|
|---|---|---|
|Uses `MapControllerRoute`?|‚ùå No|‚úÖ Yes|
|Uses `MapRazorPages()`?|‚úÖ Yes|‚ùå No|
|Routing based on file structure?|‚úÖ Yes|‚ùå No|
|Uses `[Controller]` + `[Action]`?|‚ùå No|‚úÖ Yes|

So if you‚Äôre using Razor Pages and want to use custom route parameters, they must be defined directly using `@page` in the `.cshtml` file ‚Äî **the MVC route map won't apply**. The **Area** is like the **Controller**, and the **Page** is like the **Action** in the MVC world.

**To Recap:**

- **Area** = **Controller** in MVC (group of related pages).
    
- **Page** = **Action** in MVC (a specific page that handles a route).

This analogy helps you map out how to work with both Razor Pages and MVC within your application.
## Generic Type Specialization with Defaults
In ASP.NET, `IdentityUser` uses `string` as the default key type. Since it's actually a generic class, why don't we write `IdentityUser<string>` instead of just `IdentityUser`?

**ChatGPT said:**

Excellent question ‚Äî you're thinking about this **very precisely**, and you‚Äôve spotted something many overlook.

Let‚Äôs break it down clearly:

üß± **`IdentityUser` ‚Äì What's Actually Going On?**

Yes, you're right:  
By default, `IdentityUser` **uses a `string` as the primary key type** ‚Äî but it‚Äôs done **via inheritance**.

Here‚Äôs what actually happens under the hood:

```csharp
public class IdentityUser : IdentityUser<string>
{
    public IdentityUser() : base() { }
}
```

So `IdentityUser` is a _convenience class_ that simply wraps the generic `IdentityUser<TKey>` with `string` as the default key.

That‚Äôs why **you don‚Äôt need to write `IdentityUser<string>`** ‚Äî because the framework **already provides that as `IdentityUser`**.

üß© **Custom Key Types (like `Guid`)**

If you want to change the key type (e.g., to `Guid`), you then **have to drop the convenience wrapper** and explicitly write:

```csharp
public class ApplicationUser : IdentityUser<Guid>
{
    // Add your custom props
}
```

And then your context must match:

```csharp
public class WarehouseDbContext 
    : IdentityDbContext<ApplicationUser, IdentityRole<Guid>, Guid>
{
    // ...
}
```

üß† **Summary**

|Goal|Inherit From|Why|
|---|---|---|
|Use string as primary key (default)|`IdentityUser`|It wraps `IdentityUser<string>`|
|Use custom key like `Guid`|`IdentityUser<Guid>`|You must specify the key explicitly|
|Same applies to roles and context|`IdentityRole<Guid>`, etc.|Everything must use the same key|

So your insight is spot-on:

> `IdentityUser` is just a shorthand for `IdentityUser<string>`, and when you use other types like `Guid`, you must write it explicitly.

**You said:**

We have an identity class which inherits from the generic identity class and provides a concrete implementation of it ‚Äî string. Basically `IdentityUser` is a concrete class that inherits from the generic `IdentityUser<TKey>` with `string` as the default key. When we want a different key type, like `Guid`, we use the generic version. But how can both classes have the same name?

**ChatGPT said:**

Gerard ‚Äî that is _an excellent observation_. Let's unpack this in a clear and complete way.

‚úÖ **You're Exactly Right:**

> ‚ÄúWe have an identity class which inherits from the generic identity class and provides a concrete implementation of it ‚Äî string.‚Äù

Yes! That‚Äôs exactly what this is doing:

```csharp
public class IdentityUser : IdentityUser<string>
{
    public IdentityUser() : base() { }
}
```

‚ùì**But... How Do They Have the Same Name?**

This might seem like a naming conflict at first, but it **doesn‚Äôt break anything**, because of how **.NET generics and type overloading** work.

Here‚Äôs the key:

- `IdentityUser` ‚Üí non-generic class
    
- `IdentityUser<TKey>` ‚Üí _generic_ class

.NET (C# specifically) **treats them as two separate types** internally:

|Type Syntax|Treated As Internally|
|---|---|
|`IdentityUser`|`IdentityUser` (arity = 0)|
|`IdentityUser<TKey>`|`IdentityUser` (arity = 1)|

This is called **type overloading by arity** ‚Äî where `IdentityUser` and `IdentityUser<T>` are different symbols because they have different _numbers of generic parameters_.

So C# allows:

```csharp
public class IdentityUser : IdentityUser<string> { }
public class IdentityUser<TKey> { /* generic base */ }
```

Even though they look like the ‚Äúsame name,‚Äù the compiler sees one as:

- `IdentityUser` (no generics), and
    
- the other as `IdentityUser<T>` (one generic).

üß† **Real-World Analogy**

Think of this like method overloading:

```csharp
void Print() { }
void Print(string message) { }
```

Different parameters = different methods.

Same with types: different _generic arity_ = different types.

‚úÖ **In Summary**

- `IdentityUser<TKey>` is the base class.
    
- `IdentityUser` is a convenience class that just sets `TKey = string`.
    
- They can both exist because C# treats them as different due to arity (generic parameter count).

**You said:**

So `IdentityDbContext` is a generic type with different type parameters ‚Äî it's essentially using generic overloading through inheritance.

**ChatGPT said:**

Yes ‚Äî exactly right!

`IdentityDbContext` is a **generic class**, and just like `IdentityUser`, it uses **type overloading by arity**.

There are several overloads like:

```csharp
public class IdentityDbContext : IdentityDbContext<IdentityUser>
public class IdentityDbContext<TUser> : IdentityDbContext<TUser, IdentityRole, string>
public class IdentityDbContext<TUser, TRole, TKey> : DbContext
```

Each layer provides more customization:

- **`IdentityDbContext`** ‚Üí default `IdentityUser`, `IdentityRole`, and `string` key
    
- **`IdentityDbContext<TUser>`** ‚Üí custom user class
    
- **`IdentityDbContext<TUser, TRole, TKey>`** ‚Üí full control over user, role, and key type

So yes ‚Äî it‚Äôs the same technique: generic overloading with different arities.

**You said:**

`IdentityDbContext<TUser>` is a specialized version of the main generic class `IdentityDbContext<TUser, TRole, TKey>`, where only the user type is customizable, and the role and key types default to `IdentityRole` and `string`.

**ChatGPT said:**

Exactly ‚Äî you're spot on again.

To clarify your statement just a bit more precisely:

> `public class IdentityDbContext<TUser> : IdentityDbContext<TUser, IdentityRole, string>`

This means:

- It's a **specialization** (or shortcut) of the main generic class:

```csharp
public class IdentityDbContext<TUser, TRole, TKey> : DbContext
```

So yes ‚Äî both are **the same base class**, but the first version allows you to specify only `TUser`, while it **defaults** the role type to `IdentityRole` and key type to `string`.

Think of it like this:

```csharp
// Full control
IdentityDbContext<CustomUser, CustomRole, Guid>

// Partial control
IdentityDbContext<CustomUser> // uses IdentityRole and string as defaults

// No control (fully default)
IdentityDbContext // uses IdentityUser, IdentityRole, string
```

It's a clean way to give developers flexibility without always forcing them to supply all three types.

Would you like me to summarize all these overloads into a small table or hierarchy?

**You said:**

Basically, we start with the fully customizable generic class, and then create convenient presets on top of it for common use cases.

**ChatGPT said:**

Yes ‚Äî exactly! You‚Äôve nailed the concept.

The ASP.NET Identity team designed it like this:

- **Start with the full version**:

```csharp
public class IdentityDbContext<TUser, TRole, TKey> : DbContext
```

This is the most flexible base.
    
- **Then create convenient presets** that:
    
    - Reduce boilerplate
        
    - Cover common scenarios (like using `string` as a key)
        
    - Are easier to use for most developers

So:

```csharp
// Preset: default role and key type
public class IdentityDbContext<TUser> : IdentityDbContext<TUser, IdentityRole, string>

// Preset: default user, role, and key
public class IdentityDbContext : IdentityDbContext<IdentityUser, IdentityRole, string>
```

This pattern is common in .NET to balance **customization** with **ease of use**.

Want to see the same idea applied in other .NET types too (like `Dictionary`, `Task`, etc.)?
## Services Lifecycle
In .NET (and many other DI frameworks), services can be registered with different **lifetimes**, which determine whether a new instance is created each time or not.

Here are the common lifetimes in .NET:

üîÅ **Transient**

- **Behavior:** A new instance is created **every time** the service is requested.
    
- **Effect:** Yes, two classes will get **two different instances**.
    
- **Register with:** `services.AddTransient<IMyService, MyService>();`

‚ôªÔ∏è **Scoped**

- **Behavior:** A single instance is created per **request** (in web apps).
    
- **Effect:** Two classes in the **same HTTP request** will share the **same instance**. In **different requests**, they get different instances.
    
- **Register with:** `services.AddScoped<IMyService, MyService>();`

üõë **Singleton**

- **Behavior:** Only **one instance** is created for the **entire application lifetime**.
    
- **Effect:** All classes that depend on this service get the **same instance**, even across requests.
    
- **Register with:** `services.AddSingleton<IMyService, MyService>();`

**In Summary:**

If you register your service as `Transient` each class gets its own instance.  
If it's `Scoped` or `Singleton`, the same instance can be reused depending on scope.

**You said:**

These injections mainly happen in the controller classes? That's why we can have different instances across different requests?

**ChatGPT said:**

Exactly ‚Äî injections _typically_ happen in **controller classes**, **middleware**, or **services** that are registered in the DI container. Here's the key idea:

‚úÖ **Where injections happen**

- **Controllers** (most common): injected via constructor when a request comes in
    
- **Services**: injected into other services or controllers
    
- **Middleware components**: also can receive services via constructor

üîÅ **Why instances can differ across requests**

Each HTTP request creates a **new controller instance**, and depending on the **lifetime** of the injected service:

- **Transient**: a _new instance every time it's injected_, even within the same request
    
- **Scoped**: _one instance per request_, shared among everything in that request
    
- **Singleton**: _one instance for the entire app lifetime_, shared across all requests

üß† **Example scenario**

```csharp
// Registered as Scoped
services.AddScoped<IMyService, MyService>();
```

- Request A: Controller gets `MyService` with `ID = X`
    
- Request B: Controller gets `MyService` with `ID = Y`
    
- Same request (e.g., multiple services injected): all use `ID = X`

**You said:**

Is the controller object recreated each time in our app when a different HTTP request hits?

**ChatGPT said:**

Yes, the **controller object** is recreated for each HTTP request that hits your application.

When a new request comes in, the **ASP.NET Core framework** creates a new instance of the controller class to handle that request. This ensures that each request is handled independently, and controllers can manage their own state across requests.

**Key details:**

- **New Controller Per Request**: Every time a request comes in, a new instance of the controller is created to handle that request.
    
- **Dependency Injection (DI)**: While the controller is recreated for each request, the **services** injected into the controller (such as scoped or singleton services) may have different lifetimes, depending on their registration in the DI container.
    
    - **Scoped services**: Created once per request, shared within that request across the controller and other services.
        
    - **Singleton services**: Created once when the application starts and used across all requests.

**Example:**

Let's say we have a controller and a scoped service:

```csharp
public class MyController : Controller
{
    private readonly IMyService _myService;

    public MyController(IMyService myService)
    {
        _myService = myService;
    }

    public IActionResult Index()
    {
        var result = _myService.GetData();
        return View(result);
    }
}
```

And the `IMyService` is registered as scoped:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddScoped<IMyService, MyService>();
}
```

**What happens when a request comes in?**

- A **new instance of `MyController`** is created for each request.
    
- The **`IMyService`** is injected and a **new instance of `MyService`** is created once per request and shared within the request.

This allows each request to have its own instance of the controller and ensures that scoped services (like `IMyService`) are created and managed independently for each request.
## `UserStore`
The **`UserStore`** in ASP.NET Core Identity is a class that provides the **persistence logic** for user-related data. It's the bridge between the `UserManager<TUser>` and your **data source** (like a database).

**üîß What it does:**

`UserStore` implements interfaces like `IUserStore<TUser>`, `IUserPasswordStore<TUser>`, `IUserEmailStore<TUser>`, etc., which define methods for CRUD operations on user properties.

For example:

- `CreateAsync()` ‚Üí adds a user to the database.
    
- `FindByNameAsync()` ‚Üí fetches a user by username.
    
- `SetPasswordHashAsync()` ‚Üí sets a hashed password.
    
- `GetRolesAsync()` ‚Üí gets user roles.

üß± **Where is it used?**

It's typically registered with dependency injection during Identity setup:

```csharp
services.AddIdentity<ApplicationUser, IdentityRole>()
        .AddEntityFrameworkStores<ApplicationDbContext>();
```

In this example:

- `AddEntityFrameworkStores<ApplicationDbContext>()` registers `UserStore<ApplicationUser>` and `RoleStore<IdentityRole>` using EF Core under the hood.
    
- `UserManager` then uses this registered `UserStore` to save and retrieve user data.

üìù **Custom `UserStore`?**

You can implement your own `IUserStore<TUser>` if you're **not using Entity Framework** or want to persist users in:

- MongoDB
    
- Azure Table Storage
    
- A web API
    
- Flat files, etc.

‚úÖ **Why we need `UserStore` in ASP.NET Core Identity**

Think of **`UserManager<TUser>`** like a manager that handles higher-level user operations (like creating users, changing passwords, adding roles), but **it doesn‚Äôt know how to actually talk to the database**. That's the job of the `UserStore`.

**Analogy:**

Imagine `UserManager` is a **hotel receptionist**, and the `UserStore` is the **key cabinet** where the room keys (data) are actually stored. The receptionist knows how to handle a guest but always uses the cabinet to get or set anything.

üëá **What would happen without a `UserStore`?**

Without `UserStore`, `UserManager` wouldn‚Äôt know **how to fetch a user**, **how to save one**, or even **how to update their password**. It delegates those low-level operations to the `UserStore`, which contains **database-specific logic**.

So:

- `UserManager.CreateAsync(user, password)`  
    ‚Üí Calls `UserStore.CreateAsync(user)`  
    ‚Üí Saves the user in the DB (via EF Core or other)

- `UserManager.FindByNameAsync(username)`  
    ‚Üí Calls `UserStore.FindByNameAsync(username)`  
    ‚Üí Retrieves the user from the DB

‚öôÔ∏è **Why is this separation useful?**

It allows ASP.NET Identity to:

- Be **storage-agnostic**: it doesn't care if you're using EF Core, MongoDB, or something else.
    
- Be **testable**: you can mock the store in unit tests.
    
- Be **extensible**: you can write a custom `UserStore` for any kind of data source.

Let‚Äôs walk through what happens internally when you call:

```csharp
await userManager.CreateAsync(user, "Password123!");
```

üß† **Step-by-step breakdown**

1. **Password gets hashed**

`UserManager.CreateAsync(user, password)` first hashes the password using a configured password hasher:

```csharp
var hash = _passwordHasher.HashPassword(user, password);
user.PasswordHash = hash;
```

So now your user object has a `PasswordHash`.

2. **Validation is performed**

It checks:

- Is the username unique?
    
- Does the password meet the policy?
    
- Are all required fields filled?

```csharp
var errors = ValidateUser(user);
var pwdErrors = ValidatePassword(password);
```

If any validations fail, the method returns `IdentityResult.Failed(...)`.

3. **User is saved using the `UserStore`**

If validation passes, `UserManager` calls:

```csharp
await _userStore.CreateAsync(user, cancellationToken);
```

This is where the real storage happens.

üîç **And what is `_userStore`?**

Usually, it‚Äôs an instance of:

```csharp
UserStore<IdentityUser> : IUserStore<IdentityUser>, IUserPasswordStore<IdentityUser>, ...
```

That means it knows how to:

- Insert a user into your database (usually with Entity Framework Core)
    
- Set and retrieve passwords, emails, roles, etc.

Under the hood, this line typically looks like:

```csharp
_context.Users.Add(user); // _context is your EF DbContext
await _context.SaveChangesAsync();
```

4. **Final result is returned**

After the store saves the user, `UserManager` returns:

```csharp
IdentityResult.Success
```

**In other words:**

**`UserManager`** is the primary class you work with, but it does not handle how or where the data is stored. It delegates that responsibility to **UserStore**. For example, when you create a new user, **UserManager** will say to **UserStore**, _"I have a new user that needs to be saved. I don't know where or how you‚Äôll save it, just take care of it."_

The **`UserStore`** is responsible for the actual storage operations, including where the data is saved, which database is used, and how the data is handled. The default **UserStore** implementation uses **Entity Framework** and **SQL Server**, but if you need to use a different database like **MySQL**, you would need to use a different **UserStore** implementation.

This flexibility is one of the key features added in ASP.NET Core Identity, which allows it to work with different data stores. In contrast, **ASP.NET Membership** was tightly coupled to **SQL Server** and didn't provide this level of abstraction.

A similar concept applies to **`RoleManager`** and **`RoleStore`**, where **`RoleManager`** works with **`RoleStore`** to handle role data storage, maintaining the same separation of concerns.

he **`UserStore`** and **`RoleStore`** serve as **abstractions** that hide the complexities of how and where the data is actually stored. They act like **service layers** or **middlemen**, handling all the low-level data operations (like saving, retrieving, or deleting users and roles) without the **`UserManager`** or **`RoleManager`** needing to know the specific details about the database or data store being used.

This makes it easy to switch out the underlying storage system (for example, from SQL Server to MongoDB) without having to rewrite the logic in **`UserManager`** or **`RoleManager`**. You just plug in a new **`UserStore`** or **`RoleStore`** implementation that knows how to interact with the new database.

In short, they're like **service layer**: they handle the specifics, while the **`UserManager`** and **`RoleManager`** focus on the high-level logic of user and role management.

üí°**Summary**

|Layer|Responsibility|
|---|---|
|`UserManager`|Handles rules, validation, workflows|
|`UserStore`|Handles database logic (Create, Find, Update, etc.)|
|`DbContext`|The actual EF Core connection to your SQL Server|
## Cookies
‚úÖ What Happens When a User Logs In:

1. **User credentials are validated** (e.g., via `SignInManager.PasswordSignInAsync(...)`).
    
2. If the login is successful:
    
    - Identity **creates a cookie** that represents the authenticated user.
        
    - This is an **authentication cookie** and is **stored in the user's browser**.
        
3. On every subsequent request (GET, POST, etc.):
    
    - The browser **automatically sends this cookie** with the request.
        
    - The server **reads the cookie**, validates it, and knows which user is making the request.

üîê **What's Inside the Cookie?**

- It's **not** storing the entire user object.
    
- It contains an **encrypted and signed ticket** with user claims (like user ID, roles, etc.).
    
- ASP.NET Core uses middleware to **decrypt and validate** this on every request.

üß† **Summary:**

|Aspect|Details|
|---|---|
|Where the auth info is stored|In a **secure cookie** in the browser|
|When it is sent|Automatically with **every request** to the same domain|
|Who reads it|ASP.NET Core authentication middleware (before controller/page code)|
|Security|Encrypted, signed, uses HTTPS-only settings by default|

This is why once a user logs in, their identity is available through `User.Identity` in controllers or Razor Pages without needing to pass anything manually.
## User Object
The `User` object is **automatically injected** and is available by default in both **MVC controllers** and **Razor Pages** without any special configuration. This is part of the ASP.NET Core framework's built-in functionality to handle authentication and authorization.

- **In MVC controllers**, the `User` property is available on every action, giving you access to the authenticated user's information (such as their identity and claims).

- **In Razor Pages**, the `User` property is also available in the `PageModel` and in Razor views.

In both cases, the `User` property automatically provides access to the authenticated user's information, and you don't need to inject anything manually. It's part of the `HttpContext` that ASP.NET Core provides for each request. This makes it super convenient to use user-related data across your actions, pages, and views.
## Partial Views
Partial views in Razor are indeed just regular Razor views, but they are used to inject reusable UI elements into other views. The key difference is that partial views are not meant to be standalone pages. Instead, they are designed to be rendered as part of a larger view.

**Here's how partial views work:**

1. **Reusable UI Elements**: You can think of partial views as smaller pieces of a webpage‚Äîlike a header, footer, sidebar, or any other UI section that appears on multiple pages. These are components that are shared across different pages.
    
2. **Injected into Parent Views**: The partial view is rendered wherever you include the `<partial />` tag in the parent Razor page. The content of the partial view gets injected into the place where the `<partial />` tag is located.
    
3. **Rendering Mechanism**: When the page containing the `<partial />` tag is rendered, the Razor engine looks for the partial view (e.g., `_Privacy.cshtml`), and includes its content inside the parent view at the location of the tag.

**Example:**

Let‚Äôs break down an example:

`Home.cshtml` (Main View):

```html
<h1>Welcome to Our Website</h1>

<p>This is the main content of the page.</p>

<!-- Including the partial view here -->
<partial name="_Privacy" />
```

`_Privacy.cshtml` (Partial View):

```html
<div class="privacy-policy">
    <h2>Privacy Policy</h2>
    <p>This is our privacy policy content.</p>
</div>
```

**What Happens:**

- When the `Home.cshtml` view is rendered, it will include the content from `_Privacy.cshtml` where the `<partial name="_Privacy" />` tag is placed.
    
- The `_Privacy.cshtml` view will not be a standalone page but will be rendered as part of the larger `Home.cshtml` page.

**Key Points:**

- **Partial views** are **not full pages**; they are just fragments or reusable parts of a page.
    
- The `<partial />` tag is used to **render these fragments** within the parent view.
    
- They help you keep your views DRY (Don't Repeat Yourself) by allowing you to reuse common elements across multiple pages.

In summary: partial views allow you to inject specific parts of a page into a parent Razor page, which helps with reusability and modular design.
# Bookmarks
[Introduction to Identity on ASP.NET Core | Microsoft Learn](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-9.0&tabs=visual-studio)

Completion: 03.05.2025