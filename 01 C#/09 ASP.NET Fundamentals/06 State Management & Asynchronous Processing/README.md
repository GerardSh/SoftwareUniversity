# General
## HTTP Cookies
Малък файл с обикновен текст без изпълним код.
- Изпратен от сървъра до браузъра на клиента.
- Съхраняван от браузъра на устройството на клиента (компютър, таблет и т.н.). Това е едно от малкото неща, които можем да запишем с цел осигуряване на сигурността на потребителската машина.
- Съдържа малко количество данни за конкретен клиент и уебсайт.

Сървърът създава кукита, които изпраща към браузъра, а той ги връща обратно на всеки следващ рекуест. Вътре в кукито има двойки ключ-стойност (key-value pairs).

Според GDPR и директивата ePrivacy, трябва да уведомяваме потребителите, че използваме кукита, и да получаваме тяхното съгласие, преди да ги събираме. Това обикновено става чрез банер, който информира потребителите и им позволява да управляват предпочитанията си за кукитата. Като се съгласим да ползваме куки, дори тази информация се записва в куки.

Принципно има ограничение в размера на кукитата, но съвременните браузъри решават проблема, като ги разпадат на повече части. Така можем да съберем много голяма информация в кукитата, но не е желателно, тъй като това увеличава размера на рекуеста.

Реално информацията в кукито са неща, които сървъра трябва да помни за нас. Понеже HTTP протокола е stateless - не помни нищо. Каквото и да е имало в даден рекуест, то е загубено в следващия. След първия рекуест, на следващия сървъра вече не помни нищо за нас. Кукито се явява като work around, като в него записваме нещата, които искаме да бъдат запомнени за нас.
### Usage
1. Управление на сесии - това е най-честата употреба на кукита, като също се използват за колички за пазаруване, резултати от игри или всичко друго, което сървърът трябва да запомни.  Те могат да съхраняват информация за самия потребител, като кой е логнат, заедно с неговите допълнителни свойства. В тях се намират така наречените клейма (claims), като напоследък **claim-based identity** се използва от всички, включително и от ASP.NET. Когато се логваме някъде, някой проверява дали имаме право да се идентифицираме, като първо се проверява даден критерий, като потребителско име и парола. След като се установи, че сме ние, се проверява дали има допълнителна информация, например имейл, имена, роля и друга информация. Понеже вече сме идентифицирани и се знае кои сме, системата може да твърди, че ние сме този човек и имаме съответната информация. Въпросният провайдър, независимо кой е той, издава клеймата (claims) — твърдения за нас. Например: първо твърдение — това е името на човека, второ твърдение — той е администратор и т.н. Провайдърът записва тези твърдения в кукито и оттук нататък, всеки път, когато това куки се върне към сървъра, той ще знае тези твърдения. Няма нужда да ги проверява, защото има вяра в провайдъра и неговите твърдения. Всички тези твърдения се приемат за верни, докато кукито е валидно. В момента, в който изтече или бъде анулирано (например при **sign out**), сървърът забравя тези данни, защото не ги съхранява на друго място.

2. Персонализация - потребителски предпочитания, теми и други персонализирани настройки.

3. Проследяване - записване и анализиране на потребителско поведение. Може да се записва информация за самата активност в браузъра, като например колко хора са посетили дадена страница и колко време са се задържали на нея. Тази информация ни дава възможност да преценим кое е интересно за клиентите и кое не се посещава, като така можем да оптимизираме съдържанието и функционалността на сайта.

4. Да пазим информация, която преди това е била въведена във форма, е една от основните функции на кукитата и сесиите. Когато потребителят попълни форма и я изпрати, сървърът може да запише определена част от информацията (например потребителски имена, настройки или предпочитания) в кукита или сесийни данни, за да я запази и да я използва в бъдеще, без да се налага потребителят да въвежда отново същите данни.
### Stateless HTTP - The Problem
Сървърът не знае дали два рекуеста идват от един и същ клиент, което води до проблеми:

За всяка операция, която искаме да извършим на даден сайт, трябва да се автентикираме отново.

Друга необходима информация като количка с покупки, запазени резултати от игри, или вече сме избрали нещо на страницата, при следващия рекуест то изчезва и тн.

Няма как да се персонализира страницата.
### Stateless HTTP - The Cookie Solution
Въпреки че HTTP протоколът е **stateless**, той има механизъм за запомняне, наречен **cookie**. Чрез кукито сървърът може да помни състоянието между рекуестите. Например, когато се логнем с даден рекуест и сървърът ни върне отговор, той може да ни изпрати куки, в което е записано кой сме. В следващия рекуест, когато върнем кукито към сървъра, той вече знае кой се обръща към него, като чете информацията в кукито.

Куки и сесии често се комбинират, защото може да имаме куки, което съдържа само идентификатор на сесия. Сървърът знае откъде да извлече тази сесия, която обикновено се пази на сървъра. Важно е обаче **къде** точно се съхранява тази информация, защото това определя сигурността и достъпността на сесийните данни.
### How Are Cookies Used
Отговорът на сървъра съдържа куки, което бива запазено, чрез **Set-Cookie** header:

```
HTTP/1.1 200 OK
Set-Cookie: lang=en
```

Заявката от клиента съдържа съответното куки, което изпраща към сървъра, чрез **Cookie** header-a, ако е направена към същия domain:

```
GET www.example.bg HTTP/1.1
Cookie: lang=en
```

Това означава, че при всяко следващо посещение на същия сайт, браузърът изпраща кукито обратно към сървъра, за да може той да запомни предишните настройки, като например избран език (в случая `lang=en`).

Така, сървърът изпраща информация за куки, което браузърът запазва, а при следващите рекуести браузърът връща тези кукита обратно към сървъра.

Когато браузърът получи куки от даден сайт, той ги запазва локално. При всяко следващо искане към този същия домейн, браузърът автоматично включва съответните кукита в **Cookie** header-а на заявката. Това позволява на сървъра да "помни" информация като идентификация на потребителя или настройки. Това гарантира, че само правилните кукита ще бъдат изпращани на сървъра за съответния домейн.
### Cookie Structure
Кукито се състои от **Name**, **Value** и **Attributes** (по избор).

Атрибутите са **ключ-стойност** двойки с допълнителна информация.

Атрибутите не се включват в заявките.

Атрибутите се използват от клиента за управление на кукитата - да кажат на клиента, какво трябва да направи с даденото куки.

Пример за Set-Cookie header:

```
Set-Cookie: SSID=Ap4P…GTEq; Domain=foo.com; Path=/;
Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly
```

Обяснение на атрибутите:

- **`SSID=Ap4P…GTEq`**: Това е информацията, която ще се препраща към всеки рекуест.

- **Domain=foo.com**: Кукито ще бъде изпратено само на домейна **foo.com**.

- **Path=/**: Кукито ще бъде изпратено за всички пътища на домейна.

- **Expires**: Определя кога кукито ще изтече. Ако не е зададено, кукито ще изтече при затваряне на браузъра.

- **Secure**: Кукито ще бъде изпратено само по сигурни (HTTPS) връзки.

- **`HttpOnly`**: Кукито не може да бъде достъпно чрез JavaScript, като се защитава от XSS атаки.
### Scope
Означава областта, в която действа дадено нещо. Когато говорим за кукита, ние определяме обхвата им чрез домейна (domain) и пътя (path). Целта е да гарантираме, че кукито няма да бъде изпратено към друг. Ако искаме то да бъде валидно само за определена част от нашето приложение, уточняваме пътя, като всички страници под този път в йерархията също ще получават кукито. По този начин може да разграничим, ако примерно имаме две area на нашето приложение - една администраторска и една потребителска, кукито да важи само за една от тях, рядко се налага. По честно кукитата са на основния път, но принципно е възможно.

- Domain – посочва уебсайта, към който принадлежи кукито. Ние така указваме кой сървър трябва да го получава.

- Path – указва пътя в URL-а, който трябва да съществува в заявката, за да бъде изпратен Cookie header-ът. С това ние ограничаваме действието на кукито само до определена част от приложението.

```
Set-Cookie: SSID=Ap4P…GTEq; Domain=foo.com; Path=/;
Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly
```
### Lifetime
Куки файловете имат срок на действие, който се определя от атрибутите Expires и Max-Age.

- Expires – определя датата, на която браузърът трябва да изтрие кукито.

- По подразбиране куки файловете се изтриват в края на сесията. Браузърите обикновено приемат за край на сесията затварянето на целия браузър, а не само на таба. Въпреки това, това не винаги е гарантирано, тъй като някои браузъри могат да поддържат сесии активни дори след затваряне на прозореца.

- Max-Age – интервал от секунди, след който кукито ще бъде изтрито.

```
Set-Cookie: SSID=Ap4P…GTEq; Domain=foo.com; Path=/;
Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly
```
### Security
Сигурността на кукитата се постига чрез използване на специални флагове, които нямат стойности, а само указания за браузъра:

- **Secure** – указва на браузъра да използва кукитата само през сигурни/шифровани връзки (например HTTPS).

- **`HttpOnly`** – определя, че кукито не може да бъде достъпвано чрез клиентски езици за скриптиране като JavaScript.

Пример за Set-Cookie header с тези атрибути:

```
Set-Cookie: SSID=Ap4P…GTEq; Domain=foo.com; Path=/; Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly
```
### What is in the Cookie
Кукито е малък файл, съдържащ таблица с двойки **ключ-стойност**, които се използват за съхранение на информация, която сървърът и браузърът обменят. Всяка двойка ключ-стойност представлява конкретна информация, свързана с потребителската сесия, като например идентификатор на сесия или предпочитания за език.

Тази таблица от ключове и стойности се изпраща обратно към сървъра с всяка следваща заявка от същия клиент към сървъра, което позволява на сървъра да "помни" данни за клиента.

**Example Table:**

| **Attribute**            | **Value**                                 |
| ------------------------ | ----------------------------------------- |
| **Name**                 | ELOQUA                                    |
| **Content**              | GUID=50B3A712CDAA4A208FE95CE1F2BA7063     |
| **Domain**               | .oracle.com                               |
| **Path**                 | /                                         |
| **Send for**             | Any kind of connection                    |
| **Accessible to script** | Yes                                       |
| **Created**              | Monday, August 15, 2016 at 11:38:50 PM    |
| **Expires**              | Wednesday, August 15, 2018 at 11:38:51 PM |
### How to View Cookies
В **Google Chrome** можем да видим кукитата, като следваме тези стъпки:

1. Натискаме **F12** или **Ctrl + Shift + I**, за да отворим инструментите за разработчици.

2. Отиваме в таба **Application** (горе в инструментите).

3. В лявото меню избираме **Cookies** и след това кликваме на домейна, за който искаме да видим кукитата.

4. Ще се появи списък с всички кукита, които сървърът е изпратил за този домейн.

Там можем да видим детайли за всяко куки, като име, стойност, дата на изтичане и други атрибути.
### Third Party Cookies
Бисквитките на трети страни са бисквитки, поставени от домейн, различен от този на уебсайта, който посещаваме. Те се използват основно за реклама и проследяване на активността ни в интернет. Когато посетим сайт, външни мрежи, като рекламни услуги, могат да поставят бисквитки в браузъра ни.

**Как работят:**

1. Посещаваме сайт.

2. Външни източници (като рекламни мрежи) поставят бисквитки.

3. Те проследяват поведението ни през различни сайтове.

Проблеми с конфиденциалността:

- Могат да проследяват поведението ни без нашето съгласие.

- Някои браузъри ги блокират по подразбиране за защита на конфиденциалността.

**Регулации:**

- Законодателства като GDPR изискват съгласие за поставяне на тези бисквитки.

Общо взето, бисквитките на трети страни се използват за проследяване и таргетиране на реклами, но имат проблеми с конфиденциалността, което води до регулации и блокиране от браузъри.
## HTTP Sessions
**Сесии** са начин за съхранение на информация за потребител, която да бъде използвана през множество страници в уеб приложение. Тази информация се запазва през цялото време на взаимодействието на потребителя с уебсайта, дори когато той навигира между различни страници, като например `/login`, `/home`, и `/products`.

**Какво са сесиите?**

- **Сесиите** позволяват на уеб приложението да проследява дейността и състоянието на потребителя през множество страници, без да е необходимо да се въвеждат или изпращат отново данни.

- Обикновено, **сесията** съхранява данни като автентикация на потребителя (например дали потребителят е влязъл в системата) или други предпочитания (като съдържание в пазарска количка).

- Сесиите обикновено се съхраняват на сървъра, а **идентификаторът на сесията** се изпраща към клиента (обикновено като бисквитка), за да свърже потребителя с данните, съхранени на сървъра. Възможно е също да се изпрати като параметър в заявката (например в **URL**), но това носи сериозен риск, тъй като сесийните данни могат да бъдат видими в адресната лента, логове или дори да бъдат подслушвани от неоторизирани лица. Това може да доведе до кражба на сесията чрез атаки като **session fixation** или **session hijacking**.

**Пример:**

Потребителят **Тео** влиза в уеб приложение:

1. **Страница за вход**: Потребителят влиза на `/login`. Създава се сесия на сървъра и на **Тео** се присвоява уникален идентификатор на сесията.

2. **Начална страница**: Когато **Тео** премине към `/home`, идентификаторът на сесията се изпраща с заявката, което позволява на сървъра да идентифицира, че сесията принадлежи на **Тео**.

3. **Страница с продукти**: На `/products` сървърът използва идентификатора на сесията, за да разбере, че **Тео** е все още влязъл в системата, и може да покаже персонализирано съдържание или препоръки за продукти.

**Как работи:**

- **Идентификатор на сесията**: Когато **Тео** влиза в системата, сървърът създава уникален идентификатор на сесията, който се съхранява като бисквитка в браузъра на **Тео**.

- Докато **Тео** навигира между страници (например `/home`, `/products`), идентификаторът на сесията се изпраща обратно към сървъра, което позволява на сървъра да свърже действията с текущата сесия на **Тео** и да извлече съответната информация.

**Съхранение на сесията:**

- Сесията може да съхранява всякаква съответна информация, като името на потребителя (например **Тео**), статус на влизане, предпочитания на потребителя или други данни, които могат да бъдат използвани през различните страници на уеб приложението.

В обобщение, **сесията** гарантира, че информацията за потребителя (като идентичността на **Тео**) се запазва през множество страници в уеб приложението, без да е необходимо потребителят да влиза отново или да въвежда данни многократно.
### Relation with Cookies
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250429145908.png)

При този вариант се създава нов идентификатор на сесия, където вече седи истинския идентификатор на потребителя. Проблема е че процеса е тежък и е на две стъпки - само за да разберем информацията на потребителя, трябва веднъж да минем през session store и след това да минем през базата да видим кой е потребителя и чак след това се минава отново през базата за да се свърши работа. Това не е много оптимален вариант.

По-чистият и сигурен подход е, когато срещу нашия **идентификатор за сесия** съхраняваме **цялата информация за потребителя** на сървъра, а не я предаваме към клиента. Обикновено това се реализира чрез **in-memory бази** като Redis, които позволяват бърз достъп до сесийните данни и лесно мащабиране при голям брой потребители, без да се компрометира сигурността.
### Sessions vs Cookies
| Feature              | Cookies                                                       | Sessions                                          |
| -------------------- | ------------------------------------------------------------- | ------------------------------------------------- |
| **Storage Location** | Съхраняват се на компютъра на потребителя (като текстов файл) | Съхраняват се на сървъра                          |
| **Expiration**       | Изтичат на зададена дата                                      | Изтичат при затваряне на браузъра                 |
| **Data Capacity**    | Могат да съхраняват ограничено количество данни               | Могат да съхраняват неограничено количество данни |
| **Dependency**       | Не зависят от сесията                                         | Зависят от кукито (обикновено session ID)         |
| **Security**         | По-слаба сигурност – съхраняват се в обикновен текст          | По-висока сигурност – данните са криптирани       |
| **Accessibility**    | Лесно достъпни от всеки                                       | Не могат да бъдат достъпени лесно                 |
Ако съхраняваме сесиите само на сървъра (в паметта му), при наличие на няколко сървъра (напр. 5), потребителят ще бъде свързан само с този сървър, на който е създадена сесията. Ако по-късно заявката му попадне на друг сървър, сесията няма да бъде намерена и ще изглежда като че не е логнат. Затова при scaled приложения се използва споделен storage (напр. Redis), достъпно от всички сървъри.

Сесията съхранява информация за потребителя на сървъра, а не в бисквитките. Куките се използват само за съхранение на **идентификатора на сесията**, който свързва потребителя със сървърната информация.

Трябва да задаваме **срок на валидност (expiration)** на сесиите, за да избегнем т.нар. **„зомби сесии“**. Когато потребителят затвори браузъра, бисквитката със session ID може да се изтрие, но сървърът не получава сигнал за това и продължава да съхранява сесията. Затова е добре да ползваме **sliding expiration** – например, при живот от 30 минути, ако потребителят изпрати заявка на 15-тата минута, времето се удължава с още 30 минути.

Как работи:

1. Потребителят влиза в системата и получава **`session_id`**, който се съхранява в браузъра като бисквитка.

2. При всяка заявка, браузърът изпраща **`session_id`** към сървъра.

3. Сървърът използва този идентификатор, за да извлече данни за потребителя (например настройки, състояние на вход и т.н.).

**Как се съхранява информацията:**

- **В паметта на сървъра** (RAM) за бързо и временно съхранение.

- **В база данни**, ако информацията трябва да се съхранява постоянно.

- **Във външни хранилища** като **Redis**, ако има множество сървъри.

**Предимства:**

- Безопасност: Данните се съхраняват на сървъра и не могат да бъдат променяни от потребителя.

- Може да се съхраняват повече и по-сигурни данни в сравнение с куки.

Основната разлика е:

- **В куки** съхраняваме **цялата информация** за потребителя (например данни за влизане, настройки и т.н.), което може да бъде уязвимо и да увеличи размера на куките.

- **В сесии** съхраняваме само **идентификатора на сесията (`session_id`)** в куки, който указва на сървъра коя информация принадлежи на конкретния потребител. Всичката същинска информация се съхранява **на сървъра**, което е по-сигурно и по-ефективно.
## Synchronous Programming
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250429171514.png)

Изпълнение на програмни компоненти един след друг.

Всяко действие се случва след предходното.

Компонентите изчакват завършването на предишните.

Ресурсите на програмата са достъпни през цялото време, тъй като изпълнението е последователно и всяка част от кода има достъп до резултатите от предишните стъпки. Информацията от Task 1 може да бъде ползвана в следващите таскове, където решим. Това не е валидно, когато имаме паралелна обработка.
### Drawbacks
**Ако един компонент е блокиран, цялата програма е блокирана**  
    В синхронно програмиране, ако един компонент трябва да изчака (например поради забавяне в мрежова връзка или файлови операции), това ще блокира изпълнението на целия процес, докато не се приключи с него.

**Потребителският интерфейс може да стане unresponsive**  
    Ако програмата блокира по време на синхронни операции, интерфейсът може да спре да реагира на действия на потребителя, като например натискания на бутони или въвеждане на текст.

**Не се използват всички ядра на процесора**  
    В синхронно изпълнение, само едно ядро от процесора се използва по време на изпълнение на програмата, което означава, че програмата не се възползва от възможностите за паралелна обработка, които предлагат многопроцесорните системи.

**Задачи, изискващи голямо натоварване на процесора, забавят изпълнението на всички други задачи**  
    Ако има тежки операции (например сложни изчисления), те могат да блокират изпълнението на други части от програмата, което води до значително забавяне.

**Достъпът до ресурси блокира цялата програма**  
    Достъпът до външни ресурси като файлове или мрежови връзки също може да блокира програмата, докато се изчака отговорът от сървъра или операцията с файла.

**Особено проблемно при използване на уеб ресурси**  
    Програмите, които зависят от уеб заявки (например API извиквания), може да блокират всичко, докато се изчака отговор от сървъра. Това е особено проблемно за UX, когато се използват уеб приложения, които се нуждаят от незабавна реакция на потребителя.
## Asynchronous Programming
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250429213543.png)

**Компонентите на програмата могат да се изпълняват паралелно**  
	Частите на програмата не се изпълняват задължително една след друга, а могат да вървят едновременно.

**Някои действия се изпълняват едновременно с други**  
	Примерно четене от файл и показване на прогрес може да се случват паралелно.

**Всяко действие може да се изпълнява в отделна нишка**  
	Това позволява на програмата да използва по-добре процесора, като разпределя задачите в различни ядра.

**Независимите компоненти не изчакват изпълнението на останалите**  
	Ако една задача не зависи от друга, тя може да се изпълни веднага, без да чака другите да приключат. За да ги пуснем на отделни нишки, тасковете не трябва да зависят един от друг – не трябва резултатът от единия да е нужен за работата на втория. Ако има такава зависимост, задачите трябва да се изпълнят в една нишка, защото няма смисъл да са в различни. Изключение е, ако искаме да освободим главната нишка за нещо друго – тогава можем да ги изкараме в две нишки.

**Ресурсите на програмата се споделят между нишките**  
	Променливи, файлове или база данни могат да се използват от различни нишки едновременно.

**Ако една нишка използва даден ресурс, другите не трябва да го използват едновременно**  
	Това е нужно, за да се избегнат конфликти, загуба на данни или непредвидено поведение в програмата.
# Misc
# ChatGPT
## 🧵 What is a thread

A **thread** is the smallest unit of execution in a program. You can think of it as a **separate worker** doing a specific task. All threads within the same program **share the same memory (resources)**, but each thread has its own **execution context** — meaning it knows what it’s doing and where it left off.

🧠 **What is the main thread?**

When a program starts, it begins with a **main thread** by default.  
If you don’t create any additional threads, **everything runs sequentially inside that main thread**.

🤝 **How do threads correlate or interact?**

- **They share resources**: All threads have access to the same memory — variables, files, databases.

- **They can block each other**, if two threads try to access the same resource at the same time without coordination → this leads to issues like race conditions or deadlocks.

- **Synchronization** is needed when threads need to communicate or coordinate — using tools like `lock`, `mutex`, `await`, `join`, `signal`, etc.

📌 **What’s the difference between the main thread and other threads?**

|**Main Thread**|**Other (Secondary) Threads**|
|---|---|
|Starts automatically|Created manually or via libraries|
|Runs the main program code|Handle specific parallel tasks|
|If it finishes, the program ends|Can end independently|
|Shouldn't be blocked for long tasks|Help offload work from the main thread|

🧠 **Analogy:**

Imagine the main thread is a **receptionist** in an office.  
If they have to do everything — answer calls, print documents, make coffee — productivity drops.  
But if you bring in **helpers (threads)** for certain tasks, the receptionist (main thread) can focus on the most important things.
# Bookmarks
Completion: 30.04.2025