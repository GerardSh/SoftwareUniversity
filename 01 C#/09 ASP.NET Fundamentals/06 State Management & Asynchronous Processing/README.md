# General
## HTTP Cookies
–ú–∞–ª—ä–∫ —Ñ–∞–π–ª —Å –æ–±–∏–∫–Ω–æ–≤–µ–Ω —Ç–µ–∫—Å—Ç –±–µ–∑ –∏–∑–ø—ä–ª–Ω–∏–º –∫–æ–¥.
- –ò–∑–ø—Ä–∞—Ç–µ–Ω –æ—Ç —Å—ä—Ä–≤—ä—Ä–∞ –¥–æ –±—Ä–∞—É–∑—ä—Ä–∞ –Ω–∞ –∫–ª–∏–µ–Ω—Ç–∞.
- –°—ä—Ö—Ä–∞–Ω—è–≤–∞–Ω –æ—Ç –±—Ä–∞—É–∑—ä—Ä–∞ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ—Ç–æ –Ω–∞ –∫–ª–∏–µ–Ω—Ç–∞ (–∫–æ–º–ø—é—Ç—ä—Ä, —Ç–∞–±–ª–µ—Ç –∏ —Ç.–Ω.). –¢–æ–≤–∞ –µ –µ–¥–Ω–æ –æ—Ç –º–∞–ª–∫–æ—Ç–æ –Ω–µ—â–∞, –∫–æ–∏—Ç–æ –º–æ–∂–µ–º –¥–∞ –∑–∞–ø–∏—à–µ–º —Å —Ü–µ–ª –æ—Å–∏–≥—É—Ä—è–≤–∞–Ω–µ –Ω–∞ —Å–∏–≥—É—Ä–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∞—Ç–∞ –º–∞—à–∏–Ω–∞.
- –°—ä–¥—ä—Ä–∂–∞ –º–∞–ª–∫–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω–∏ –∑–∞ –∫–æ–Ω–∫—Ä–µ—Ç–µ–Ω –∫–ª–∏–µ–Ω—Ç –∏ —É–µ–±—Å–∞–π—Ç.

–°—ä—Ä–≤—ä—Ä—ä—Ç —Å—ä–∑–¥–∞–≤–∞ –∫—É–∫–∏—Ç–∞, –∫–æ–∏—Ç–æ –∏–∑–ø—Ä–∞—â–∞ –∫—ä–º –±—Ä–∞—É–∑—ä—Ä–∞, –∞ —Ç–æ–π –≥–∏ –≤—Ä—ä—â–∞ –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ –≤—Å–µ–∫–∏ —Å–ª–µ–¥–≤–∞—â —Ä–µ–∫—É–µ—Å—Ç. –í—ä—Ç—Ä–µ –≤ –∫—É–∫–∏—Ç–æ –∏–º–∞ –¥–≤–æ–π–∫–∏ –∫–ª—é—á-—Å—Ç–æ–π–Ω–æ—Å—Ç (key-value pairs).

–°–ø–æ—Ä–µ–¥ GDPR –∏ –¥–∏—Ä–µ–∫—Ç–∏–≤–∞—Ç–∞ ePrivacy, —Ç—Ä—è–±–≤–∞ –¥–∞ —É–≤–µ–¥–æ–º—è–≤–∞–º–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ, —á–µ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –∫—É–∫–∏—Ç–∞, –∏ –¥–∞ –ø–æ–ª—É—á–∞–≤–∞–º–µ —Ç—è—Ö–Ω–æ—Ç–æ —Å—ä–≥–ª–∞—Å–∏–µ, –ø—Ä–µ–¥–∏ –¥–∞ –≥–∏ —Å—ä–±–∏—Ä–∞–º–µ. –¢–æ–≤–∞ –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Å—Ç–∞–≤–∞ —á—Ä–µ–∑ –±–∞–Ω–µ—Ä, –∫–æ–π—Ç–æ –∏–Ω—Ñ–æ—Ä–º–∏—Ä–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏—Ç–µ –∏ –∏–º –ø–æ–∑–≤–æ–ª—è–≤–∞ –¥–∞ —É–ø—Ä–∞–≤–ª—è–≤–∞—Ç –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–Ω–∏—è—Ç–∞ —Å–∏ –∑–∞ –∫—É–∫–∏—Ç–∞—Ç–∞. –ö–∞—Ç–æ —Å–µ —Å—ä–≥–ª–∞—Å–∏–º –¥–∞ –ø–æ–ª–∑–≤–∞–º–µ –∫—É–∫–∏, –¥–æ—Ä–∏ —Ç–∞–∑–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è —Å–µ –∑–∞–ø–∏—Å–≤–∞ –≤ –∫—É–∫–∏.

–ü—Ä–∏–Ω—Ü–∏–ø–Ω–æ –∏–º–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤ —Ä–∞–∑–º–µ—Ä–∞ –Ω–∞ –∫—É–∫–∏—Ç–∞—Ç–∞, –Ω–æ —Å—ä–≤—Ä–µ–º–µ–Ω–Ω–∏—Ç–µ –±—Ä–∞—É–∑—ä—Ä–∏ —Ä–µ—à–∞–≤–∞—Ç –ø—Ä–æ–±–ª–µ–º–∞, –∫–∞—Ç–æ –≥–∏ —Ä–∞–∑–ø–∞–¥–∞—Ç –Ω–∞ –ø–æ–≤–µ—á–µ —á–∞—Å—Ç–∏. –¢–∞–∫–∞ –º–æ–∂–µ–º –¥–∞ —Å—ä–±–µ—Ä–µ–º –º–Ω–æ–≥–æ –≥–æ–ª—è–º–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –≤ –∫—É–∫–∏—Ç–∞—Ç–∞, –Ω–æ –Ω–µ –µ –∂–µ–ª–∞—Ç–µ–ª–Ω–æ, —Ç—ä–π –∫–∞—Ç–æ —Ç–æ–≤–∞ —É–≤–µ–ª–∏—á–∞–≤–∞ —Ä–∞–∑–º–µ—Ä–∞ –Ω–∞ —Ä–µ–∫—É–µ—Å—Ç–∞.

–†–µ–∞–ª–Ω–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è—Ç–∞ –≤ –∫—É–∫–∏—Ç–æ —Å–∞ –Ω–µ—â–∞, –∫–æ–∏—Ç–æ —Å—ä—Ä–≤—ä—Ä–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ –ø–æ–º–Ω–∏ –∑–∞ –Ω–∞—Å. –ü–æ–Ω–µ–∂–µ HTTP –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –µ stateless - –Ω–µ –ø–æ–º–Ω–∏ –Ω–∏—â–æ. –ö–∞–∫–≤–æ—Ç–æ –∏ –¥–∞ –µ –∏–º–∞–ª–æ –≤ –¥–∞–¥–µ–Ω —Ä–µ–∫—É–µ—Å—Ç, —Ç–æ –µ –∑–∞–≥—É–±–µ–Ω–æ –≤ —Å–ª–µ–¥–≤–∞—â–∏—è. –°–ª–µ–¥ –ø—ä—Ä–≤–∏—è —Ä–µ–∫—É–µ—Å—Ç, –Ω–∞ —Å–ª–µ–¥–≤–∞—â–∏—è —Å—ä—Ä–≤—ä—Ä–∞ –≤–µ—á–µ –Ω–µ –ø–æ–º–Ω–∏ –Ω–∏—â–æ –∑–∞ –Ω–∞—Å. –ö—É–∫–∏—Ç–æ —Å–µ —è–≤—è–≤–∞ –∫–∞—Ç–æ work around, –∫–∞—Ç–æ –≤ –Ω–µ–≥–æ –∑–∞–ø–∏—Å–≤–∞–º–µ –Ω–µ—â–∞—Ç–∞, –∫–æ–∏—Ç–æ –∏—Å–∫–∞–º–µ –¥–∞ –±—ä–¥–∞—Ç –∑–∞–ø–æ–º–Ω–µ–Ω–∏ –∑–∞ –Ω–∞—Å.
### Usage
1. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ —Å–µ—Å–∏–∏ - —Ç–æ–≤–∞ –µ –Ω–∞–π-—á–µ—Å—Ç–∞—Ç–∞ —É–ø–æ—Ç—Ä–µ–±–∞ –Ω–∞ –∫—É–∫–∏—Ç–∞, –∫–∞—Ç–æ —Å—ä—â–æ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –∑–∞ –∫–æ–ª–∏—á–∫–∏ –∑–∞ –ø–∞–∑–∞—Ä—É–≤–∞–Ω–µ, —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –æ—Ç –∏–≥—Ä–∏ –∏–ª–∏ –≤—Å–∏—á–∫–æ –¥—Ä—É–≥–æ, –∫–æ–µ—Ç–æ —Å—ä—Ä–≤—ä—Ä—ä—Ç —Ç—Ä—è–±–≤–∞ –¥–∞ –∑–∞–ø–æ–º–Ω–∏.  –¢–µ –º–æ–≥–∞—Ç –¥–∞ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ —Å–∞–º–∏—è –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª, –∫–∞—Ç–æ –∫–æ–π –µ –ª–æ–≥–Ω–∞—Ç, –∑–∞–µ–¥–Ω–æ —Å –Ω–µ–≥–æ–≤–∏—Ç–µ –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ —Å–≤–æ–π—Å—Ç–≤–∞. –í —Ç—è—Ö —Å–µ –Ω–∞–º–∏—Ä–∞—Ç —Ç–∞–∫–∞ –Ω–∞—Ä–µ—á–µ–Ω–∏—Ç–µ –∫–ª–µ–π–º–∞ (claims), –∫–∞—Ç–æ –Ω–∞–ø–æ—Å–ª–µ–¥—ä–∫ **claim-based identity** —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –æ—Ç –≤—Å–∏—á–∫–∏, –≤–∫–ª—é—á–∏—Ç–µ–ª–Ω–æ –∏ –æ—Ç ASP.NET. –ö–æ–≥–∞—Ç–æ —Å–µ –ª–æ–≥–≤–∞–º–µ –Ω—è–∫—ä–¥–µ, –Ω—è–∫–æ–π –ø—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ –∏–º–∞–º–µ –ø—Ä–∞–≤–æ –¥–∞ —Å–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–∞–º–µ, –∫–∞—Ç–æ –ø—ä—Ä–≤–æ —Å–µ –ø—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–¥–µ–Ω –∫—Ä–∏—Ç–µ—Ä–∏–π, –∫–∞—Ç–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–æ –∏–º–µ –∏ –ø–∞—Ä–æ–ª–∞. –°–ª–µ–¥ –∫–∞—Ç–æ —Å–µ —É—Å—Ç–∞–Ω–æ–≤–∏, —á–µ —Å–º–µ –Ω–∏–µ, —Å–µ –ø—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ –∏–º–∞ –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, –Ω–∞–ø—Ä–∏–º–µ—Ä –∏–º–µ–π–ª, –∏–º–µ–Ω–∞, —Ä–æ–ª—è –∏ –¥—Ä—É–≥–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è. –ü–æ–Ω–µ–∂–µ –≤–µ—á–µ —Å–º–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–∞–Ω–∏ –∏ —Å–µ –∑–Ω–∞–µ –∫–æ–∏ —Å–º–µ, —Å–∏—Å—Ç–µ–º–∞—Ç–∞ –º–æ–∂–µ –¥–∞ —Ç–≤—ä—Ä–¥–∏, —á–µ –Ω–∏–µ —Å–º–µ —Ç–æ–∑–∏ —á–æ–≤–µ–∫ –∏ –∏–º–∞–º–µ —Å—ä–æ—Ç–≤–µ—Ç–Ω–∞—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è. –í—ä–ø—Ä–æ—Å–Ω–∏—è—Ç –ø—Ä–æ–≤–∞–π–¥—ä—Ä, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –∫–æ–π –µ —Ç–æ–π, –∏–∑–¥–∞–≤–∞ –∫–ª–µ–π–º–∞—Ç–∞ (claims) ‚Äî —Ç–≤—ä—Ä–¥–µ–Ω–∏—è –∑–∞ –Ω–∞—Å. –ù–∞–ø—Ä–∏–º–µ—Ä: –ø—ä—Ä–≤–æ —Ç–≤—ä—Ä–¥–µ–Ω–∏–µ ‚Äî —Ç–æ–≤–∞ –µ –∏–º–µ—Ç–æ –Ω–∞ —á–æ–≤–µ–∫–∞, –≤—Ç–æ—Ä–æ —Ç–≤—ä—Ä–¥–µ–Ω–∏–µ ‚Äî —Ç–æ–π –µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –∏ —Ç.–Ω. –ü—Ä–æ–≤–∞–π–¥—ä—Ä—ä—Ç –∑–∞–ø–∏—Å–≤–∞ —Ç–µ–∑–∏ —Ç–≤—ä—Ä–¥–µ–Ω–∏—è –≤ –∫—É–∫–∏—Ç–æ –∏ –æ—Ç—Ç—É–∫ –Ω–∞—Ç–∞—Ç—ä–∫, –≤—Å–µ–∫–∏ –ø—ä—Ç, –∫–æ–≥–∞—Ç–æ —Ç–æ–≤–∞ –∫—É–∫–∏ —Å–µ –≤—ä—Ä–Ω–µ –∫—ä–º —Å—ä—Ä–≤—ä—Ä–∞, —Ç–æ–π —â–µ –∑–Ω–∞–µ —Ç–µ–∑–∏ —Ç–≤—ä—Ä–¥–µ–Ω–∏—è. –ù—è–º–∞ –Ω—É–∂–¥–∞ –¥–∞ –≥–∏ –ø—Ä–æ–≤–µ—Ä—è–≤–∞, –∑–∞—â–æ—Ç–æ –∏–º–∞ –≤—è—Ä–∞ –≤ –ø—Ä–æ–≤–∞–π–¥—ä—Ä–∞ –∏ –Ω–µ–≥–æ–≤–∏—Ç–µ —Ç–≤—ä—Ä–¥–µ–Ω–∏—è. –í—Å–∏—á–∫–∏ —Ç–µ–∑–∏ —Ç–≤—ä—Ä–¥–µ–Ω–∏—è —Å–µ –ø—Ä–∏–µ–º–∞—Ç –∑–∞ –≤–µ—Ä–Ω–∏, –¥–æ–∫–∞—Ç–æ –∫—É–∫–∏—Ç–æ –µ –≤–∞–ª–∏–¥–Ω–æ. –í –º–æ–º–µ–Ω—Ç–∞, –≤ –∫–æ–π—Ç–æ –∏–∑—Ç–µ—á–µ –∏–ª–∏ –±—ä–¥–µ –∞–Ω—É–ª–∏—Ä–∞–Ω–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä –ø—Ä–∏ **sign out**), —Å—ä—Ä–≤—ä—Ä—ä—Ç –∑–∞–±—Ä–∞–≤—è —Ç–µ–∑–∏ –¥–∞–Ω–Ω–∏, –∑–∞—â–æ—Ç–æ –Ω–µ –≥–∏ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –Ω–∞ –¥—Ä—É–≥–æ –º—è—Å—Ç–æ.

2. –ü–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏—è - –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∏ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–Ω–∏—è, —Ç–µ–º–∏ –∏ –¥—Ä—É–≥–∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–∞–Ω–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.

3. –ü—Ä–æ—Å–ª–µ–¥—è–≤–∞–Ω–µ - –∑–∞–ø–∏—Å–≤–∞–Ω–µ –∏ –∞–Ω–∞–ª–∏–∑–∏—Ä–∞–Ω–µ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–æ –ø–æ–≤–µ–¥–µ–Ω–∏–µ. –ú–æ–∂–µ –¥–∞ —Å–µ –∑–∞–ø–∏—Å–≤–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ —Å–∞–º–∞—Ç–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç –≤ –±—Ä–∞—É–∑—ä—Ä–∞, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä –∫–æ–ª–∫–æ —Ö–æ—Ä–∞ —Å–∞ –ø–æ—Å–µ—Ç–∏–ª–∏ –¥–∞–¥–µ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –∏ –∫–æ–ª–∫–æ –≤—Ä–µ–º–µ —Å–∞ —Å–µ –∑–∞–¥—ä—Ä–∂–∞–ª–∏ –Ω–∞ –Ω–µ—è. –¢–∞–∑–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–∏ –¥–∞–≤–∞ –≤—ä–∑–º–æ–∂–Ω–æ—Å—Ç –¥–∞ –ø—Ä–µ—Ü–µ–Ω–∏–º –∫–æ–µ –µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ –∑–∞ –∫–ª–∏–µ–Ω—Ç–∏—Ç–µ –∏ –∫–æ–µ –Ω–µ —Å–µ –ø–æ—Å–µ—â–∞–≤–∞, –∫–∞—Ç–æ —Ç–∞–∫–∞ –º–æ–∂–µ–º –¥–∞ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–∞–º–µ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ –∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ —Å–∞–π—Ç–∞.

4. –î–∞ –ø–∞–∑–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, –∫–æ—è—Ç–æ –ø—Ä–µ–¥–∏ —Ç–æ–≤–∞ –µ –±–∏–ª–∞ –≤—ä–≤–µ–¥–µ–Ω–∞ –≤—ä–≤ —Ñ–æ—Ä–º–∞, –µ –µ–¥–Ω–∞ –æ—Ç –æ—Å–Ω–æ–≤–Ω–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∞ –∫—É–∫–∏—Ç–∞—Ç–∞ –∏ —Å–µ—Å–∏–∏—Ç–µ. –ö–æ–≥–∞—Ç–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –ø–æ–ø—ä–ª–Ω–∏ —Ñ–æ—Ä–º–∞ –∏ —è –∏–∑–ø—Ä–∞—Ç–∏, —Å—ä—Ä–≤—ä—Ä—ä—Ç –º–æ–∂–µ –¥–∞ –∑–∞–ø–∏—à–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ —á–∞—Å—Ç –æ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∏ –∏–º–µ–Ω–∞, –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–ª–∏ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–Ω–∏—è) –≤ –∫—É–∫–∏—Ç–∞ –∏–ª–∏ —Å–µ—Å–∏–π–Ω–∏ –¥–∞–Ω–Ω–∏, –∑–∞ –¥–∞ —è –∑–∞–ø–∞–∑–∏ –∏ –¥–∞ —è –∏–∑–ø–æ–ª–∑–≤–∞ –≤ –±—ä–¥–µ—â–µ, –±–µ–∑ –¥–∞ —Å–µ –Ω–∞–ª–∞–≥–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –¥–∞ –≤—ä–≤–µ–∂–¥–∞ –æ—Ç–Ω–æ–≤–æ —Å—ä—â–∏—Ç–µ –¥–∞–Ω–Ω–∏.
### Stateless HTTP - The Problem
–°—ä—Ä–≤—ä—Ä—ä—Ç –Ω–µ –∑–Ω–∞–µ –¥–∞–ª–∏ –¥–≤–∞ —Ä–µ–∫—É–µ—Å—Ç–∞ –∏–¥–≤–∞—Ç –æ—Ç –µ–¥–∏–Ω –∏ —Å—ä—â –∫–ª–∏–µ–Ω—Ç, –∫–æ–µ—Ç–æ –≤–æ–¥–∏ –¥–æ –ø—Ä–æ–±–ª–µ–º–∏:

–ó–∞ –≤—Å—è–∫–∞ –æ–ø–µ—Ä–∞—Ü–∏—è, –∫–æ—è—Ç–æ –∏—Å–∫–∞–º–µ –¥–∞ –∏–∑–≤—ä—Ä—à–∏–º –Ω–∞ –¥–∞–¥–µ–Ω —Å–∞–π—Ç, —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –∞–≤—Ç–µ–Ω—Ç–∏–∫–∏—Ä–∞–º–µ –æ—Ç–Ω–æ–≤–æ.

–î—Ä—É–≥–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∫–∞—Ç–æ –∫–æ–ª–∏—á–∫–∞ —Å –ø–æ–∫—É–ø–∫–∏, –∑–∞–ø–∞–∑–µ–Ω–∏ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –æ—Ç –∏–≥—Ä–∏, –∏–ª–∏ –≤–µ—á–µ —Å–º–µ –∏–∑–±—Ä–∞–ª–∏ –Ω–µ—â–æ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ç–∞, –ø—Ä–∏ —Å–ª–µ–¥–≤–∞—â–∏—è —Ä–µ–∫—É–µ—Å—Ç —Ç–æ –∏–∑—á–µ–∑–≤–∞ –∏ —Ç–Ω.

–ù—è–º–∞ –∫–∞–∫ –¥–∞ —Å–µ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ç–∞.
### Stateless HTTP - The Cookie Solution
–í—ä–ø—Ä–µ–∫–∏ —á–µ HTTP –ø—Ä–æ—Ç–æ–∫–æ–ª—ä—Ç –µ **stateless**, —Ç–æ–π –∏–º–∞ –º–µ—Ö–∞–Ω–∏–∑—ä–º –∑–∞ –∑–∞–ø–æ–º–Ω—è–Ω–µ, –Ω–∞—Ä–µ—á–µ–Ω **cookie**. –ß—Ä–µ–∑ –∫—É–∫–∏—Ç–æ —Å—ä—Ä–≤—ä—Ä—ä—Ç –º–æ–∂–µ –¥–∞ –ø–æ–º–Ω–∏ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –º–µ–∂–¥—É —Ä–µ–∫—É–µ—Å—Ç–∏—Ç–µ. –ù–∞–ø—Ä–∏–º–µ—Ä, –∫–æ–≥–∞—Ç–æ —Å–µ –ª–æ–≥–Ω–µ–º —Å –¥–∞–¥–µ–Ω —Ä–µ–∫—É–µ—Å—Ç –∏ —Å—ä—Ä–≤—ä—Ä—ä—Ç –Ω–∏ –≤—ä—Ä–Ω–µ –æ—Ç–≥–æ–≤–æ—Ä, —Ç–æ–π –º–æ–∂–µ –¥–∞ –Ω–∏ –∏–∑–ø—Ä–∞—Ç–∏ –∫—É–∫–∏, –≤ –∫–æ–µ—Ç–æ –µ –∑–∞–ø–∏—Å–∞–Ω–æ –∫–æ–π —Å–º–µ. –í —Å–ª–µ–¥–≤–∞—â–∏—è —Ä–µ–∫—É–µ—Å—Ç, –∫–æ–≥–∞—Ç–æ –≤—ä—Ä–Ω–µ–º –∫—É–∫–∏—Ç–æ –∫—ä–º —Å—ä—Ä–≤—ä—Ä–∞, —Ç–æ–π –≤–µ—á–µ –∑–Ω–∞–µ –∫–æ–π —Å–µ –æ–±—Ä—ä—â–∞ –∫—ä–º –Ω–µ–≥–æ, –∫–∞—Ç–æ —á–µ—Ç–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è—Ç–∞ –≤ –∫—É–∫–∏—Ç–æ.

–ö—É–∫–∏ –∏ —Å–µ—Å–∏–∏ —á–µ—Å—Ç–æ —Å–µ –∫–æ–º–±–∏–Ω–∏—Ä–∞—Ç, –∑–∞—â–æ—Ç–æ –º–æ–∂–µ –¥–∞ –∏–º–∞–º–µ –∫—É–∫–∏, –∫–æ–µ—Ç–æ —Å—ä–¥—ä—Ä–∂–∞ —Å–∞–º–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞ —Å–µ—Å–∏—è. –°—ä—Ä–≤—ä—Ä—ä—Ç –∑–Ω–∞–µ –æ—Ç–∫—ä–¥–µ –¥–∞ –∏–∑–≤–ª–µ—á–µ —Ç–∞–∑–∏ —Å–µ—Å–∏—è, –∫–æ—è—Ç–æ –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Å–µ –ø–∞–∑–∏ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞. –í–∞–∂–Ω–æ –µ –æ–±–∞—á–µ **–∫—ä–¥–µ** —Ç–æ—á–Ω–æ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ —Ç–∞–∑–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, –∑–∞—â–æ—Ç–æ —Ç–æ–≤–∞ –æ–ø—Ä–µ–¥–µ–ª—è —Å–∏–≥—É—Ä–Ω–æ—Å—Ç—Ç–∞ –∏ –¥–æ—Å—Ç—ä–ø–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ —Å–µ—Å–∏–π–Ω–∏—Ç–µ –¥–∞–Ω–Ω–∏.
### How Are Cookies Used
–û—Ç–≥–æ–≤–æ—Ä—ä—Ç –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞ —Å—ä–¥—ä—Ä–∂–∞ –∫—É–∫–∏, –∫–æ–µ—Ç–æ –±–∏–≤–∞ –∑–∞–ø–∞–∑–µ–Ω–æ, —á—Ä–µ–∑ **Set-Cookie** header:

```
HTTP/1.1 200 OK
Set-Cookie: lang=en
```

–ó–∞—è–≤–∫–∞—Ç–∞ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞ —Å—ä–¥—ä—Ä–∂–∞ —Å—ä–æ—Ç–≤–µ—Ç–Ω–æ—Ç–æ –∫—É–∫–∏, –∫–æ–µ—Ç–æ –∏–∑–ø—Ä–∞—â–∞ –∫—ä–º —Å—ä—Ä–≤—ä—Ä–∞, —á—Ä–µ–∑ **Cookie** header-a, –∞–∫–æ –µ –Ω–∞–ø—Ä–∞–≤–µ–Ω–∞ –∫—ä–º —Å—ä—â–∏—è domain:

```
GET www.example.bg HTTP/1.1
Cookie: lang=en
```

–¢–æ–≤–∞ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ –ø—Ä–∏ –≤—Å—è–∫–æ —Å–ª–µ–¥–≤–∞—â–æ –ø–æ—Å–µ—â–µ–Ω–∏–µ –Ω–∞ —Å—ä—â–∏—è —Å–∞–π—Ç, –±—Ä–∞—É–∑—ä—Ä—ä—Ç –∏–∑–ø—Ä–∞—â–∞ –∫—É–∫–∏—Ç–æ –æ–±—Ä–∞—Ç–Ω–æ –∫—ä–º —Å—ä—Ä–≤—ä—Ä–∞, –∑–∞ –¥–∞ –º–æ–∂–µ —Ç–æ–π –¥–∞ –∑–∞–ø–æ–º–Ω–∏ –ø—Ä–µ–¥–∏—à–Ω–∏—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä –∏–∑–±—Ä–∞–Ω –µ–∑–∏–∫ (–≤ —Å–ª—É—á–∞—è `lang=en`).

–¢–∞–∫–∞, —Å—ä—Ä–≤—ä—Ä—ä—Ç –∏–∑–ø—Ä–∞—â–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –∫—É–∫–∏, –∫–æ–µ—Ç–æ –±—Ä–∞—É–∑—ä—Ä—ä—Ç –∑–∞–ø–∞–∑–≤–∞, –∞ –ø—Ä–∏ —Å–ª–µ–¥–≤–∞—â–∏—Ç–µ —Ä–µ–∫—É–µ—Å—Ç–∏ –±—Ä–∞—É–∑—ä—Ä—ä—Ç –≤—Ä—ä—â–∞ —Ç–µ–∑–∏ –∫—É–∫–∏—Ç–∞ –æ–±—Ä–∞—Ç–Ω–æ –∫—ä–º —Å—ä—Ä–≤—ä—Ä–∞.

–ö–æ–≥–∞—Ç–æ –±—Ä–∞—É–∑—ä—Ä—ä—Ç –ø–æ–ª—É—á–∏ –∫—É–∫–∏ –æ—Ç –¥–∞–¥–µ–Ω —Å–∞–π—Ç, —Ç–æ–π –≥–∏ –∑–∞–ø–∞–∑–≤–∞ –ª–æ–∫–∞–ª–Ω–æ. –ü—Ä–∏ –≤—Å—è–∫–æ —Å–ª–µ–¥–≤–∞—â–æ –∏—Å–∫–∞–Ω–µ –∫—ä–º —Ç–æ–∑–∏ —Å—ä—â–∏—è –¥–æ–º–µ–π–Ω, –±—Ä–∞—É–∑—ä—Ä—ä—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≤–∫–ª—é—á–≤–∞ —Å—ä–æ—Ç–≤–µ—Ç–Ω–∏—Ç–µ –∫—É–∫–∏—Ç–∞ –≤ **Cookie** header-–∞ –Ω–∞ –∑–∞—è–≤–∫–∞—Ç–∞. –¢–æ–≤–∞ –ø–æ–∑–≤–æ–ª—è–≤–∞ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞ –¥–∞ "–ø–æ–º–Ω–∏" –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∫–∞—Ç–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è –∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏. –¢–æ–≤–∞ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞, —á–µ —Å–∞–º–æ –ø—Ä–∞–≤–∏–ª–Ω–∏—Ç–µ –∫—É–∫–∏—Ç–∞ —â–µ –±—ä–¥–∞—Ç –∏–∑–ø—Ä–∞—â–∞–Ω–∏ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞ –∑–∞ —Å—ä–æ—Ç–≤–µ—Ç–Ω–∏—è –¥–æ–º–µ–π–Ω.
### Cookie Structure
–ö—É–∫–∏—Ç–æ —Å–µ —Å—ä—Å—Ç–æ–∏ –æ—Ç **Name**, **Value** –∏ **Attributes** (–ø–æ –∏–∑–±–æ—Ä).

–ê—Ç—Ä–∏–±—É—Ç–∏—Ç–µ —Å–∞ **–∫–ª—é—á-—Å—Ç–æ–π–Ω–æ—Å—Ç** –¥–≤–æ–π–∫–∏ —Å –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è.

–ê—Ç—Ä–∏–±—É—Ç–∏—Ç–µ –Ω–µ —Å–µ –≤–∫–ª—é—á–≤–∞—Ç –≤ –∑–∞—è–≤–∫–∏—Ç–µ.

–ê—Ç—Ä–∏–±—É—Ç–∏—Ç–µ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞ –∑–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –∫—É–∫–∏—Ç–∞—Ç–∞ - –¥–∞ –∫–∞–∂–∞—Ç –Ω–∞ –∫–ª–∏–µ–Ω—Ç–∞, –∫–∞–∫–≤–æ —Ç—Ä—è–±–≤–∞ –¥–∞ –Ω–∞–ø—Ä–∞–≤–∏ —Å –¥–∞–¥–µ–Ω–æ—Ç–æ –∫—É–∫–∏.

–ü—Ä–∏–º–µ—Ä –∑–∞ Set-Cookie header:

```
Set-Cookie: SSID=Ap4P‚Ä¶GTEq; Domain=foo.com; Path=/;
Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly
```

–û–±—è—Å–Ω–µ–Ω–∏–µ –Ω–∞ –∞—Ç—Ä–∏–±—É—Ç–∏—Ç–µ:

- **`SSID=Ap4P‚Ä¶GTEq`**: –¢–æ–≤–∞ –µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è—Ç–∞, –∫–æ—è—Ç–æ —â–µ —Å–µ –ø—Ä–µ–ø—Ä–∞—â–∞ –∫—ä–º –≤—Å–µ–∫–∏ —Ä–µ–∫—É–µ—Å—Ç.

- **Domain=foo.com**: –ö—É–∫–∏—Ç–æ —â–µ –±—ä–¥–µ –∏–∑–ø—Ä–∞—Ç–µ–Ω–æ —Å–∞–º–æ –Ω–∞ –¥–æ–º–µ–π–Ω–∞ **foo.com**.

- **Path=/**: –ö—É–∫–∏—Ç–æ —â–µ –±—ä–¥–µ –∏–∑–ø—Ä–∞—Ç–µ–Ω–æ –∑–∞ –≤—Å–∏—á–∫–∏ –ø—ä—Ç–∏—â–∞ –Ω–∞ –¥–æ–º–µ–π–Ω–∞.

- **Expires**: –û–ø—Ä–µ–¥–µ–ª—è –∫–æ–≥–∞ –∫—É–∫–∏—Ç–æ —â–µ –∏–∑—Ç–µ—á–µ. –ê–∫–æ –Ω–µ –µ –∑–∞–¥–∞–¥–µ–Ω–æ, –∫—É–∫–∏—Ç–æ —â–µ –∏–∑—Ç–µ—á–µ –ø—Ä–∏ –∑–∞—Ç–≤–∞—Ä—è–Ω–µ –Ω–∞ –±—Ä–∞—É–∑—ä—Ä–∞.

- **Secure**: –ö—É–∫–∏—Ç–æ —â–µ –±—ä–¥–µ –∏–∑–ø—Ä–∞—Ç–µ–Ω–æ —Å–∞–º–æ –ø–æ —Å–∏–≥—É—Ä–Ω–∏ (HTTPS) –≤—Ä—ä–∑–∫–∏.

- **`HttpOnly`**: –ö—É–∫–∏—Ç–æ –Ω–µ –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –¥–æ—Å—Ç—ä–ø–Ω–æ —á—Ä–µ–∑ JavaScript, –∫–∞—Ç–æ —Å–µ –∑–∞—â–∏—Ç–∞–≤–∞ –æ—Ç XSS –∞—Ç–∞–∫–∏.
### Scope
–û–∑–Ω–∞—á–∞–≤–∞ –æ–±–ª–∞—Å—Ç—Ç–∞, –≤ –∫–æ—è—Ç–æ –¥–µ–π—Å—Ç–≤–∞ –¥–∞–¥–µ–Ω–æ –Ω–µ—â–æ. –ö–æ–≥–∞—Ç–æ –≥–æ–≤–æ—Ä–∏–º –∑–∞ –∫—É–∫–∏—Ç–∞, –Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª—è–º–µ –æ–±—Ö–≤–∞—Ç–∞ –∏–º —á—Ä–µ–∑ –¥–æ–º–µ–π–Ω–∞ (domain) –∏ –ø—ä—Ç—è (path). –¶–µ–ª—Ç–∞ –µ –¥–∞ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞–º–µ, —á–µ –∫—É–∫–∏—Ç–æ –Ω—è–º–∞ –¥–∞ –±—ä–¥–µ –∏–∑–ø—Ä–∞—Ç–µ–Ω–æ –∫—ä–º –¥—Ä—É–≥. –ê–∫–æ –∏—Å–∫–∞–º–µ —Ç–æ –¥–∞ –±—ä–¥–µ –≤–∞–ª–∏–¥–Ω–æ —Å–∞–º–æ –∑–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ —á–∞—Å—Ç –æ—Ç –Ω–∞—à–µ—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, —É—Ç–æ—á–Ω—è–≤–∞–º–µ –ø—ä—Ç—è, –∫–∞—Ç–æ –≤—Å–∏—á–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü–∏ –ø–æ–¥ —Ç–æ–∑–∏ –ø—ä—Ç –≤ –π–µ—Ä–∞—Ä—Ö–∏—è—Ç–∞ —Å—ä—â–æ —â–µ –ø–æ–ª—É—á–∞–≤–∞—Ç –∫—É–∫–∏—Ç–æ. –ü–æ —Ç–æ–∑–∏ –Ω–∞—á–∏–Ω –º–æ–∂–µ –¥–∞ —Ä–∞–∑–≥—Ä–∞–Ω–∏—á–∏–º, –∞–∫–æ –ø—Ä–∏–º–µ—Ä–Ω–æ –∏–º–∞–º–µ –¥–≤–µ area –Ω–∞ –Ω–∞—à–µ—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ - –µ–¥–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—Å–∫–∞ –∏ –µ–¥–Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∞, –∫—É–∫–∏—Ç–æ –¥–∞ –≤–∞–∂–∏ —Å–∞–º–æ –∑–∞ –µ–¥–Ω–∞ –æ—Ç —Ç—è—Ö, —Ä—è–¥–∫–æ —Å–µ –Ω–∞–ª–∞–≥–∞. –ü–æ —á–µ—Å—Ç–Ω–æ –∫—É–∫–∏—Ç–∞—Ç–∞ —Å–∞ –Ω–∞ –æ—Å–Ω–æ–≤–Ω–∏—è –ø—ä—Ç, –Ω–æ –ø—Ä–∏–Ω—Ü–∏–ø–Ω–æ –µ –≤—ä–∑–º–æ–∂–Ω–æ.

- Domain ‚Äì –ø–æ—Å–æ—á–≤–∞ —É–µ–±—Å–∞–π—Ç–∞, –∫—ä–º –∫–æ–π—Ç–æ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏ –∫—É–∫–∏—Ç–æ. –ù–∏–µ —Ç–∞–∫–∞ —É–∫–∞–∑–≤–∞–º–µ –∫–æ–π —Å—ä—Ä–≤—ä—Ä —Ç—Ä—è–±–≤–∞ –¥–∞ –≥–æ –ø–æ–ª—É—á–∞–≤–∞.

- Path ‚Äì —É–∫–∞–∑–≤–∞ –ø—ä—Ç—è –≤ URL-–∞, –∫–æ–π—Ç–æ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞ –≤ –∑–∞—è–≤–∫–∞—Ç–∞, –∑–∞ –¥–∞ –±—ä–¥–µ –∏–∑–ø—Ä–∞—Ç–µ–Ω Cookie header-—ä—Ç. –° —Ç–æ–≤–∞ –Ω–∏–µ –æ–≥—Ä–∞–Ω–∏—á–∞–≤–∞–º–µ –¥–µ–π—Å—Ç–≤–∏–µ—Ç–æ –Ω–∞ –∫—É–∫–∏—Ç–æ —Å–∞–º–æ –¥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ —á–∞—Å—Ç –æ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ.

```
Set-Cookie: SSID=Ap4P‚Ä¶GTEq; Domain=foo.com; Path=/;
Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly
```
### Lifetime
–ö—É–∫–∏ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ –∏–º–∞—Ç —Å—Ä–æ–∫ –Ω–∞ –¥–µ–π—Å—Ç–≤–∏–µ, –∫–æ–π—Ç–æ —Å–µ –æ–ø—Ä–µ–¥–µ–ª—è –æ—Ç –∞—Ç—Ä–∏–±—É—Ç–∏—Ç–µ Expires –∏ Max-Age.

- Expires ‚Äì –æ–ø—Ä–µ–¥–µ–ª—è –¥–∞—Ç–∞—Ç–∞, –Ω–∞ –∫–æ—è—Ç–æ –±—Ä–∞—É–∑—ä—Ä—ä—Ç —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–∑—Ç—Ä–∏–µ –∫—É–∫–∏—Ç–æ.

- –ü–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ –∫—É–∫–∏ —Ñ–∞–π–ª–æ–≤–µ—Ç–µ —Å–µ –∏–∑—Ç—Ä–∏–≤–∞—Ç –≤ –∫—Ä–∞—è –Ω–∞ —Å–µ—Å–∏—è—Ç–∞. –ë—Ä–∞—É–∑—ä—Ä–∏—Ç–µ –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ –ø—Ä–∏–µ–º–∞—Ç –∑–∞ –∫—Ä–∞–π –Ω–∞ —Å–µ—Å–∏—è—Ç–∞ –∑–∞—Ç–≤–∞—Ä—è–Ω–µ—Ç–æ –Ω–∞ —Ü–µ–ª–∏—è –±—Ä–∞—É–∑—ä—Ä, –∞ –Ω–µ —Å–∞–º–æ –Ω–∞ —Ç–∞–±–∞. –í—ä–ø—Ä–µ–∫–∏ —Ç–æ–≤–∞, —Ç–æ–≤–∞ –Ω–µ –≤–∏–Ω–∞–≥–∏ –µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞–Ω–æ, —Ç—ä–π –∫–∞—Ç–æ –Ω—è–∫–æ–∏ –±—Ä–∞—É–∑—ä—Ä–∏ –º–æ–≥–∞—Ç –¥–∞ –ø–æ–¥–¥—ä—Ä–∂–∞—Ç —Å–µ—Å–∏–∏ –∞–∫—Ç–∏–≤–Ω–∏ –¥–æ—Ä–∏ —Å–ª–µ–¥ –∑–∞—Ç–≤–∞—Ä—è–Ω–µ –Ω–∞ –ø—Ä–æ–∑–æ—Ä–µ—Ü–∞.

- Max-Age ‚Äì –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ—Ç —Å–µ–∫—É–Ω–¥–∏, —Å–ª–µ–¥ –∫–æ–π—Ç–æ –∫—É–∫–∏—Ç–æ —â–µ –±—ä–¥–µ –∏–∑—Ç—Ä–∏—Ç–æ.

```
Set-Cookie: SSID=Ap4P‚Ä¶GTEq; Domain=foo.com; Path=/;
Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly
```
### Security
–°–∏–≥—É—Ä–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ –∫—É–∫–∏—Ç–∞—Ç–∞ —Å–µ –ø–æ—Å—Ç–∏–≥–∞ —á—Ä–µ–∑ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ –Ω–∞ —Å–ø–µ—Ü–∏–∞–ª–Ω–∏ —Ñ–ª–∞–≥–æ–≤–µ, –∫–æ–∏—Ç–æ –Ω—è–º–∞—Ç —Å—Ç–æ–π–Ω–æ—Å—Ç–∏, –∞ —Å–∞–º–æ —É–∫–∞–∑–∞–Ω–∏—è –∑–∞ –±—Ä–∞—É–∑—ä—Ä–∞:

- **Secure** ‚Äì —É–∫–∞–∑–≤–∞ –Ω–∞ –±—Ä–∞—É–∑—ä—Ä–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞ –∫—É–∫–∏—Ç–∞—Ç–∞ —Å–∞–º–æ –ø—Ä–µ–∑ —Å–∏–≥—É—Ä–Ω–∏/—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏ –≤—Ä—ä–∑–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä HTTPS).

- **`HttpOnly`** ‚Äì –æ–ø—Ä–µ–¥–µ–ª—è, —á–µ –∫—É–∫–∏—Ç–æ –Ω–µ –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –¥–æ—Å—Ç—ä–ø–≤–∞–Ω–æ —á—Ä–µ–∑ –∫–ª–∏–µ–Ω—Ç—Å–∫–∏ –µ–∑–∏—Ü–∏ –∑–∞ —Å–∫—Ä–∏–ø—Ç–∏—Ä–∞–Ω–µ –∫–∞—Ç–æ JavaScript.

–ü—Ä–∏–º–µ—Ä –∑–∞ Set-Cookie header —Å —Ç–µ–∑–∏ –∞—Ç—Ä–∏–±—É—Ç–∏:

```
Set-Cookie: SSID=Ap4P‚Ä¶GTEq; Domain=foo.com; Path=/; Expires=Wed, 13 Jan 2021 22:23:01 GMT; Secure; HttpOnly
```
### What is in the Cookie
–ö—É–∫–∏—Ç–æ –µ –º–∞–ª—ä–∫ —Ñ–∞–π–ª, —Å—ä–¥—ä—Ä–∂–∞—â —Ç–∞–±–ª–∏—Ü–∞ —Å –¥–≤–æ–π–∫–∏ **–∫–ª—é—á-—Å—Ç–æ–π–Ω–æ—Å—Ç**, –∫–æ–∏—Ç–æ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –∑–∞ —Å—ä—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, –∫–æ—è—Ç–æ —Å—ä—Ä–≤—ä—Ä—ä—Ç –∏ –±—Ä–∞—É–∑—ä—Ä—ä—Ç –æ–±–º–µ–Ω—è—Ç. –í—Å—è–∫–∞ –¥–≤–æ–π–∫–∞ –∫–ª—é—á-—Å—Ç–æ–π–Ω–æ—Å—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–≤–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, —Å–≤—ä—Ä–∑–∞–Ω–∞ —Å –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∞—Ç–∞ —Å–µ—Å–∏—è, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞ —Å–µ—Å–∏—è –∏–ª–∏ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–Ω–∏—è –∑–∞ –µ–∑–∏–∫.

–¢–∞–∑–∏ —Ç–∞–±–ª–∏—Ü–∞ –æ—Ç –∫–ª—é—á–æ–≤–µ –∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ —Å–µ –∏–∑–ø—Ä–∞—â–∞ –æ–±—Ä–∞—Ç–Ω–æ –∫—ä–º —Å—ä—Ä–≤—ä—Ä–∞ —Å –≤—Å—è–∫–∞ —Å–ª–µ–¥–≤–∞—â–∞ –∑–∞—è–≤–∫–∞ –æ—Ç —Å—ä—â–∏—è –∫–ª–∏–µ–Ω—Ç –∫—ä–º —Å—ä—Ä–≤—ä—Ä–∞, –∫–æ–µ—Ç–æ –ø–æ–∑–≤–æ–ª—è–≤–∞ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞ –¥–∞ "–ø–æ–º–Ω–∏" –¥–∞–Ω–Ω–∏ –∑–∞ –∫–ª–∏–µ–Ω—Ç–∞.

**Example Table:**

| **Attribute**            | **Value**                                 |
| ------------------------ | ----------------------------------------- |
| **Name**                 | ELOQUA                                    |
| **Content**              | GUID=50B3A712CDAA4A208FE95CE1F2BA7063     |
| **Domain**               | .oracle.com                               |
| **Path**                 | /                                         |
| **Send for**             | Any kind of connection                    |
| **Accessible to script** | Yes                                       |
| **Created**              | Monday, August 15, 2016 at 11:38:50 PM    |
| **Expires**              | Wednesday, August 15, 2018 at 11:38:51 PM |
### How to View Cookies
–í **Google Chrome** –º–æ–∂–µ–º –¥–∞ –≤–∏–¥–∏–º –∫—É–∫–∏—Ç–∞—Ç–∞, –∫–∞—Ç–æ —Å–ª–µ–¥–≤–∞–º–µ —Ç–µ–∑–∏ —Å—Ç—ä–ø–∫–∏:

1. –ù–∞—Ç–∏—Å–∫–∞–º–µ **F12** –∏–ª–∏ **Ctrl + Shift + I**, –∑–∞ –¥–∞ –æ—Ç–≤–æ—Ä–∏–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏—Ç–µ –∑–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏—Ü–∏.

2. –û—Ç–∏–≤–∞–º–µ –≤ —Ç–∞–±–∞ **Application** (–≥–æ—Ä–µ –≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏—Ç–µ).

3. –í –ª—è–≤–æ—Ç–æ –º–µ–Ω—é –∏–∑–±–∏—Ä–∞–º–µ **Cookies** –∏ —Å–ª–µ–¥ —Ç–æ–≤–∞ –∫–ª–∏–∫–≤–∞–º–µ –Ω–∞ –¥–æ–º–µ–π–Ω–∞, –∑–∞ –∫–æ–π—Ç–æ –∏—Å–∫–∞–º–µ –¥–∞ –≤–∏–¥–∏–º –∫—É–∫–∏—Ç–∞—Ç–∞.

4. –©–µ —Å–µ –ø–æ—è–≤–∏ —Å–ø–∏—Å—ä–∫ —Å –≤—Å–∏—á–∫–∏ –∫—É–∫–∏—Ç–∞, –∫–æ–∏—Ç–æ —Å—ä—Ä–≤—ä—Ä—ä—Ç –µ –∏–∑–ø—Ä–∞—Ç–∏–ª –∑–∞ —Ç–æ–∑–∏ –¥–æ–º–µ–π–Ω.

–¢–∞–º –º–æ–∂–µ–º –¥–∞ –≤–∏–¥–∏–º –¥–µ—Ç–∞–π–ª–∏ –∑–∞ –≤—Å—è–∫–æ –∫—É–∫–∏, –∫–∞—Ç–æ –∏–º–µ, —Å—Ç–æ–π–Ω–æ—Å—Ç, –¥–∞—Ç–∞ –Ω–∞ –∏–∑—Ç–∏—á–∞–Ω–µ –∏ –¥—Ä—É–≥–∏ –∞—Ç—Ä–∏–±—É—Ç–∏.
### Third Party Cookies
–ë–∏—Å–∫–≤–∏—Ç–∫–∏—Ç–µ –Ω–∞ —Ç—Ä–µ—Ç–∏ —Å—Ç—Ä–∞–Ω–∏ —Å–∞ –±–∏—Å–∫–≤–∏—Ç–∫–∏, –ø–æ—Å—Ç–∞–≤–µ–Ω–∏ –æ—Ç –¥–æ–º–µ–π–Ω, —Ä–∞–∑–ª–∏—á–µ–Ω –æ—Ç —Ç–æ–∑–∏ –Ω–∞ —É–µ–±—Å–∞–π—Ç–∞, –∫–æ–π—Ç–æ –ø–æ—Å–µ—â–∞–≤–∞–º–µ. –¢–µ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –æ—Å–Ω–æ–≤–Ω–æ –∑–∞ —Ä–µ–∫–ª–∞–º–∞ –∏ –ø—Ä–æ—Å–ª–µ–¥—è–≤–∞–Ω–µ –Ω–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—Ç–∞ –Ω–∏ –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç. –ö–æ–≥–∞—Ç–æ –ø–æ—Å–µ—Ç–∏–º —Å–∞–π—Ç, –≤—ä–Ω—à–Ω–∏ –º—Ä–µ–∂–∏, –∫–∞—Ç–æ —Ä–µ–∫–ª–∞–º–Ω–∏ —É—Å–ª—É–≥–∏, –º–æ–≥–∞—Ç –¥–∞ –ø–æ—Å—Ç–∞–≤—è—Ç –±–∏—Å–∫–≤–∏—Ç–∫–∏ –≤ –±—Ä–∞—É–∑—ä—Ä–∞ –Ω–∏.

**–ö–∞–∫ —Ä–∞–±–æ—Ç—è—Ç:**

1. –ü–æ—Å–µ—â–∞–≤–∞–º–µ —Å–∞–π—Ç.

2. –í—ä–Ω—à–Ω–∏ –∏–∑—Ç–æ—á–Ω–∏—Ü–∏ (–∫–∞—Ç–æ —Ä–µ–∫–ª–∞–º–Ω–∏ –º—Ä–µ–∂–∏) –ø–æ—Å—Ç–∞–≤—è—Ç –±–∏—Å–∫–≤–∏—Ç–∫–∏.

3. –¢–µ –ø—Ä–æ—Å–ª–µ–¥—è–≤–∞—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ—Ç–æ –Ω–∏ –ø—Ä–µ–∑ —Ä–∞–∑–ª–∏—á–Ω–∏ —Å–∞–π—Ç–æ–≤–µ.

–ü—Ä–æ–±–ª–µ–º–∏ —Å –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª–Ω–æ—Å—Ç—Ç–∞:

- –ú–æ–≥–∞—Ç –¥–∞ –ø—Ä–æ—Å–ª–µ–¥—è–≤–∞—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ—Ç–æ –Ω–∏ –±–µ–∑ –Ω–∞—à–µ—Ç–æ —Å—ä–≥–ª–∞—Å–∏–µ.

- –ù—è–∫–æ–∏ –±—Ä–∞—É–∑—ä—Ä–∏ –≥–∏ –±–ª–æ–∫–∏—Ä–∞—Ç –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ –∑–∞ –∑–∞—â–∏—Ç–∞ –Ω–∞ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª–Ω–æ—Å—Ç—Ç–∞.

**–†–µ–≥—É–ª–∞—Ü–∏–∏:**

- –ó–∞–∫–æ–Ω–æ–¥–∞—Ç–µ–ª—Å—Ç–≤–∞ –∫–∞—Ç–æ GDPR –∏–∑–∏—Å–∫–≤–∞—Ç —Å—ä–≥–ª–∞—Å–∏–µ –∑–∞ –ø–æ—Å—Ç–∞–≤—è–Ω–µ –Ω–∞ —Ç–µ–∑–∏ –±–∏—Å–∫–≤–∏—Ç–∫–∏.

–û–±—â–æ –≤–∑–µ—Ç–æ, –±–∏—Å–∫–≤–∏—Ç–∫–∏—Ç–µ –Ω–∞ —Ç—Ä–µ—Ç–∏ —Å—Ç—Ä–∞–Ω–∏ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –∑–∞ –ø—Ä–æ—Å–ª–µ–¥—è–≤–∞–Ω–µ –∏ —Ç–∞—Ä–≥–µ—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Ä–µ–∫–ª–∞–º–∏, –Ω–æ –∏–º–∞—Ç –ø—Ä–æ–±–ª–µ–º–∏ —Å –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª–Ω–æ—Å—Ç—Ç–∞, –∫–æ–µ—Ç–æ –≤–æ–¥–∏ –¥–æ —Ä–µ–≥—É–ª–∞—Ü–∏–∏ –∏ –±–ª–æ–∫–∏—Ä–∞–Ω–µ –æ—Ç –±—Ä–∞—É–∑—ä—Ä–∏.
## HTTP Sessions
**–°–µ—Å–∏–∏** —Å–∞ –Ω–∞—á–∏–Ω –∑–∞ —Å—ä—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª, –∫–æ—è—Ç–æ –¥–∞ –±—ä–¥–µ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–∞ –ø—Ä–µ–∑ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∏ –≤ —É–µ–± –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ. –¢–∞–∑–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è —Å–µ –∑–∞–ø–∞–∑–≤–∞ –ø—Ä–µ–∑ —Ü—è–ª–æ—Ç–æ –≤—Ä–µ–º–µ –Ω–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ—Ç–æ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è —Å —É–µ–±—Å–∞–π—Ç–∞, –¥–æ—Ä–∏ –∫–æ–≥–∞—Ç–æ —Ç–æ–π –Ω–∞–≤–∏–≥–∏—Ä–∞ –º–µ–∂–¥—É —Ä–∞–∑–ª–∏—á–Ω–∏ —Å—Ç—Ä–∞–Ω–∏—Ü–∏, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä `/login`, `/home`, –∏ `/products`.

**–ö–∞–∫–≤–æ —Å–∞ —Å–µ—Å–∏–∏—Ç–µ?**

- **–°–µ—Å–∏–∏—Ç–µ** –ø–æ–∑–≤–æ–ª—è–≤–∞—Ç –Ω–∞ —É–µ–± –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –¥–∞ –ø—Ä–æ—Å–ª–µ–¥—è–≤–∞ –¥–µ–π–Ω–æ—Å—Ç—Ç–∞ –∏ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è –ø—Ä–µ–∑ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∏, –±–µ–∑ –¥–∞ –µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–∞ —Å–µ –≤—ä–≤–µ–∂–¥–∞—Ç –∏–ª–∏ –∏–∑–ø—Ä–∞—â–∞—Ç –æ—Ç–Ω–æ–≤–æ –¥–∞–Ω–Ω–∏.

- –û–±–∏–∫–Ω–æ–≤–µ–Ω–æ, **—Å–µ—Å–∏—è—Ç–∞** —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –¥–∞–Ω–Ω–∏ –∫–∞—Ç–æ –∞–≤—Ç–µ–Ω—Ç–∏–∫–∞—Ü–∏—è –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è (–Ω–∞–ø—Ä–∏–º–µ—Ä –¥–∞–ª–∏ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –µ –≤–ª—è–∑—ä–ª –≤ —Å–∏—Å—Ç–µ–º–∞—Ç–∞) –∏–ª–∏ –¥—Ä—É–≥–∏ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–Ω–∏—è (–∫–∞—Ç–æ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –≤ –ø–∞–∑–∞—Ä—Å–∫–∞ –∫–æ–ª–∏—á–∫–∞).

- –°–µ—Å–∏–∏—Ç–µ –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞, –∞ **–∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ä—Ç –Ω–∞ —Å–µ—Å–∏—è—Ç–∞** —Å–µ –∏–∑–ø—Ä–∞—â–∞ –∫—ä–º –∫–ª–∏–µ–Ω—Ç–∞ (–æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ –∫–∞—Ç–æ –±–∏—Å–∫–≤–∏—Ç–∫–∞), –∑–∞ –¥–∞ —Å–≤—ä—Ä–∂–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è —Å –¥–∞–Ω–Ω–∏—Ç–µ, —Å—ä—Ö—Ä–∞–Ω–µ–Ω–∏ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞. –í—ä–∑–º–æ–∂–Ω–æ –µ —Å—ä—â–æ –¥–∞ —Å–µ –∏–∑–ø—Ä–∞—Ç–∏ –∫–∞—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—ä—Ä –≤ –∑–∞—è–≤–∫–∞—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä –≤ **URL**), –Ω–æ —Ç–æ–≤–∞ –Ω–æ—Å–∏ —Å–µ—Ä–∏–æ–∑–µ–Ω —Ä–∏—Å–∫, —Ç—ä–π –∫–∞—Ç–æ —Å–µ—Å–∏–π–Ω–∏—Ç–µ –¥–∞–Ω–Ω–∏ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –≤–∏–¥–∏–º–∏ –≤ –∞–¥—Ä–µ—Å–Ω–∞—Ç–∞ –ª–µ–Ω—Ç–∞, –ª–æ–≥–æ–≤–µ –∏–ª–∏ –¥–æ—Ä–∏ –¥–∞ –±—ä–¥–∞—Ç –ø–æ–¥—Å–ª—É—à–≤–∞–Ω–∏ –æ—Ç –Ω–µ–æ—Ç–æ—Ä–∏–∑–∏—Ä–∞–Ω–∏ –ª–∏—Ü–∞. –¢–æ–≤–∞ –º–æ–∂–µ –¥–∞ –¥–æ–≤–µ–¥–µ –¥–æ –∫—Ä–∞–∂–±–∞ –Ω–∞ —Å–µ—Å–∏—è—Ç–∞ —á—Ä–µ–∑ –∞—Ç–∞–∫–∏ –∫–∞—Ç–æ **session fixation** –∏–ª–∏ **session hijacking**.

**–ü—Ä–∏–º–µ—Ä:**

–ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç **–¢–µ–æ** –≤–ª–∏–∑–∞ –≤ —É–µ–± –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ:

1. **–°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞ –≤—Ö–æ–¥**: –ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –≤–ª–∏–∑–∞ –Ω–∞ `/login`. –°—ä–∑–¥–∞–≤–∞ —Å–µ —Å–µ—Å–∏—è –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞ –∏ –Ω–∞ **–¢–µ–æ** —Å–µ –ø—Ä–∏—Å–≤–æ—è–≤–∞ —É–Ω–∏–∫–∞–ª–µ–Ω –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞ —Å–µ—Å–∏—è—Ç–∞.

2. **–ù–∞—á–∞–ª–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞**: –ö–æ–≥–∞—Ç–æ **–¢–µ–æ** –ø—Ä–µ–º–∏–Ω–µ –∫—ä–º `/home`, –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ä—Ç –Ω–∞ —Å–µ—Å–∏—è—Ç–∞ —Å–µ –∏–∑–ø—Ä–∞—â–∞ —Å –∑–∞—è–≤–∫–∞—Ç–∞, –∫–æ–µ—Ç–æ –ø–æ–∑–≤–æ–ª—è–≤–∞ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞ –¥–∞ –∏–¥–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–∞, —á–µ —Å–µ—Å–∏—è—Ç–∞ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏ –Ω–∞ **–¢–µ–æ**.

3. **–°—Ç—Ä–∞–Ω–∏—Ü–∞ —Å –ø—Ä–æ–¥—É–∫—Ç–∏**: –ù–∞ `/products` —Å—ä—Ä–≤—ä—Ä—ä—Ç –∏–∑–ø–æ–ª–∑–≤–∞ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –Ω–∞ —Å–µ—Å–∏—è—Ç–∞, –∑–∞ –¥–∞ —Ä–∞–∑–±–µ—Ä–µ, —á–µ **–¢–µ–æ** –µ –≤—Å–µ –æ—â–µ –≤–ª—è–∑—ä–ª –≤ —Å–∏—Å—Ç–µ–º–∞—Ç–∞, –∏ –º–æ–∂–µ –¥–∞ –ø–æ–∫–∞–∂–µ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–∞–Ω–æ —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ –∏–ª–∏ –ø—Ä–µ–ø–æ—Ä—ä–∫–∏ –∑–∞ –ø—Ä–æ–¥—É–∫—Ç–∏.

**–ö–∞–∫ —Ä–∞–±–æ—Ç–∏:**

- **–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞ —Å–µ—Å–∏—è—Ç–∞**: –ö–æ–≥–∞—Ç–æ **–¢–µ–æ** –≤–ª–∏–∑–∞ –≤ —Å–∏—Å—Ç–µ–º–∞—Ç–∞, —Å—ä—Ä–≤—ä—Ä—ä—Ç —Å—ä–∑–¥–∞–≤–∞ —É–Ω–∏–∫–∞–ª–µ–Ω –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞ —Å–µ—Å–∏—è—Ç–∞, –∫–æ–π—Ç–æ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –∫–∞—Ç–æ –±–∏—Å–∫–≤–∏—Ç–∫–∞ –≤ –±—Ä–∞—É–∑—ä—Ä–∞ –Ω–∞ **–¢–µ–æ**.

- –î–æ–∫–∞—Ç–æ **–¢–µ–æ** –Ω–∞–≤–∏–≥–∏—Ä–∞ –º–µ–∂–¥—É —Å—Ç—Ä–∞–Ω–∏—Ü–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä `/home`, `/products`), –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ä—Ç –Ω–∞ —Å–µ—Å–∏—è—Ç–∞ —Å–µ –∏–∑–ø—Ä–∞—â–∞ –æ–±—Ä–∞—Ç–Ω–æ –∫—ä–º —Å—ä—Ä–≤—ä—Ä–∞, –∫–æ–µ—Ç–æ –ø–æ–∑–≤–æ–ª—è–≤–∞ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞ –¥–∞ —Å–≤—ä—Ä–∂–µ –¥–µ–π—Å—Ç–≤–∏—è—Ç–∞ —Å —Ç–µ–∫—É—â–∞—Ç–∞ —Å–µ—Å–∏—è –Ω–∞ **–¢–µ–æ** –∏ –¥–∞ –∏–∑–≤–ª–µ—á–µ —Å—ä–æ—Ç–≤–µ—Ç–Ω–∞—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è.

**–°—ä—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞ —Å–µ—Å–∏—è—Ç–∞:**

- –°–µ—Å–∏—è—Ç–∞ –º–æ–∂–µ –¥–∞ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –≤—Å—è–∫–∞–∫–≤–∞ —Å—ä–æ—Ç–≤–µ—Ç–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, –∫–∞—Ç–æ –∏–º–µ—Ç–æ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è (–Ω–∞–ø—Ä–∏–º–µ—Ä **–¢–µ–æ**), —Å—Ç–∞—Ç—É—Å –Ω–∞ –≤–ª–∏–∑–∞–Ω–µ, –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–Ω–∏—è –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è –∏–ª–∏ –¥—Ä—É–≥–∏ –¥–∞–Ω–Ω–∏, –∫–æ–∏—Ç–æ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –∏–∑–ø–æ–ª–∑–≤–∞–Ω–∏ –ø—Ä–µ–∑ —Ä–∞–∑–ª–∏—á–Ω–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü–∏ –Ω–∞ —É–µ–± –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ.

–í –æ–±–æ–±—â–µ–Ω–∏–µ, **—Å–µ—Å–∏—è—Ç–∞** –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞, —á–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è—Ç–∞ –∑–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è (–∫–∞—Ç–æ –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ **–¢–µ–æ**) —Å–µ –∑–∞–ø–∞–∑–≤–∞ –ø—Ä–µ–∑ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∏ –≤ —É–µ–± –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ, –±–µ–∑ –¥–∞ –µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –¥–∞ –≤–ª–∏–∑–∞ –æ—Ç–Ω–æ–≤–æ –∏–ª–∏ –¥–∞ –≤—ä–≤–µ–∂–¥–∞ –¥–∞–Ω–Ω–∏ –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ.
### Relation with Cookies
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250429145908.png)

–ü—Ä–∏ —Ç–æ–∑–∏ –≤–∞—Ä–∏–∞–Ω—Ç —Å–µ —Å—ä–∑–¥–∞–≤–∞ –Ω–æ–≤ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞ —Å–µ—Å–∏—è, –∫—ä–¥–µ—Ç–æ –≤–µ—á–µ —Å–µ–¥–∏ –∏—Å—Ç–∏–Ω—Å–∫–∏—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è. –ü—Ä–æ–±–ª–µ–º–∞ –µ —á–µ –ø—Ä–æ—Ü–µ—Å–∞ –µ —Ç–µ–∂—ä–∫ –∏ –µ –Ω–∞ –¥–≤–µ —Å—Ç—ä–ø–∫–∏ - —Å–∞–º–æ –∑–∞ –¥–∞ —Ä–∞–∑–±–µ—Ä–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è—Ç–∞ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è, —Ç—Ä—è–±–≤–∞ –≤–µ–¥–Ω—ä–∂ –¥–∞ –º–∏–Ω–µ–º –ø—Ä–µ–∑ session store –∏ —Å–ª–µ–¥ —Ç–æ–≤–∞ –¥–∞ –º–∏–Ω–µ–º –ø—Ä–µ–∑ –±–∞–∑–∞—Ç–∞ –¥–∞ –≤–∏–¥–∏–º –∫–æ–π –µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è –∏ —á–∞–∫ —Å–ª–µ–¥ —Ç–æ–≤–∞ —Å–µ –º–∏–Ω–∞–≤–∞ –æ—Ç–Ω–æ–≤–æ –ø—Ä–µ–∑ –±–∞–∑–∞—Ç–∞ –∑–∞ –¥–∞ —Å–µ —Å–≤—ä—Ä—à–∏ —Ä–∞–±–æ—Ç–∞. –¢–æ–≤–∞ –Ω–µ –µ –º–Ω–æ–≥–æ –æ–ø—Ç–∏–º–∞–ª–µ–Ω –≤–∞—Ä–∏–∞–Ω—Ç.

–ü–æ-—á–∏—Å—Ç–∏—è—Ç –∏ —Å–∏–≥—É—Ä–µ–Ω –ø–æ–¥—Ö–æ–¥ –µ, –∫–æ–≥–∞—Ç–æ —Å—Ä–µ—â—É –Ω–∞—à–∏—è **–∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞ —Å–µ—Å–∏—è** —Å—ä—Ö—Ä–∞–Ω—è–≤–∞–º–µ **—Ü—è–ª–∞—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è** –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞, –∞ –Ω–µ —è –ø—Ä–µ–¥–∞–≤–∞–º–µ –∫—ä–º –∫–ª–∏–µ–Ω—Ç–∞. –û–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Ç–æ–≤–∞ —Å–µ —Ä–µ–∞–ª–∏–∑–∏—Ä–∞ —á—Ä–µ–∑ **in-memory –±–∞–∑–∏** –∫–∞—Ç–æ Redis, –∫–æ–∏—Ç–æ –ø–æ–∑–≤–æ–ª—è–≤–∞—Ç –±—ä—Ä–∑ –¥–æ—Å—Ç—ä–ø –¥–æ —Å–µ—Å–∏–π–Ω–∏—Ç–µ –¥–∞–Ω–Ω–∏ –∏ –ª–µ—Å–Ω–æ –º–∞—â–∞–±–∏—Ä–∞–Ω–µ –ø—Ä–∏ –≥–æ–ª—è–º –±—Ä–æ–π –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–∏, –±–µ–∑ –¥–∞ —Å–µ –∫–æ–º–ø—Ä–æ–º–µ—Ç–∏—Ä–∞ —Å–∏–≥—É—Ä–Ω–æ—Å—Ç—Ç–∞.
### Sessions vs Cookies
| Feature              | Cookies                                                       | Sessions                                          |
| -------------------- | ------------------------------------------------------------- | ------------------------------------------------- |
| **Storage Location** | –°—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç —Å–µ –Ω–∞ –∫–æ–º–ø—é—Ç—ä—Ä–∞ –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è (–∫–∞—Ç–æ —Ç–µ–∫—Å—Ç–æ–≤ —Ñ–∞–π–ª) | –°—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç —Å–µ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞                          |
| **Expiration**       | –ò–∑—Ç–∏—á–∞—Ç –Ω–∞ –∑–∞–¥–∞–¥–µ–Ω–∞ –¥–∞—Ç–∞                                      | –ò–∑—Ç–∏—á–∞—Ç –ø—Ä–∏ –∑–∞—Ç–≤–∞—Ä—è–Ω–µ –Ω–∞ –±—Ä–∞—É–∑—ä—Ä–∞                 |
| **Data Capacity**    | –ú–æ–≥–∞—Ç –¥–∞ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω–∏               | –ú–æ–≥–∞—Ç –¥–∞ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω–∏ |
| **Dependency**       | –ù–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Å–µ—Å–∏—è—Ç–∞                                         | –ó–∞–≤–∏—Å—è—Ç –æ—Ç –∫—É–∫–∏—Ç–æ (–æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ session ID)         |
| **Security**         | –ü–æ-—Å–ª–∞–±–∞ —Å–∏–≥—É—Ä–Ω–æ—Å—Ç ‚Äì —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç —Å–µ –≤ –æ–±–∏–∫–Ω–æ–≤–µ–Ω —Ç–µ–∫—Å—Ç          | –ü–æ-–≤–∏—Å–æ–∫–∞ —Å–∏–≥—É—Ä–Ω–æ—Å—Ç ‚Äì –¥–∞–Ω–Ω–∏—Ç–µ —Å–∞ –∫—Ä–∏–ø—Ç–∏—Ä–∞–Ω–∏       |
| **Accessibility**    | –õ–µ—Å–Ω–æ –¥–æ—Å—Ç—ä–ø–Ω–∏ –æ—Ç –≤—Å–µ–∫–∏                                       | –ù–µ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –¥–æ—Å—Ç—ä–ø–µ–Ω–∏ –ª–µ—Å–Ω–æ                 |
–ê–∫–æ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞–º–µ —Å–µ—Å–∏–∏—Ç–µ —Å–∞–º–æ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞ (–≤ –ø–∞–º–µ—Ç—Ç–∞ –º—É), –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–µ –Ω–∞ –Ω—è–∫–æ–ª–∫–æ —Å—ä—Ä–≤—ä—Ä–∞ (–Ω–∞–ø—Ä. 5), –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç —â–µ –±—ä–¥–µ —Å–≤—ä—Ä–∑–∞–Ω —Å–∞–º–æ —Å —Ç–æ–∑–∏ —Å—ä—Ä–≤—ä—Ä, –Ω–∞ –∫–æ–π—Ç–æ –µ —Å—ä–∑–¥–∞–¥–µ–Ω–∞ —Å–µ—Å–∏—è—Ç–∞. –ê–∫–æ –ø–æ-–∫—ä—Å–Ω–æ –∑–∞—è–≤–∫–∞—Ç–∞ –º—É –ø–æ–ø–∞–¥–Ω–µ –Ω–∞ –¥—Ä—É–≥ —Å—ä—Ä–≤—ä—Ä, —Å–µ—Å–∏—è—Ç–∞ –Ω—è–º–∞ –¥–∞ –±—ä–¥–µ –Ω–∞–º–µ—Ä–µ–Ω–∞ –∏ —â–µ –∏–∑–≥–ª–µ–∂–¥–∞ –∫–∞—Ç–æ —á–µ –Ω–µ –µ –ª–æ–≥–Ω–∞—Ç. –ó–∞—Ç–æ–≤–∞ –ø—Ä–∏ scaled –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ —Å–ø–æ–¥–µ–ª–µ–Ω storage (–Ω–∞–ø—Ä. Redis), –¥–æ—Å—Ç—ä–ø–Ω–æ –æ—Ç –≤—Å–∏—á–∫–∏ —Å—ä—Ä–≤—ä—Ä–∏.

–°–µ—Å–∏—è—Ç–∞ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞, –∞ –Ω–µ –≤ –±–∏—Å–∫–≤–∏—Ç–∫–∏—Ç–µ. –ö—É–∫–∏—Ç–µ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç —Å–∞–º–æ –∑–∞ —Å—ä—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞ **–∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –Ω–∞ —Å–µ—Å–∏—è—Ç–∞**, –∫–æ–π—Ç–æ —Å–≤—ä—Ä–∑–≤–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è —Å—ä—Å —Å—ä—Ä–≤—ä—Ä–Ω–∞—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è.

–¢—Ä—è–±–≤–∞ –¥–∞ –∑–∞–¥–∞–≤–∞–º–µ **—Å—Ä–æ–∫ –Ω–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç (expiration)** –Ω–∞ —Å–µ—Å–∏–∏—Ç–µ, –∑–∞ –¥–∞ –∏–∑–±–µ–≥–Ω–µ–º —Ç.–Ω–∞—Ä. **‚Äû–∑–æ–º–±–∏ —Å–µ—Å–∏–∏‚Äú**. –ö–æ–≥–∞—Ç–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –∑–∞—Ç–≤–æ—Ä–∏ –±—Ä–∞—É–∑—ä—Ä–∞, –±–∏—Å–∫–≤–∏—Ç–∫–∞—Ç–∞ —Å—ä—Å session ID –º–æ–∂–µ –¥–∞ —Å–µ –∏–∑—Ç—Ä–∏–µ, –Ω–æ —Å—ä—Ä–≤—ä—Ä—ä—Ç –Ω–µ –ø–æ–ª—É—á–∞–≤–∞ —Å–∏–≥–Ω–∞–ª –∑–∞ —Ç–æ–≤–∞ –∏ –ø—Ä–æ–¥—ä–ª–∂–∞–≤–∞ –¥–∞ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ —Å–µ—Å–∏—è—Ç–∞. –ó–∞—Ç–æ–≤–∞ –µ –¥–æ–±—Ä–µ –¥–∞ –ø–æ–ª–∑–≤–∞–º–µ **sliding expiration** ‚Äì –Ω–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–∏ –∂–∏–≤–æ—Ç –æ—Ç 30 –º–∏–Ω—É—Ç–∏, –∞–∫–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –∏–∑–ø—Ä–∞—Ç–∏ –∑–∞—è–≤–∫–∞ –Ω–∞ 15-—Ç–∞—Ç–∞ –º–∏–Ω—É—Ç–∞, –≤—Ä–µ–º–µ—Ç–æ —Å–µ —É–¥—ä–ª–∂–∞–≤–∞ —Å –æ—â–µ 30 –º–∏–Ω—É—Ç–∏.

–ö–∞–∫ —Ä–∞–±–æ—Ç–∏:

1. –ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –≤–ª–∏–∑–∞ –≤ —Å–∏—Å—Ç–µ–º–∞—Ç–∞ –∏ –ø–æ–ª—É—á–∞–≤–∞ **`session_id`**, –∫–æ–π—Ç–æ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –≤ –±—Ä–∞—É–∑—ä—Ä–∞ –∫–∞—Ç–æ –±–∏—Å–∫–≤–∏—Ç–∫–∞.

2. –ü—Ä–∏ –≤—Å—è–∫–∞ –∑–∞—è–≤–∫–∞, –±—Ä–∞—É–∑—ä—Ä—ä—Ç –∏–∑–ø—Ä–∞—â–∞ **`session_id`** –∫—ä–º —Å—ä—Ä–≤—ä—Ä–∞.

3. –°—ä—Ä–≤—ä—Ä—ä—Ç –∏–∑–ø–æ–ª–∑–≤–∞ —Ç–æ–∑–∏ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä, –∑–∞ –¥–∞ –∏–∑–≤–ª–µ—á–µ –¥–∞–Ω–Ω–∏ –∑–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è (–Ω–∞–ø—Ä–∏–º–µ—Ä –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, —Å—ä—Å—Ç–æ—è–Ω–∏–µ –Ω–∞ –≤—Ö–æ–¥ –∏ —Ç.–Ω.).

**–ö–∞–∫ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è—Ç–∞:**

- **–í –ø–∞–º–µ—Ç—Ç–∞ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞** (RAM) –∑–∞ –±—ä—Ä–∑–æ –∏ –≤—Ä–µ–º–µ–Ω–Ω–æ —Å—ä—Ö—Ä–∞–Ω–µ–Ω–∏–µ.

- **–í –±–∞–∑–∞ –¥–∞–Ω–Ω–∏**, –∞–∫–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è—Ç–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ.

- **–í—ä–≤ –≤—ä–Ω—à–Ω–∏ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞** –∫–∞—Ç–æ **Redis**, –∞–∫–æ –∏–º–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Å—ä—Ä–≤—ä—Ä–∏.

**–ü—Ä–µ–¥–∏–º—Å—Ç–≤–∞:**

- –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç: –î–∞–Ω–Ω–∏—Ç–µ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞ –∏ –Ω–µ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –ø—Ä–æ–º–µ–Ω—è–Ω–∏ –æ—Ç –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è.

- –ú–æ–∂–µ –¥–∞ —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç –ø–æ–≤–µ—á–µ –∏ –ø–æ-—Å–∏–≥—É—Ä–Ω–∏ –¥–∞–Ω–Ω–∏ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –∫—É–∫–∏.

–û—Å–Ω–æ–≤–Ω–∞—Ç–∞ —Ä–∞–∑–ª–∏–∫–∞ –µ:

- **–í –∫—É–∫–∏** —Å—ä—Ö—Ä–∞–Ω—è–≤–∞–º–µ **—Ü—è–ª–∞—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è** –∑–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è (–Ω–∞–ø—Ä–∏–º–µ—Ä –¥–∞–Ω–Ω–∏ –∑–∞ –≤–ª–∏–∑–∞–Ω–µ, –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ —Ç.–Ω.), –∫–æ–µ—Ç–æ –º–æ–∂–µ –¥–∞ –±—ä–¥–µ —É—è–∑–≤–∏–º–æ –∏ –¥–∞ —É–≤–µ–ª–∏—á–∏ —Ä–∞–∑–º–µ—Ä–∞ –Ω–∞ –∫—É–∫–∏—Ç–µ.

- **–í —Å–µ—Å–∏–∏** —Å—ä—Ö—Ä–∞–Ω—è–≤–∞–º–µ —Å–∞–º–æ **–∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –Ω–∞ —Å–µ—Å–∏—è—Ç–∞ (`session_id`)** –≤ –∫—É–∫–∏, –∫–æ–π—Ç–æ —É–∫–∞–∑–≤–∞ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞ –∫–æ—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏—è –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª. –í—Å–∏—á–∫–∞—Ç–∞ —Å—ä—â–∏–Ω—Å–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ **–Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞**, –∫–æ–µ—Ç–æ –µ –ø–æ-—Å–∏–≥—É—Ä–Ω–æ –∏ –ø–æ-–µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ.
## Synchronous Programming
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250429171514.png)

–ò–∑–ø—ä–ª–Ω–µ–Ω–∏–µ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–Ω–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –µ–¥–∏–Ω —Å–ª–µ–¥ –¥—Ä—É–≥.

–í—Å—è–∫–æ –¥–µ–π—Å—Ç–≤–∏–µ —Å–µ —Å–ª—É—á–≤–∞ —Å–ª–µ–¥ –ø—Ä–µ–¥—Ö–æ–¥–Ω–æ—Ç–æ.

–ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∏—Ç–µ –∏–∑—á–∞–∫–≤–∞—Ç –∑–∞–≤—ä—Ä—à–≤–∞–Ω–µ—Ç–æ –Ω–∞ –ø—Ä–µ–¥–∏—à–Ω–∏—Ç–µ.

–†–µ—Å—É—Ä—Å–∏—Ç–µ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ —Å–∞ –¥–æ—Å—Ç—ä–ø–Ω–∏ –ø—Ä–µ–∑ —Ü—è–ª–æ—Ç–æ –≤—Ä–µ–º–µ, —Ç—ä–π –∫–∞—Ç–æ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–æ –∏ –≤—Å—è–∫–∞ —á–∞—Å—Ç –æ—Ç –∫–æ–¥–∞ –∏–º–∞ –¥–æ—Å—Ç—ä–ø –¥–æ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ –æ—Ç –ø—Ä–µ–¥–∏—à–Ω–∏—Ç–µ —Å—Ç—ä–ø–∫–∏. –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è—Ç–∞ –æ—Ç Task 1 –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –ø–æ–ª–∑–≤–∞–Ω–∞ –≤ —Å–ª–µ–¥–≤–∞—â–∏—Ç–µ —Ç–∞—Å–∫–æ–≤–µ, –∫—ä–¥–µ—Ç–æ —Ä–µ—à–∏–º. –¢–æ–≤–∞ –Ω–µ –µ –≤–∞–ª–∏–¥–Ω–æ, –∫–æ–≥–∞—Ç–æ –∏–º–∞–º–µ –ø–∞—Ä–∞–ª–µ–ª–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞.
### Drawbacks
**–ê–∫–æ –µ–¥–∏–Ω –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –µ –±–ª–æ–∫–∏—Ä–∞–Ω, —Ü—è–ª–∞—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –µ –±–ª–æ–∫–∏—Ä–∞–Ω–∞**  
    –í —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ, –∞–∫–æ –µ–¥–∏–Ω –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–∑—á–∞–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä –ø–æ—Ä–∞–¥–∏ –∑–∞–±–∞–≤—è–Ω–µ –≤ –º—Ä–µ–∂–æ–≤–∞ –≤—Ä—ä–∑–∫–∞ –∏–ª–∏ —Ñ–∞–π–ª–æ–≤–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏), —Ç–æ–≤–∞ —â–µ –±–ª–æ–∫–∏—Ä–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ —Ü–µ–ª–∏—è –ø—Ä–æ—Ü–µ—Å, –¥–æ–∫–∞—Ç–æ –Ω–µ —Å–µ –ø—Ä–∏–∫–ª—é—á–∏ —Å –Ω–µ–≥–æ.

**–ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∏—è—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –º–æ–∂–µ –¥–∞ —Å—Ç–∞–Ω–µ unresponsive**  
    –ê–∫–æ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –±–ª–æ–∫–∏—Ä–∞ –ø–æ –≤—Ä–µ–º–µ –Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏, –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ä—Ç –º–æ–∂–µ –¥–∞ —Å–ø—Ä–µ –¥–∞ —Ä–µ–∞–≥–∏—Ä–∞ –Ω–∞ –¥–µ–π—Å—Ç–≤–∏—è –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è, –∫–∞—Ç–æ –Ω–∞–ø—Ä–∏–º–µ—Ä –Ω–∞—Ç–∏—Å–∫–∞–Ω–∏—è –Ω–∞ –±—É—Ç–æ–Ω–∏ –∏–ª–∏ –≤—ä–≤–µ–∂–¥–∞–Ω–µ –Ω–∞ —Ç–µ–∫—Å—Ç.

**–ù–µ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –≤—Å–∏—á–∫–∏ —è–¥—Ä–∞ –Ω–∞ –ø—Ä–æ—Ü–µ—Å–æ—Ä–∞**  
    –í —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ, —Å–∞–º–æ –µ–¥–Ω–æ —è–¥—Ä–æ –æ—Ç –ø—Ä–æ—Ü–µ—Å–æ—Ä–∞ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –ø–æ –≤—Ä–µ–º–µ –Ω–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞, –∫–æ–µ—Ç–æ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –Ω–µ —Å–µ –≤—ä–∑–ø–æ–ª–∑–≤–∞ –æ—Ç –≤—ä–∑–º–æ–∂–Ω–æ—Å—Ç–∏—Ç–µ –∑–∞ –ø–∞—Ä–∞–ª–µ–ª–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞, –∫–æ–∏—Ç–æ –ø—Ä–µ–¥–ª–∞–≥–∞—Ç –º–Ω–æ–≥–æ–ø—Ä–æ—Ü–µ—Å–æ—Ä–Ω–∏—Ç–µ —Å–∏—Å—Ç–µ–º–∏.

**–ó–∞–¥–∞—á–∏, –∏–∑–∏—Å–∫–≤–∞—â–∏ –≥–æ–ª—è–º–æ –Ω–∞—Ç–æ–≤–∞—Ä–≤–∞–Ω–µ –Ω–∞ –ø—Ä–æ—Ü–µ—Å–æ—Ä–∞, –∑–∞–±–∞–≤—è—Ç –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ –≤—Å–∏—á–∫–∏ –¥—Ä—É–≥–∏ –∑–∞–¥–∞—á–∏**  
    –ê–∫–æ –∏–º–∞ —Ç–µ–∂–∫–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä —Å–ª–æ–∂–Ω–∏ –∏–∑—á–∏—Å–ª–µ–Ω–∏—è), —Ç–µ –º–æ–≥–∞—Ç –¥–∞ –±–ª–æ–∫–∏—Ä–∞—Ç –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ –¥—Ä—É–≥–∏ —á–∞—Å—Ç–∏ –æ—Ç –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞, –∫–æ–µ—Ç–æ –≤–æ–¥–∏ –¥–æ –∑–Ω–∞—á–∏—Ç–µ–ª–Ω–æ –∑–∞–±–∞–≤—è–Ω–µ.

**–î–æ—Å—Ç—ä–ø—ä—Ç –¥–æ —Ä–µ—Å—É—Ä—Å–∏ –±–ª–æ–∫–∏—Ä–∞ —Ü—è–ª–∞—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–∞**  
    –î–æ—Å—Ç—ä–ø—ä—Ç –¥–æ –≤—ä–Ω—à–Ω–∏ —Ä–µ—Å—É—Ä—Å–∏ –∫–∞—Ç–æ —Ñ–∞–π–ª–æ–≤–µ –∏–ª–∏ –º—Ä–µ–∂–æ–≤–∏ –≤—Ä—ä–∑–∫–∏ —Å—ä—â–æ –º–æ–∂–µ –¥–∞ –±–ª–æ–∫–∏—Ä–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞, –¥–æ–∫–∞—Ç–æ —Å–µ –∏–∑—á–∞–∫–∞ –æ—Ç–≥–æ–≤–æ—Ä—ä—Ç –æ—Ç —Å—ä—Ä–≤—ä—Ä–∞ –∏–ª–∏ –æ–ø–µ—Ä–∞—Ü–∏—è—Ç–∞ —Å —Ñ–∞–π–ª–∞.

**–û—Å–æ–±–µ–Ω–æ –ø—Ä–æ–±–ª–µ–º–Ω–æ –ø—Ä–∏ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ –Ω–∞ —É–µ–± —Ä–µ—Å—É—Ä—Å–∏**  
    –ü—Ä–æ–≥—Ä–∞–º–∏—Ç–µ, –∫–æ–∏—Ç–æ –∑–∞–≤–∏—Å—è—Ç –æ—Ç —É–µ–± –∑–∞—è–≤–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä API –∏–∑–≤–∏–∫–≤–∞–Ω–∏—è), –º–æ–∂–µ –¥–∞ –±–ª–æ–∫–∏—Ä–∞—Ç –≤—Å–∏—á–∫–æ, –¥–æ–∫–∞—Ç–æ —Å–µ –∏–∑—á–∞–∫–∞ –æ—Ç–≥–æ–≤–æ—Ä –æ—Ç —Å—ä—Ä–≤—ä—Ä–∞. –¢–æ–≤–∞ –µ –æ—Å–æ–±–µ–Ω–æ –ø—Ä–æ–±–ª–µ–º–Ω–æ –∑–∞ UX, –∫–æ–≥–∞—Ç–æ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç —É–µ–± –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, –∫–æ–∏—Ç–æ —Å–µ –Ω—É–∂–¥–∞—è—Ç –æ—Ç –Ω–µ–∑–∞–±–∞–≤–Ω–∞ —Ä–µ–∞–∫—Ü–∏—è –Ω–∞ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è.
## Asynchronous Programming
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250429213543.png)

**–ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∏—Ç–µ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –º–æ–≥–∞—Ç –¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞—Ç –ø–∞—Ä–∞–ª–µ–ª–Ω–æ**  
	–ß–∞—Å—Ç–∏—Ç–µ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –Ω–µ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞—Ç –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –µ–¥–Ω–∞ —Å–ª–µ–¥ –¥—Ä—É–≥–∞, –∞ –º–æ–≥–∞—Ç –¥–∞ –≤—ä—Ä–≤—è—Ç –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.

**–ù—è–∫–æ–∏ –¥–µ–π—Å—Ç–≤–∏—è —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞—Ç –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ —Å –¥—Ä—É–≥–∏**  
	–ü—Ä–∏–º–µ—Ä–Ω–æ —á–µ—Ç–µ–Ω–µ –æ—Ç —Ñ–∞–π–ª –∏ –ø–æ–∫–∞–∑–≤–∞–Ω–µ –Ω–∞ –ø—Ä–æ–≥—Ä–µ—Å –º–æ–∂–µ –¥–∞ —Å–µ —Å–ª—É—á–≤–∞—Ç –ø–∞—Ä–∞–ª–µ–ª–Ω–æ.

**–í—Å—è–∫–æ –¥–µ–π—Å—Ç–≤–∏–µ –º–æ–∂–µ –¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞ –≤ –æ—Ç–¥–µ–ª–Ω–∞ –Ω–∏—à–∫–∞**  
	–¢–æ–≤–∞ –ø–æ–∑–≤–æ–ª—è–≤–∞ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞ –ø–æ-–¥–æ–±—Ä–µ –ø—Ä–æ—Ü–µ—Å–æ—Ä–∞, –∫–∞—Ç–æ —Ä–∞–∑–ø—Ä–µ–¥–µ–ª—è –∑–∞–¥–∞—á–∏—Ç–µ –≤ —Ä–∞–∑–ª–∏—á–Ω–∏ —è–¥—Ä–∞.

**–ù–µ–∑–∞–≤–∏—Å–∏–º–∏—Ç–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –Ω–µ –∏–∑—á–∞–∫–≤–∞—Ç –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ –æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ**  
	–ê–∫–æ –µ–¥–Ω–∞ –∑–∞–¥–∞—á–∞ –Ω–µ –∑–∞–≤–∏—Å–∏ –æ—Ç –¥—Ä—É–≥–∞, —Ç—è –º–æ–∂–µ –¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω–∏ –≤–µ–¥–Ω–∞–≥–∞, –±–µ–∑ –¥–∞ —á–∞–∫–∞ –¥—Ä—É–≥–∏—Ç–µ –¥–∞ –ø—Ä–∏–∫–ª—é—á–∞—Ç. –ó–∞ –¥–∞ –≥–∏ –ø—É—Å–Ω–µ–º –Ω–∞ –æ—Ç–¥–µ–ª–Ω–∏ –Ω–∏—à–∫–∏, —Ç–∞—Å–∫–æ–≤–µ—Ç–µ –Ω–µ —Ç—Ä—è–±–≤–∞ –¥–∞ –∑–∞–≤–∏—Å—è—Ç –µ–¥–∏–Ω –æ—Ç –¥—Ä—É–≥ ‚Äì –Ω–µ —Ç—Ä—è–±–≤–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç—ä—Ç –æ—Ç –µ–¥–∏–Ω–∏—è –¥–∞ –µ –Ω—É–∂–µ–Ω –∑–∞ —Ä–∞–±–æ—Ç–∞—Ç–∞ –Ω–∞ –≤—Ç–æ—Ä–∏—è. –ê–∫–æ –∏–º–∞ —Ç–∞–∫–∞–≤–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç, –∑–∞–¥–∞—á–∏—Ç–µ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω—è—Ç –≤ –µ–¥–Ω–∞ –Ω–∏—à–∫–∞, –∑–∞—â–æ—Ç–æ –Ω—è–º–∞ —Å–º–∏—Å—ä–ª –¥–∞ —Å–∞ –≤ —Ä–∞–∑–ª–∏—á–Ω–∏. –ò–∑–∫–ª—é—á–µ–Ω–∏–µ –µ, –∞–∫–æ –∏—Å–∫–∞–º–µ –¥–∞ –æ—Å–≤–æ–±–æ–¥–∏–º –≥–ª–∞–≤–Ω–∞—Ç–∞ –Ω–∏—à–∫–∞ –∑–∞ –Ω–µ—â–æ –¥—Ä—É–≥–æ ‚Äì —Ç–æ–≥–∞–≤–∞ –º–æ–∂–µ–º –¥–∞ –≥–∏ –∏–∑–∫–∞—Ä–∞–º–µ –≤ –¥–≤–µ –Ω–∏—à–∫–∏.

**–†–µ—Å—É—Ä—Å–∏—Ç–µ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ —Å–µ —Å–ø–æ–¥–µ–ª—è—Ç –º–µ–∂–¥—É –Ω–∏—à–∫–∏—Ç–µ**  
	–ü—Ä–æ–º–µ–Ω–ª–∏–≤–∏, —Ñ–∞–π–ª–æ–≤–µ –∏–ª–∏ –±–∞–∑–∞ –¥–∞–Ω–Ω–∏ –º–æ–≥–∞—Ç –¥–∞ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –æ—Ç —Ä–∞–∑–ª–∏—á–Ω–∏ –Ω–∏—à–∫–∏ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.

**–ê–∫–æ –µ–¥–Ω–∞ –Ω–∏—à–∫–∞ –∏–∑–ø–æ–ª–∑–≤–∞ –¥–∞–¥–µ–Ω —Ä–µ—Å—É—Ä—Å, –¥—Ä—É–≥–∏—Ç–µ –Ω–µ —Ç—Ä—è–±–≤–∞ –¥–∞ –≥–æ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ**  
	–¢–æ–≤–∞ –µ –Ω—É–∂–Ω–æ, –∑–∞ –¥–∞ —Å–µ –∏–∑–±–µ–≥–Ω–∞—Ç –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∏, –∑–∞–≥—É–±–∞ –Ω–∞ –¥–∞–Ω–Ω–∏ –∏–ª–∏ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–æ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –≤ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞.
### Benefits
–ê–∫–æ –¥–∞–¥–µ–Ω –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –µ –±–ª–æ–∫–∏—Ä–∞–Ω, –æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ –ø—Ä–æ–¥—ä–ª–∂–∞–≤–∞—Ç –¥–∞ —Ä–∞–±–æ—Ç—è—Ç.  

–ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–∏—è—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å (UI) —Ä–∞–±–æ—Ç–∏ –æ—Ç–¥–µ–ª–Ω–æ –∏ –æ—Å—Ç–∞–≤–∞ responsive.  

–°—ä–≤—Ä–µ–º–µ–Ω–Ω–∏—Ç–µ –ø—Ä–æ—Ü–µ—Å–æ—Ä–∏ –∏–º–∞—Ç –Ω—è–∫–æ–ª–∫–æ —è–¥—Ä–∞, –∏ –≤—Å—è–∫–æ –º–æ–∂–µ –¥–∞ –∏–∑–ø—ä–ª–Ω—è–≤–∞ –µ–¥–Ω–∞ –∏–ª–∏ –ø–æ–≤–µ—á–µ –Ω–∏—à–∫–∏.  

–ù–∏—à–∫–∏—Ç–µ —Å–µ —Ä–∞–∑–ø—Ä–µ–¥–µ–ª—è—Ç –¥–∏–Ω–∞–º–∏—á–Ω–æ –º–µ–∂–¥—É —è–¥—Ä–∞—Ç–∞ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—Ç–∞ —Å–∏—Å—Ç–µ–º–∞.  

–ó–∞–¥–∞—á–∏, –∏–∑–∏—Å–∫–≤–∞—â–∏ –º–Ω–æ–≥–æ –∏–∑—á–∏—Å–ª–µ–Ω–∏—è, —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞—Ç –Ω–∞ —Ñ–æ–Ω–æ–≤–∏ (background) –Ω–∏—à–∫–∏.  

–î–æ—Å—Ç—ä–ø—ä—Ç –¥–æ —Ä–µ—Å—É—Ä—Å–∏ —Å—ä—â–æ —Å–µ –∏–∑–≤—ä—Ä—à–≤–∞ –Ω–∞ —Ñ–æ–Ω–æ–≤–∏ –Ω–∏—à–∫–∏.  
### Drawbacks
–¢—Ä—É–¥–Ω–æ –µ –¥–∞ —Å–µ —Ä–∞–∑–±–µ—Ä–µ –∫–æ–∏ —á–∞—Å—Ç–∏ –æ—Ç –∫–æ–¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞—Ç –≤ –∫–æ–Ω–∫—Ä–µ—Ç–µ–Ω –º–æ–º–µ–Ω—Ç.  

–ü–æ-—Ç—Ä—É–¥–Ω–æ –æ—Ç –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ –µ –¥–∞ —Å–µ –¥–µ–±—ä–≥–≤–∞.  

–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –µ –¥–∞ —Å–µ –∑–∞—â–∏—Ç—è—Ç —Ä–µ—Å—É—Ä—Å–∏—Ç–µ.  

–ï–¥–Ω–∞ –Ω–∏—à–∫–∞ –∏–∑–ø–æ–ª–∑–≤–∞ —Ä–µ—Å—É—Ä—Å.  

–û—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ –Ω–∏—à–∫–∏ —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–∑—á–∞–∫–∞—Ç –∑–∞ –¥–æ—Å—Ç—ä–ø –¥–æ —Å—ä—â–∏—è —Ä–µ—Å—É—Ä—Å.  

–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è—Ç–∞ –Ω–∞ –¥–æ—Å—Ç—ä–ø–∞ –¥–æ —Ä–µ—Å—É—Ä—Å–∏ –µ —Ç—Ä—É–¥–Ω–∞.  

–ú–æ–≥–∞—Ç –¥–∞ –≤—ä–∑–Ω–∏–∫–Ω–∞—Ç deadlock —Å—ä—Å—Ç–æ—è–Ω–∏—è (–≤–∑–∞–∏–º–Ω–æ –±–ª–æ–∫–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–∏—à–∫–∏).  
### Code
```csharp
static void PrintNumbersInRange(int a, int b)
{
    for (int i = a; i <= b; i++)
    {
        Console.WriteLine(i);
    }
}

int n = int.Parse(Console.ReadLine());
PrintNumbersInRange(0, 100);
var task = Task.Run(() =>
    PrintNumbersInRange(100, 200));

Console.WriteLine("Done.");
task.Wait();
```

–í —Ç–æ–∑–∏ –ø—Ä–∏–º–µ—Ä:

–ú–µ—Ç–æ–¥—ä—Ç `PrintNumbersInRange` –æ—Ç–ø–µ—á–∞—Ç–≤–∞ —á–∏—Å–ª–∞—Ç–∞ –≤ –∑–∞–¥–∞–¥–µ–Ω –∏–Ω—Ç–µ—Ä–≤–∞–ª.

`PrintNumbersInRange(0, 100)` —Å–µ –∏–∑–≤–∏–∫–≤–∞ –≤ –≥–ª–∞–≤–Ω–∞—Ç–∞ –Ω–∏—à–∫–∞.

 –°–ª–µ–¥ —Ç–æ–≤–∞ —Å–µ —Å—Ç–∞—Ä—Ç–∏—Ä–∞ —Ñ–æ–Ω–æ–≤ `Task`, –∫–æ–π—Ç–æ –∏–∑–≤–∏–∫–≤–∞ `PrintNumbersInRange(100, 200)`.

`Console.WriteLine("Done.")` —Å–µ –æ—Ç–ø–µ—á–∞—Ç–≤–∞ –≤–µ–¥–Ω–∞–≥–∞ —Å–ª–µ–¥ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ—Ç–æ –Ω–∞ –∑–∞–¥–∞—á–∞—Ç–∞, **–ø—Ä–µ–¥–∏** —Ç—è –¥–∞ –∑–∞–≤—ä—Ä—à–∏.

`task.Wait()` –∏–∑—á–∞–∫–≤–∞ –ø—Ä–∏–∫–ª—é—á–≤–∞–Ω–µ—Ç–æ –Ω–∞ —Ñ–æ–Ω–æ–≤–∞—Ç–∞ –∑–∞–¥–∞—á–∞, –ø—Ä–µ–¥–∏ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –¥–∞ –∑–∞–≤—ä—Ä—à–∏.
## Threads
–ï–¥–Ω–∞ **–Ω–∏—à–∫–∞ (thread)** –µ –æ—Å–Ω–æ–≤–Ω–∞ –µ–¥–∏–Ω–∏—Ü–∞ –∑–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ –Ω–∞ –∫–æ–¥.

–û–±–∏–∫–Ω–æ–≤–µ–Ω–æ –µ–¥–∏–Ω –ø—Ä–æ—Ü–µ—Å (–ø—Ä–æ–≥—Ä–∞–º–∞) –∏–∑–ø–æ–ª–∑–≤–∞ –ø–æ–≤–µ—á–µ –æ—Ç –µ–¥–Ω–∞ –Ω–∏—à–∫–∞.

–í .NET **–≤–∏–Ω–∞–≥–∏** –∏–º–∞ –ø–æ–≤–µ—á–µ –æ—Ç –µ–¥–Ω–∞ –Ω–∏—à–∫–∞, –∫–æ–∏—Ç–æ —Å–∞ —á–∏—Å—Ç–æ —Å–ª—É–∂–µ–±–Ω–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä –∑–∞ garbage collector-–∞). –ö–∞–∫–≤–æ—Ç–æ –∏ –¥–∞ –ø–∏—à–µ–º –Ω–∏–µ, —Ç–æ –≤–∏–Ω–∞–≥–∏ –µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ, –≤–∏–Ω–∞–≥–∏ –∏–º–∞ –ø–æ–≤–µ—á–µ –æ—Ç –µ–¥–Ω–∞ –Ω–∏—à–∫–∞, –ø—Ä–æ—Å—Ç–æ –Ω–µ —Å–µ –≥—Ä–∏–∂–∏–º –Ω–∏–µ –∑–∞ —Ç—è—Ö.

–í—Å—è–∫–∞ –Ω–∏—à–∫–∞ –∏–º–∞ —Å–≤—ä—Ä–∑–∞–Ω–∞ —Å –Ω–µ—è –ø–∞–º–µ—Ç–Ω–∞ –æ–±–ª–∞—Å—Ç, –Ω–∞—Ä–µ—á–µ–Ω–∞ **Call Stack**. –¢–∞–º —Å–µ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç **–ª–æ–∫–∞–ª–Ω–∏—Ç–µ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏**. –°—ä—Ö—Ä–∞–Ω—è–≤–∞—Ç —Å–µ –∏ **–≤ –º–æ–º–µ–Ω—Ç–∞ –∏–∑–≤–∏–∫–∞–Ω–∏—Ç–µ –º–µ—Ç–æ–¥–∏** ‚Äì –≤ —Ä–µ–¥–∞, –≤ –∫–æ–π—Ç–æ —Å–∞ –∏–∑–≤–∏–∫–∞–Ω–∏.
### Instruction Execution
–í—Å–µ–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–µ–Ω –∫–æ–¥ —Å–µ –ø—Ä–µ–≤–µ–∂–¥–∞ –≤ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∑–∞ –ø—Ä–æ—Ü–µ—Å–æ—Ä–∞ (CPU –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏).

–ü—Ä–∏–º–µ—Ä ‚Äì –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ –Ω–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:

**`Program.cs`**

```csharp
int a = 5;  
int b = 4;  
Console.WriteLine(a + b);  
```

**‚Üì Compilation ‚Üì**

**`Program.exe`**

```css
00DA2655 mov dword ptr [ebp-40h],5  
00DA265C mov dword ptr [ebp-44h],4  
00DA2663 mov ecx,dword ptr [ebp-40h]  
00DA2666 add ecx,dword ptr [ebp-44h]  
00DA2669 call 73B5A920  
00DA266E nop  
```

–û–±—è—Å–Ω–µ–Ω–∏–µ:

–ü—Ä–∏ –∫–æ–º–ø–∏–ª–∞—Ü–∏—è, C# –∫–æ–¥—ä—Ç —Å–µ –ø—Ä–µ–≤–µ–∂–¥–∞ –≤ –Ω–∏—Å–∫–æ –Ω–∏–≤–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏.

–í—Å—è–∫–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –æ—Ç–≥–æ–≤–∞—Ä—è –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è –Ω–∞ –ø—Ä–æ—Ü–µ—Å–æ—Ä–∞.

–ù–∞–ø—Ä–∏–º–µ—Ä: –ø—Ä–∏—Å–≤–æ—è–≤–∞–Ω–µ –Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏, —Å—ä–±–∏—Ä–∞–Ω–µ –∏ –∏–∑–≤–∏–∫–≤–∞–Ω–µ –Ω–∞ –º–µ—Ç–æ–¥.

Single-Core CPU:

–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏—Ç–µ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞—Ç **–µ–¥–Ω–∞ –ø–æ –µ–¥–Ω–∞** –≤ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–µ–Ω —Ä–µ–¥.

–ù—è–º–∞ –ø–∞—Ä–∞–ª–µ–ª–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ ‚Äì –≤—Å–∏—á–∫–æ —Å—Ç–∞–≤–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–æ.
#### Scheduler
Scheduler-—ä—Ç **–Ω–µ —á–∞–∫–∞** –ø—Ä–æ—Ü–µ—Å–æ—Ä—ä—Ç –¥–∞ —Å–µ –æ—Å–≤–æ–±–æ–¥–∏, **–∞ –∞–∫—Ç–∏–≤–Ω–æ —É–ø—Ä–∞–≤–ª—è–≤–∞ –Ω–∏—à–∫–∏—Ç–µ**, –∫–∞—Ç–æ:

- **–°–ø–∏—Ä–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –Ω–∞ —Ç–µ–∫—É—â–∞—Ç–∞ –Ω–∏—à–∫–∞** –≤ –ø—Ä–æ–∏–∑–≤–æ–ª–µ–Ω –º–æ–º–µ–Ω—Ç (–¥–æ—Ä–∏ –¥–∞ –Ω–µ –µ –ø—Ä–∏–∫–ª—é—á–∏–ª–∞).

- **–ü—É—Å–∫–∞ —Å–ª–µ–¥–≤–∞—â–∞—Ç–∞ –Ω–∏—à–∫–∞** —Å–ø–æ—Ä–µ–¥ –≤—ä—Ç—Ä–µ—à–Ω–∞ –ª–æ–≥–∏–∫–∞ –∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∏.

- –¢–æ–≤–∞ –∑–Ω–∞—á–∏, —á–µ –∫–æ–≥–∞—Ç–æ –∫–∞–∂–µ ‚Äû—Å–µ–≥–∞ —â–µ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞ `Program.exe`‚Äú, –º–æ–∂–µ –¥–∞ –ø—É—Å–Ω–µ **—Å–∞–º–æ –Ω—è–∫–æ–ª–∫–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏** –∏ –≤–µ–¥–Ω–∞–≥–∞ —Å–ª–µ–¥ —Ç–æ–≤–∞ –¥–∞ –ø—Ä–µ–≤–∫–ª—é—á–∏ –Ω–∞ –¥—Ä—É–≥–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä `chrome.exe`).

–¢–∞–∫–∞ —á–µ:

- **–ù–µ —Å–µ –∏–∑—á–∞–∫–≤–∞ –∑–∞–≤—ä—Ä—à–≤–∞–Ω–µ –Ω–∞ –Ω–∏—à–∫–∞—Ç–∞**, –∞ —Å–µ –ø—Ä–∞–≤–∏ **–±—ä—Ä–∑–æ –ø—Ä–µ–≤–∫–ª—é—á–≤–∞–Ω–µ** (context switch).

- –î–æ—Ä–∏ –∞–∫–æ –ø—Ä–æ—Ü–µ—Å–æ—Ä—ä—Ç –µ –Ω–∞ 100% –Ω–∞—Ç–æ–≤–∞—Ä–≤–∞–Ω–µ, **–Ω–µ –∑–Ω–∞—á–∏, —á–µ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –µ –∑–∞–±–∏–ª–∞** ‚Äî –ø—Ä–æ—Å—Ç–æ **–¥—Ä—É–≥–∏ –Ω–∏—à–∫–∏ —Å–∞ —Å–ø—Ä–µ–Ω–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ**, –∑–∞ –¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω–∏ —Ç–µ–∫—É—â–∞—Ç–∞.

- –¢–æ–∑–∏ –ø—Ä–æ—Ü–µ—Å —Å–µ —Å–ª—É—á–≤–∞ **–º–Ω–æ–≥–æ –±—ä—Ä–∑–æ –∏ —Ü–∏–∫–ª–∏—á–Ω–æ** –Ω–∞ –≤—Å—è–∫–æ —è–¥—Ä–æ, —Ç–∞–∫–∞ —á–µ –∏–∑–≥–ª–µ–∂–¥–∞ —Å—è–∫–∞—à –≤—Å–∏—á–∫–æ —Ä–∞–±–æ—Ç–∏ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.

‚è± **–ù—è–º–∞ –≥–∞—Ä–∞–Ω—Ü–∏—è –∑–∞ —Ä–µ–¥ –∏–ª–∏ –ø—Ä–æ–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ—Å—Ç –Ω–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ**

- **–ù–µ –º–æ–∂–µ–º –¥–∞ –ø—Ä–µ–¥–≤–∏–¥–∏–º –∫–æ—è –Ω–∏—à–∫–∞ —â–µ –ø—Ä–∏–∫–ª—é—á–∏ –ø—ä—Ä–≤–∞** ‚Äî –¥–æ—Ä–∏ –∞–∫–æ –µ–¥–Ω–∞ –∑–∞–¥–∞—á–∞ –∏–∑–≥–ª–µ–∂–¥–∞ –∫—Ä–∞—Ç–∫–∞, —Ç—è **–º–æ–∂–µ –¥–∞ –±—ä–¥–µ –æ—Ç–ª–æ–∂–µ–Ω–∞** –ø–æ—Ä–∞–¥–∏ –Ω–∞—Ç–æ–≤–∞—Ä–≤–∞–Ω–µ—Ç–æ –Ω–∞ —Å–∏—Å—Ç–µ–º–∞—Ç–∞.

- –ù–∞–ø—Ä–∏–º–µ—Ä: –∞–∫–æ –∑–Ω–∞–µ–º, —á–µ –µ–¥–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–Ω–µ–º–∞ —Ç–æ—á–Ω–æ **10ms**, –∏ –Ω—è–º–∞ –¥—Ä—É–≥–∏ –∞–∫—Ç–∏–≤–Ω–∏ –Ω–∏—à–∫–∏ ‚Äî —Ç—è —â–µ —Å–µ –∏–∑–ø—ä–ª–Ω–∏ –∑–∞ 10ms.

- **–ù–æ –∞–∫–æ –º–∞—à–∏–Ω–∞—Ç–∞ –µ –Ω–∞—Ç–æ–≤–∞—Ä–µ–Ω–∞**, scheduler-—ä—Ç —â–µ –ø—Ä–µ–∫—ä—Å–≤–∞ –Ω–∞—à–∞—Ç–∞ –Ω–∏—à–∫–∞ –Ω—è–∫–æ–ª–∫–æ –ø—ä—Ç–∏, –∑–∞ –¥–∞ –¥–∞–¥–µ –≤—Ä–µ–º–µ –Ω–∞ –¥—Ä—É–≥–∏ –ø—Ä–æ—Ü–µ—Å–∏.

- –¢–∞–∫–∞ –æ–±—â–æ—Ç–æ –≤—Ä–µ–º–µ –Ω–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ —â–µ —Å–∏ –æ—Å—Ç–∞–Ω–µ 10ms, –Ω–æ **—â–µ –±—ä–¥–µ —Ä–∞–∑–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –≤—ä–≤ –≤—Ä–µ–º–µ—Ç–æ**, –Ω–∞–ø—Ä–∏–º–µ—Ä:

    - —Å—Ç–∞—Ä—Ç–∏—Ä–∞ –∑–∞ 2ms

    - –ø–æ—Å–ª–µ —á–∞–∫–∞, –∑–∞—â–æ—Ç–æ –¥—Ä—É–≥ –ø—Ä–æ—Ü–µ—Å –∑–∞–µ–º–∞ CPU

    - –ø–æ—Å–ª–µ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞ –æ—â–µ 3ms

    - –∏ —Ç.–Ω., –¥–æ–∫–∞—Ç–æ –Ω–∞—Ç—Ä—É–ø–∞ 10ms –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ
        
    - –Ω–æ —Ä–µ–∞–ª–Ω–æ **–∑–∞–≤—ä—Ä—à–≤–∞ —Å–ª–µ–¥ 30ms** –Ω–∞–ø—Ä–∏–º–µ—Ä

–¢–æ–µ—Å—Ç: **–∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –µ –±—ä—Ä–∑–æ, –Ω–æ –Ω–µ –∏ –Ω–µ–ø—Ä–µ–∫—ä—Å–Ω–∞—Ç–æ** ‚Äì —Ç–æ–≤–∞ –∑–∞–≤–∏—Å–∏ –æ—Ç –Ω–∞—Ç–æ–≤–∞—Ä–≤–∞–Ω–µ—Ç–æ –Ω–∞ —Å–∏—Å—Ç–µ–º–∞—Ç–∞ –∏ —Ä–µ—à–µ–Ω–∏—è—Ç–∞ –Ω–∞ scheduler-–∞.

Scheduler-—ä—Ç **—É–º–∏—à–ª–µ–Ω–æ –ø—Ä–µ–≤–∫–ª—é—á–≤–∞ –º–µ–∂–¥—É –Ω–∏—à–∫–∏—Ç–µ**, –∑–∞ –¥–∞ —Å—ä–∑–¥–∞–¥–µ –∏–ª—é–∑–∏—è –∑–∞ –ø–∞—Ä–∞–ª–µ–ª–Ω–æ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ, –¥–æ—Ä–∏ –∫–æ–≥–∞—Ç–æ –∏–º–∞ —Å–∞–º–æ –µ–¥–Ω–æ —è–¥—Ä–æ. –¶–µ–ª—Ç–∞ –º—É –Ω–µ –µ –¥–∞ –∏–∑—á–∞–∫–∞ –¥–∞–¥–µ–Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –¥–∞ —Å–≤—ä—Ä—à–∏, –∞:

- –¥–∞ **—Ä–∞–∑–ø—Ä–µ–¥–µ–ª–∏ –≤—Ä–µ–º–µ—Ç–æ –Ω–∞ –ø—Ä–æ—Ü–µ—Å–æ—Ä–∞** –º–µ–∂–¥—É –≤—Å–∏—á–∫–∏ –∞–∫—Ç–∏–≤–Ω–∏ –Ω–∏—à–∫–∏

- –¥–∞ **–ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏ –∑–∞–±–∏–≤–∞–Ω–µ** –∏–ª–∏ –±–ª–æ–∫–∏—Ä–∞–Ω–µ –Ω–∞ —Ü—è–ª–∞—Ç–∞ —Å–∏—Å—Ç–µ–º–∞ –æ—Ç —Ç–µ–∂–∫–∞ –∏–ª–∏ –±–∞–≤–Ω–æ –∏–∑–ø—ä–ª–Ω—è–≤–∞—â–∞ —Å–µ –ø—Ä–æ–≥—Ä–∞–º–∞

- –¥–∞ **–≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞, —á–µ –≤—Å—è–∫–∞ –Ω–∏—à–∫–∞ –ø–æ–ª—É—á–∞–≤–∞ –º–∞–ª–∫–æ "–≤—Ä–µ–º–µ –Ω–∞ —Å—Ü–µ–Ω–∞—Ç–∞"**

üìå –í—Å—è–∫–∞ –Ω–∏—à–∫–∞ —Å–∏ –∏–∑–ø—ä–ª–Ω—è–≤–∞ —Å–≤–æ—è—Ç–∞ –ª–æ–≥–∏–∫–∞ –∏ –Ω–µ –∑–Ω–∞–µ –∫–∞–∫–≤–æ —Å—Ç–∞–≤–∞ —Å –¥—Ä—É–≥–∏—Ç–µ. –ù–æ scheduler-—ä—Ç —è –ø—Ä–µ–∫—ä—Å–≤–∞, –∑–∞ –¥–∞ –¥–∞–¥–µ –ø—ä—Ç –Ω–∞ –¥—Ä—É–≥–∞ –Ω–∏—à–∫–∞ ‚Äì —Ç–æ–≤–∞ —Å–µ –Ω–∞—Ä–∏—á–∞ **preemptive multitasking.**

**–ü—Ä–∏–º–µ—Ä –∑–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ –Ω–∞ –Ω–∏—à–∫–∏**

–ò–º–∞–º–µ **—Ç—Ä–∏ –ø—Ä–æ–≥—Ä–∞–º–∏**: `Program A`, `Program B` –∏ `Program C`.

|–í—Ä–µ–º–µ|CPU –≤—Ä–µ–º–µ–≤–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ|
|---|---|
|0ms|Program A (1ms)|
|1ms|Program B (1ms)|
|2ms|Program A (1ms)|
|3ms|Program C (1ms)|
|4ms|Program A (1ms)|
|5ms|Program B (1ms)|
|6ms|Program A (1ms)|
|7ms|Program C (1ms)|
|8ms|Program B (1ms)|
|9ms|Program A (1ms)|

- **Program A**, **Program B** –∏ **Program C** –Ω–µ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞—Ç –Ω–µ–ø—Ä–µ–∫—ä—Å–Ω–∞—Ç–æ.

- Scheduler-—ä—Ç –ø—Ä–µ–≤–∫–ª—é—á–≤–∞ –º–µ–∂–¥—É —Ç—è—Ö –Ω–∞ –≤—Å–µ–∫–∏ 1ms.

- –í—ä–ø—Ä–µ–∫–∏ —á–µ –≤—Å—è–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –µ –∑–∞–ø–æ—á–Ω–∞–ª–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ —Å–∏, —Ç—è —â–µ –±—ä–¥–µ –ø—Ä–µ–∫—ä—Å–Ω–∞—Ç–∞ —Å–ª–µ–¥ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –≤—Ä–µ–º–µ, –∑–∞ –¥–∞ –º–æ–∂–µ –¥—Ä—É–≥–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–∏ –¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞—Ç —Å—ä—â–æ.

- –¢–æ–≤–∞ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞, —á–µ –≤—Å–∏—á–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–∏ –∏–º–∞—Ç –≤—Ä–µ–º–µ –¥–∞ —Ä–∞–±–æ—Ç—è—Ç –≤—ä—Ä—Ö—É –ø—Ä–æ—Ü–µ—Å–æ—Ä–∞, –±–µ–∑ –µ–¥–Ω–∞ –¥–∞ –±–ª–æ–∫–∏—Ä–∞ –æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ.

–¢–æ–≤–∞ –µ –ø—Ä–∏–Ω—Ü–∏–ø—ä—Ç –Ω–∞ **multitasking** –∏ –∫–∞–∫ scheduler-—ä—Ç —Å–µ –≥—Ä–∏–∂–∏ –∑–∞ **–±–∞–ª–∞–Ω—Å–∏—Ä–∞–Ω–æ —Ä–∞–∑–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ —Ä–µ—Å—É—Ä—Å–∏—Ç–µ**.

**–í–∞–∂–Ω–æ:**

- **–ï–¥–Ω–∞ –Ω–∏—à–∫–∞** –º–æ–∂–µ –¥–∞ –∏–∑–ø—ä–ª–Ω—è–≤–∞ —á–∞—Å—Ç–∏ –æ—Ç **–º–Ω–æ–∂–µ—Å—Ç–≤–æ –ø—Ä–æ–≥—Ä–∞–º–∏**, –Ω–æ —Ç—è –º–æ–∂–µ –¥–∞ –∏–∑–ø—ä–ª–Ω—è–≤–∞ —Å–∞–º–æ **–µ–¥–Ω–∞ –∑–∞–¥–∞—á–∞ –ø–æ –µ–¥–Ω–æ –≤—Ä–µ–º–µ**.

- –ê–∫–æ –∏–º–∞–º–µ –ø–æ–≤–µ—á–µ –Ω–∏—à–∫–∏, –≤—Å—è–∫–∞ –Ω–∏—à–∫–∞ —â–µ –º–æ–∂–µ –¥–∞ –∏–∑–ø—ä–ª–Ω—è–≤–∞ **–µ–¥–Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –∏–ª–∏ –∑–∞–¥–∞—á–∞** –ø–æ –µ–¥–Ω–æ –≤—Ä–µ–º–µ, –Ω–æ –Ω–∞ –µ–¥–Ω–æ —è–¥—Ä–æ –≤—Å–µ –æ—â–µ –Ω—è–º–∞ —Ä–µ–∞–ª–µ–Ω –ø–∞—Ä–∞–ª–µ–ª–∏–∑—ä–º, –æ—Å–≤–µ–Ω –∞–∫–æ –Ω–µ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ **–º–Ω–æ–≥–æ —è–¥—Ä–∞**.

–¢–∞–∫–∞, —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω –±—Ä–æ–π –Ω–∏—à–∫–∏, –≤—Å—è–∫–∞ –Ω–∏—à–∫–∞ –º–æ–∂–µ –¥–∞ –∏–∑–ø—ä–ª–Ω—è–≤–∞ **—á–∞—Å—Ç–∏ –æ—Ç —Ä–∞–∑–ª–∏—á–Ω–∏ –ø—Ä–æ–≥—Ä–∞–º–∏**, –Ω–æ —Ü–µ–ª–∏—è—Ç –ø—Ä–æ—Ü–µ—Å –µ **—Å–∏–º—É–ª–∏—Ä–∞–Ω –ø–∞—Ä–∞–ª–µ–ª–∏–∑—ä–º**, –Ω–µ –∏—Å—Ç–∏–Ω—Å–∫–∏ —Ç–∞–∫—ä–≤.
### Multi-Tasking
–ï–¥–∏–Ω –∫–æ–º–ø—é—Ç—ä—Ä –º–æ–∂–µ –¥–∞ –∏–∑–ø—ä–ª–Ω—è–≤–∞ –º–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å–∏ (–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è) –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.

–ù–æ –≤—Å—è–∫–æ —è–¥—Ä–æ –Ω–∞ –ø—Ä–æ—Ü–µ—Å–æ—Ä–∞ –º–æ–∂–µ –¥–∞ –∏–∑–ø—ä–ª–Ω—è–≤–∞ —Å–∞–º–æ **–µ–¥–Ω–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –Ω–∞–≤–µ–¥–Ω—ä–∂**.

–ü–∞—Ä–∞–ª–µ–ª–∏–∑–º—ä—Ç (parallelism) —Å–µ –ø–æ—Å—Ç–∏–≥–∞ —á—Ä–µ–∑ scheduler –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—Ç–∞ —Å–∏—Å—Ç–µ–º–∞. –ë—Ä–æ—è—Ç –Ω–∞ –ø—Ä–æ—Ü–µ—Å–æ—Ä–Ω–∏—Ç–µ —è–¥—Ä–∞ –Ω–µ –µ –¥–æ—Å—Ç–∞—Ç—ä—á–µ–Ω, –∑–∞ –¥–∞ –º–æ–∂–µ –≤—Å—è–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞ –Ω–∞ –æ—Ç–¥–µ–ª–Ω–∞ –Ω–∏—à–∫–∞ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ. –ó–∞—Ç–æ–≤–∞ scheduler-—ä—Ç —Ä–∞–∑–ø—Ä–µ–¥–µ–ª—è –ø—Ä–æ—Ü–µ—Å–æ—Ä–Ω–æ—Ç–æ –≤—Ä–µ–º–µ –º–µ–∂–¥—É –º–Ω–æ–∂–µ—Å—Ç–≤–æ –Ω–∏—à–∫–∏, –∫–∞—Ç–æ –∏–º –¥–∞–≤–∞ –∫—Ä–∞—Ç–∫–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∏ –∑–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ.

–¢–æ–π –¥–∞–≤–∞ –Ω–∞ –≤—Å—è–∫–∞ –Ω–∏—à–∫–∞ –º–∞–ª—ä–∫ –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ—Ç –≤—Ä–µ–º–µ –∑–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ.

–¢–æ–≤–∞ –ø–æ–≤–µ–¥–µ–Ω–∏–µ —Å–µ –Ω–∞—Ä–∏—á–∞ **–º—É–ª—Ç–∏—Ç–∞—Å–∫–∏–Ω–≥**.

–ö–æ–ª–∫–æ—Ç–æ –ø–æ–≤–µ—á–µ —è–¥—Ä–∞ –∏–º–∞ –ø—Ä–æ—Ü–µ—Å–æ—Ä—ä—Ç, —Ç–æ–ª–∫–æ–≤–∞ –ø–æ–≤–µ—á–µ –Ω–∏—à–∫–∏ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –∏–∑–ø—ä–ª–Ω—è–≤–∞–Ω–∏ **–∏—Å—Ç–∏–Ω—Å–∫–∏ –ø–∞—Ä–∞–ª–µ–ª–Ω–æ**, –∞ –Ω–µ —Å–∞–º–æ —á—Ä–µ–∑ –±—ä—Ä–∑–æ –ø—Ä–µ–≤–∫–ª—é—á–≤–∞–Ω–µ.
–ü—Ä–∏–º–µ—Ä –∑–∞ —Ä–∞–∑–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –≤—Ä–µ–º–µ—Ç–æ –≤ –µ–¥–Ω–∞ –Ω–∏—à–∫–∞ (–Ω–∞ –µ–¥–Ω–æ —è–¥—Ä–æ):

program.exe‚ÄÉchrome.exe‚ÄÉwinamp.exe‚ÄÉsystem.exe‚ÄÉprogram.exe ...
0‚ÄÉ 5 ms‚ÄÉ          10 ms‚ÄÉ          15 ms‚ÄÉ          20 ms‚ÄÉ        25 ms  

–¢—É–∫ –≤—Å—è–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –ø–æ–ª—É—á–∞–≤–∞ –∫—Ä–∞—Ç—ä–∫ –∏–Ω—Ç–µ—Ä–≤–∞–ª –∑–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ (–Ω–∞–ø—Ä. 5 –º–∏–ª–∏—Å–µ–∫—É–Ω–¥–∏), —Å–ª–µ–¥ –∫–æ–µ—Ç–æ scheduler-—ä—Ç –ø—Ä–µ–≤–∫–ª—é—á–≤–∞ –∫—ä–º —Å–ª–µ–¥–≤–∞—â–∞—Ç–∞. –ê–∫–æ –∏–º–∞ –ø–æ–≤–µ—á–µ —è–¥—Ä–∞, –ø–æ–¥–æ–±–Ω–∏ —Ä–µ–¥–æ–≤–µ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞—Ç –ø–∞—Ä–∞–ª–µ–ª–Ω–æ.
### Threads in CSharp
–ù–∏—à–∫–∏ –≤ C# –º–æ–≥–∞—Ç –¥–∞ —Å–µ —Å—ä–∑–¥–∞–≤–∞—Ç —á—Ä–µ–∑ –∫–ª–∞—Å–∞ **`System.Threading.Thread`**.

–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ä—Ç –ø—Ä–∏–µ–º–∞ –º–µ—Ç–æ–¥ (–¥–µ–ª–µ–≥–∞—Ç), –∫–æ–π—Ç–æ –¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω–∏ –≤ –æ—Ç–¥–µ–ª–Ω–∞ –Ω–∏—à–∫–∞.

```csharp
Thread thread = new Thread(() =>
{
    for (int i = 0; i < 10; i++)
    {
        Console.WriteLine(i);
    }
});
```

–†–∞–∑–ª–∏–∫–∞—Ç–∞ –º–µ–∂–¥—É `Task.Run()` –∏ `System.Threading.Thread` –µ, —á–µ –∫–æ–≥–∞—Ç–æ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ `Task.Run()`, **–Ω–µ —Å—ä–∑–¥–∞–≤–∞–º–µ –Ω–æ–≤–∞ –Ω–∏—à–∫–∞ –¥–∏—Ä–µ–∫—Ç–Ω–æ**, –∞ –¥–∞–≤–∞–º–µ –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—Ç–∞ —Å–∏—Å—Ç–µ–º–∞ –∏ framework-–∞ –≤—ä–∑–º–æ–∂–Ω–æ—Å—Ç –¥–∞ –ø—Ä–µ—Ü–µ–Ω—è—Ç –¥–∞–ª–∏ –µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–∞ —Å—ä–∑–¥–∞–¥–∞—Ç –Ω–æ–≤–∞ –Ω–∏—à–∫–∞. –ê–∫–æ —Å–∏—Å—Ç–µ–º–∞—Ç–∞ –µ —Å–∏–ª–Ω–æ –Ω–∞—Ç–æ–≤–∞—Ä–µ–Ω–∞ –∏ –Ω—è–º–∞ –Ω–∞–ª–∏—á–Ω–∏ —Ä–µ—Å—É—Ä—Å–∏, –º–æ–∂–µ –¥–∞ –Ω–µ –±—ä–¥–µ —Å—ä–∑–¥–∞–¥–µ–Ω–∞ –Ω–æ–≤–∞ –Ω–∏—à–∫–∞. –ò–∑–ø–æ–ª–∑–≤–∞–Ω–µ—Ç–æ –Ω–∞ `Task` –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–≤–∞ –ø–æ-—Å–ª–æ–∂–µ–Ω –ø—Ä–æ—Ü–µ—Å, –≤ –∫–æ–π—Ç–æ framework-—ä—Ç –∏ –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—Ç–∞ —Å–∏—Å—Ç–µ–º–∞ —Ä–µ—à–∞–≤–∞—Ç –Ω–∞–π-–µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏—è –Ω–∞—á–∏–Ω –∑–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ –Ω–∞ –∑–∞–¥–∞—á–∞—Ç–∞, –Ω–æ –∑–∞ –Ω–∞—Å —Ç–æ —Ä–∞–±–æ—Ç–∏ –∫–∞—Ç–æ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ, –ø–æ–¥–æ–±–Ω–æ –Ω–∞ –Ω–æ–≤–∞ –Ω–∏—à–∫–∞.

–û–±–∞—á–µ, –∫–æ–≥–∞—Ç–æ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ **`System.Threading.Thread`**, –Ω–∏–µ **–∑–∞–¥—ä–ª–∂–∞–≤–∞–º–µ framework-–∞ –¥–∞ —Å—ä–∑–¥–∞–¥–µ –Ω–æ–≤–∞ –Ω–∏—à–∫–∞**. –¢–æ–≤–∞ –µ –ø–æ-–º–∞–ª–∫–æ –≥—ä–≤–∫–∞–≤ –ø–æ–¥—Ö–æ–¥, –ø—Ä–∏ –∫–æ–π—Ç–æ –Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–Ω–æ –∏–∑–∏—Å–∫–≤–∞–º–µ –Ω–æ–≤–∞ –Ω–∏—à–∫–∞, –±–µ–∑ –¥–∞ –æ—Å—Ç–∞–≤—è–º–µ –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—Ç–∞ —Å–∏—Å—Ç–µ–º–∞ –¥–∞ –≤–∑–µ–º–µ —Ä–µ—à–µ–Ω–∏–µ –∑–∞ –Ω–µ—è.
### `System.Thread`
 **`Start()`** ‚Äì –ø–ª–∞–Ω–∏—Ä–∞ –Ω–∏—à–∫–∞—Ç–∞ –∑–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ, —Ç–æ–µ—Å—Ç –≤–ª–∏–∑–∞ –≤ scheduler, –∞ —Ç–æ–π –ø—Ä–µ—Ü–µ–Ω—è–≤–∞ –∫–æ–≥–∞ –∫—ä–¥–µ –∏ –∫–∞–∫ –¥–∞ –≥–æ –ø—É—Å–Ω–µ -  **—Ç–æ–µ—Å—Ç –Ω–µ —É–ø—Ä–∞–≤–ª—è–≤–∞–º–µ –¥–∏—Ä–µ–∫—Ç–Ω–æ –≤—Ä–µ–º–µ—Ç–æ** –Ω–∞ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ. –†–µ–∞–ª–Ω–æ—Ç–æ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ —Å–µ —Å–ª—É—á–≤–∞, –∫–æ–≥–∞—Ç–æ scheduler-—ä—Ç —Ä–µ—à–∏, —á–µ –µ –≤—Ä–µ–º–µ.

**`Join()`** ‚Äì –∏–∑—á–∞–∫–≤–∞ –Ω–∏—à–∫–∞—Ç–∞ –¥–∞ –∑–∞–≤—ä—Ä—à–∏ —Ä–∞–±–æ—Ç–∞—Ç–∞ —Å–∏ (–±–ª–æ–∫–∏—Ä–∞ –∏–∑–≤–∏–∫–≤–∞—â–∞—Ç–∞ –Ω–∏—à–∫–∞, –¥–æ–∫–∞—Ç–æ –ø—Ä–∏–∫–ª—é—á–∏).

–ü—Ä–∏–º–µ—Ä:

```csharp
Thread primes = new Thread(() =>
{
    PrintPrimesInRange(1, 10000);
});

primes.Start();

Console.WriteLine("Waiting for thread to finish work...");

primes.Join();  // Blocks the main thread until the 'primes' thread completes
```

**`Start()`** —Å—Ç–∞—Ä—Ç–∏—Ä–∞ –Ω–æ–≤–∞—Ç–∞ –Ω–∏—à–∫–∞, –∫–æ—è—Ç–æ –∑–∞–ø–æ—á–≤–∞ –¥–∞ –∏–∑–ø—ä–ª–Ω—è–≤–∞ –∫–æ–¥–∞ –≤ –¥–µ–ª–µ–≥–∞—Ç–∞ (–≤ —Å–ª—É—á–∞—è –º–µ—Ç–æ–¥—ä—Ç `PrintPrimesInRange`).

**`Join()`** –±–ª–æ–∫–∏—Ä–∞ –≥–ª–∞–≤–Ω–∞—Ç–∞ –Ω–∏—à–∫–∞, –¥–æ–∫–∞—Ç–æ –Ω–∏—à–∫–∞—Ç–∞ `primes` –Ω–µ –ø—Ä–∏–∫–ª—é—á–∏ —Ä–∞–±–æ—Ç–∞—Ç–∞ —Å–∏.

**Example:**

```csharp
List<long> numbers = new List<long>();

Thread t = new Thread(() =>
 SumOddNumbers(numbers, 10, 100000000L));
 
t.Start();

Console.WriteLine("What should I do?");

while (true)
{
 string command = Console.ReadLine();
 if (command == "exit") break;
}

t.Join();

void SumOddNumbers(List<long> numbers, long start, long end)
{
    long sum = 0;
    for (long i = start; i <= end; i++)
    {
        if (i % 2 != 0) // Check if the number is odd
        {
            sum += i;
        }
    }
    numbers.Add(sum); // Store the result in the numbers list
    
    Console.WriteLine($"Sum of odd numbers between {start} and {end} is: {sum}");
}
```

–í –ø—Ä–∏–º–µ—Ä–∞ —Å–µ —Å—ä–∑–¥–∞–≤–∞ –Ω–æ–≤–∞ –Ω–∏—à–∫–∞ —Å `Thread`, –∫–æ—è—Ç–æ –∏–∑–ø—ä–ª–Ω—è–≤–∞ –º–µ—Ç–æ–¥–∞ `SumOddNumbers` –∑–∞ –∏–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ —Å—É–º–∞—Ç–∞ –Ω–∞ –Ω–µ—á–µ—Ç–Ω–∏—Ç–µ —á–∏—Å–ª–∞ –≤ –¥–∞–¥–µ–Ω –¥–∏–∞–ø–∞–∑–æ–Ω. –î–æ–∫–∞—Ç–æ –Ω–∏—à–∫–∞—Ç–∞ —Ä–∞–±–æ—Ç–∏, –æ—Å–Ω–æ–≤–Ω–∞—Ç–∞ –Ω–∏—à–∫–∞ –º–æ–∂–µ –¥–∞ –ø—Ä–æ–¥—ä–ª–∂–∏ –¥–∞ –ø—Ä–∏–µ–º–∞ –∫–æ–º–∞–Ω–¥–∏ –æ—Ç –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è. –°–ª–µ–¥ –∫–∞—Ç–æ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è—Ç –≤—ä–≤–µ–¥–µ –∫–æ–º–∞–Ω–¥–∞—Ç–∞ `exit`, –æ—Å–Ω–æ–≤–Ω–∞—Ç–∞ –Ω–∏—à–∫–∞ –∏–∑—á–∞–∫–≤–∞ –∑–∞–≤—ä—Ä—à–≤–∞–Ω–µ—Ç–æ –Ω–∞ —Ñ–æ–Ω–æ–≤–∞—Ç–∞ –Ω–∏—à–∫–∞ —á—Ä–µ–∑ `t.Join()` –ø—Ä–µ–¥–∏ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –¥–∞ –ø—Ä–∏–∫–ª—é—á–∏.
### Thread Stack
–í—Å—è–∫–∞ –Ω–∏—à–∫–∞ –∏–º–∞ —Å–≤–æ–π —Å–æ–±—Å—Ç–≤–µ–Ω —Å—Ç–µ–∫  
- –ù–∞—á–∞–ª–æ—Ç–æ (–¥—ä–Ω–æ—Ç–æ) –Ω–∞ —Å—Ç–µ–∫–∞ –µ –º–µ—Ç–æ–¥—ä—Ç, –æ—Ç –∫–æ–π—Ç–æ –Ω–∏—à–∫–∞—Ç–∞ –∑–∞–ø–æ—á–≤–∞ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ.

- –í—Å–µ–∫–∏ –º–µ—Ç–æ–¥ (—Ä–∞–º–∫–∞) —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –ª–æ–∫–∞–ª–Ω–∏ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏.

**–°—Ç–µ–∫ –Ω–∞ –Ω–∏—à–∫–∞—Ç–∞**  
...  
**`IsPrime()`**  
**`PrintAllPrimes()`**  
**`Main()`**  
main thread

...  
**`IsValidUrl()`**  
**`DownloadAsync()`**  
background thread
### Thread Race Condition
**Race condition** –≤—ä–∑–Ω–∏–∫–≤–∞, –∫–æ–≥–∞—Ç–æ –¥–≤–∞ –∏–ª–∏ –ø–æ–≤–µ—á–µ –Ω–∏—à–∫–∏ –∏–º–∞—Ç –¥–æ—Å—Ç—ä–ø –¥–æ —Å–ø–æ–¥–µ–ª–µ–Ω–∏ –¥–∞–Ω–Ω–∏ –∏ —Å–µ –æ–ø–∏—Ç–≤–∞—Ç –¥–∞ –≥–∏ –ø—Ä–æ–º–µ–Ω—è—Ç –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.

**–ü—Ä–∏–º–µ—Ä:**

```csharp
List<int> numbers = Enumerable.Range(0, 10000).ToList();
for (int i = 0; i < 4; i++)
{
    new Thread(() =>
    {
        while (numbers.Count > 0)
            numbers.RemoveAt(numbers.Count - 1);
    }).Start();
}
```

–í —Ç–æ–∑–∏ –ø—Ä–∏–º–µ—Ä –∏–º–∞–º–µ —Å–ø–∏—Å—ä–∫ –æ—Ç —Ü–µ–ª–∏ —á–∏—Å–ª–∞ (`numbers`), –∏ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –Ω–∏—à–∫–∏ —Å–µ –æ–ø–∏—Ç–≤–∞—Ç –¥–∞ –ø—Ä–µ–º–∞—Ö–≤–∞—Ç –µ–ª–µ–º–µ–Ω—Ç–∏ –æ—Ç –Ω–µ–≥–æ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ. –¢—ä–π –∫–∞—Ç–æ —Å–ø–∏—Å—ä–∫—ä—Ç (`numbers`) –µ —Å–ø–æ–¥–µ–ª–µ–Ω –º–µ–∂–¥—É –Ω–∏—à–∫–∏—Ç–µ, —Ç–µ –º–æ–≥–∞—Ç –¥–∞ —Å–µ –Ω–∞–º–µ—Å–≤–∞—Ç –µ–¥–Ω–∞ –≤ –¥—Ä—É–≥–∞, –∫–æ–≥–∞—Ç–æ –ø–æ–ª—É—á–∞–≤–∞—Ç –¥–æ—Å—Ç—ä–ø –∏ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–∞—Ç –¥–∞–Ω–Ω–∏—Ç–µ. –¢–æ–≤–∞ –≤–æ–¥–∏ –¥–æ **race condition.**

–ö–∞–∫ –º–æ–∂–µ –¥–∞ —Å–µ —Å–ª—É—á–∏ race condition –≤ —Ç–æ–∑–∏ –ø—Ä–∏–º–µ—Ä:

1. **–°–ø–æ–¥–µ–ª–µ–Ω —Ä–µ—Å—É—Ä—Å**: –°–ø–∏—Å—ä–∫—ä—Ç `numbers` –µ —Å–ø–æ–¥–µ–ª–µ–Ω –º–µ–∂–¥—É –≤—Å–∏—á–∫–∏ –Ω–∏—à–∫–∏, –∫–∞—Ç–æ –≤—Å—è–∫–∞ –Ω–∏—à–∫–∞ —Å–µ –æ–ø–∏—Ç–≤–∞ –¥–∞ –∏–∑–ø—ä–ª–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏—è—Ç–∞ `RemoveAt(numbers.Count - 1)` (–ø—Ä–µ–º–∞—Ö–≤–∞ –ø–æ—Å–ª–µ–¥–Ω–∏—è –µ–ª–µ–º–µ–Ω—Ç –æ—Ç —Å–ø–∏—Å—ä–∫–∞).
    
2. **–ï–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–µ–Ω –¥–æ—Å—Ç—ä–ø**: –ú–Ω–æ–∂–µ—Å—Ç–≤–æ –Ω–∏—à–∫–∏ –º–æ–≥–∞—Ç –¥–∞ —Å–µ –æ–ø–∏—Ç–≤–∞—Ç –¥–∞ –ø—Ä–µ–º–∞—Ö–Ω–∞—Ç –µ–ª–µ–º–µ–Ω—Ç–∏ –æ—Ç —Å–ø–∏—Å—ä–∫–∞ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ. –ö–æ–≥–∞—Ç–æ –¥–≤–µ –Ω–∏—à–∫–∏ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ —á–µ—Ç–∞—Ç —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ `numbers.Count`, —Ç–µ –º–æ–∂–µ –¥–∞ —Å–º—è—Ç–∞—Ç, —á–µ –ø—Ä–µ–º–∞—Ö–≤–∞—Ç –ø–æ—Å–ª–µ–¥–Ω–∏—è –µ–ª–µ–º–µ–Ω—Ç –æ—Ç —Å–ø–∏—Å—ä–∫–∞, –Ω–æ –≤—Å—ä—â–Ω–æ—Å—Ç –º–æ–≥–∞—Ç –¥–∞ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–∞—Ç —Å—ä—â–∏—è –µ–ª–µ–º–µ–Ω—Ç –∏–ª–∏ –¥–∞ –ø—Ä–µ–º–∞—Ö–Ω–∞—Ç –ø–æ-–º–∞–ª–∫–æ –µ–ª–µ–º–µ–Ω—Ç–∏ –æ—Ç –æ—á–∞–∫–≤–∞–Ω–æ—Ç–æ.
    
3. **–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω —Ä–µ–∑—É–ª—Ç–∞—Ç**: –í —Ä–µ–∑—É–ª—Ç–∞—Ç –Ω–∞ —Ç–æ–≤–∞, –µ–ª–µ–º–µ–Ω—Ç–∏ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –ø—Ä–µ–º–∞—Ö–≤–∞–Ω–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª–Ω–æ –∏–ª–∏ –Ω—è–∫–æ–∏ –µ–ª–µ–º–µ–Ω—Ç–∏ –º–æ–∂–µ –¥–∞ –Ω–µ –±—ä–¥–∞—Ç –ø—Ä–µ–º–∞—Ö–Ω–∞—Ç–∏ –∏–∑–æ–±—â–æ, –∑–∞—â–æ—Ç–æ –Ω–∏—à–∫–∏—Ç–µ –Ω–µ –∫–æ–æ—Ä–¥–∏–Ω–∏—Ä–∞—Ç –ø—Ä–∞–≤–∏–ª–Ω–æ –¥–æ—Å—Ç—ä–ø–∞ —Å–∏ –¥–æ —Å–ø–æ–¥–µ–ª–µ–Ω–∏—Ç–µ –¥–∞–Ω–Ω–∏.
### Thread Safety
–†–µ—Å—É—Ä—Å, –∫–æ–π—Ç–æ –µ **–ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–µ–Ω**, –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ –¥–æ—Å—Ç—ä–ø–µ–Ω –æ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –Ω–∏—à–∫–∏ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.

- –ö–ª—é—á–æ–≤–∞—Ç–∞ –¥—É–º–∞ `lock` –¥–∞–≤–∞ –¥–æ—Å—Ç—ä–ø —Å–∞–º–æ –Ω–∞ –µ–¥–Ω–∞ –Ω–∏—à–∫–∞ –ø–æ –≤—Ä–µ–º–µ.

- –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç—è–≤–∞ **race conditions.**

- –ë–ª–æ–∫–∏—Ä–∞ –≤—Å–∏—á–∫–∏ –¥—Ä—É–≥–∏ –Ω–∏—à–∫–∏, –¥–æ–∫–∞—Ç–æ –∑–∞–∫–ª—é—á–≤–∞–Ω–µ—Ç–æ –Ω–µ –±—ä–¥–µ –æ—Å–≤–æ–±–æ–¥–µ–Ω–æ.

```csharp
lock (numbers)
{
    if (numbers.Count == 0) break;
    int lastIndex = numbers.Count - 1;
    numbers.RemoveAt(lastIndex);
}
```

–ó–∞ –¥–∞ –∏–∑–±–µ–≥–Ω–µ–º race condition, –∫–æ–≥–∞—Ç–æ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–∞–º–µ —Å–ø–æ–¥–µ–ª–µ–Ω–∏ –¥–∞–Ω–Ω–∏ –∫–∞—Ç–æ —Å–ø–∏—Å—ä—Ü–∏, –º–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω–∏ –º–µ—Ö–∞–Ω–∏–∑–º–∏ –∫–∞—Ç–æ **–∑–∞–∫–ª—é—á–≤–∞–Ω–∏—è (locks)** –∏–ª–∏ –¥—Ä—É–≥–∏ —Å—Ä–µ–¥—Å—Ç–≤–∞ –∑–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è, –∑–∞ –¥–∞ –æ—Å–∏–≥—É—Ä–∏–º, —á–µ —Å–∞–º–æ –µ–¥–Ω–∞ –Ω–∏—à–∫–∞ –º–æ–∂–µ –¥–∞ –¥–æ—Å—Ç—ä–ø–≤–∞ —Å–ø–æ–¥–µ–ª–µ–Ω–∏—Ç–µ –¥–∞–Ω–Ω–∏ –ø–æ –µ–¥–Ω–æ –∏ —Å—ä—â–æ –≤—Ä–µ–º–µ.

**–ò–∑–ø–æ–ª–∑–≤–∞–Ω–µ –Ω–∞ –∑–∞–∫–ª—é—á–≤–∞–Ω–µ (lock):**

```csharp
List<int> numbers = Enumerable.Range(0, 10000).ToList();
object lockObject = new object(); // Lock object

for (int i = 0; i < 4; i++)
{
    new Thread(() =>
    {
        while (true)
        {
            int index;
            lock (lockObject)  // Locking the shared resource
            {
                if (numbers.Count == 0) break;  // Exit the loop if there are no more elements
                index = numbers.Count - 1;
                numbers.RemoveAt(index);  // Remove the last element from the list
            }
        }
    }).Start();
}
```

**–û–±—è—Å–Ω–µ–Ω–∏–µ:**

- **–ú–µ—Ö–∞–Ω–∏–∑—ä–º –∑–∞ –∑–∞–∫–ª—é—á–≤–∞–Ω–µ**: `lock (lockObject)` –æ—Å–∏–≥—É—Ä—è–≤–∞, —á–µ —Å–∞–º–æ –µ–¥–Ω–∞ –Ω–∏—à–∫–∞ –º–æ–∂–µ –¥–∞ –≤–ª–µ–∑–µ –≤ –∫—Ä–∏—Ç–∏—á–Ω–∞—Ç–∞ —Å–µ–∫—Ü–∏—è, –∫—ä–¥–µ—Ç–æ —Å–µ –¥–æ—Å—Ç—ä–ø–≤–∞ –∏ –ø—Ä–æ–º–µ–Ω—è —Å–ø–æ–¥–µ–ª–µ–Ω–∏—è—Ç —Ä–µ—Å—É—Ä—Å (`numbers`). –¢–æ–≤–∞ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç—è–≤–∞ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–µ–Ω –¥–æ—Å—Ç—ä–ø –∏ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –Ω–∞ —Å–ø–∏—Å—ä–∫–∞ –æ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –Ω–∏—à–∫–∏, –∫–∞—Ç–æ –ø–æ —Ç–æ–∑–∏ –Ω–∞—á–∏–Ω —Å–µ –∏–∑–±—è–≥–≤–∞ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –Ω–∞ —Å—ä—Å—Ç–µ–∑–∞–Ω–∏–µ.

- **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç –Ω–∞ –Ω–∏—à–∫–∏—Ç–µ**: –ó–∞–∫–ª—é—á–≤–∞–Ω–µ—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞, —á–µ –ø—Ä–µ–º–∞—Ö–≤–∞–Ω–µ—Ç–æ –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç–∏ –æ—Ç —Å–ø–∏—Å—ä–∫–∞ –µ –±–µ–∑–æ–ø–∞—Å–Ω–æ –∑–∞ –Ω–∏—à–∫–∏—Ç–µ, —Ç.–µ. –Ω—è–º–∞ –¥–∞ —Å–µ —Å–ª—É—á–∏ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–µ–Ω –¥–æ—Å—Ç—ä–ø –∏ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ —Å–ø–∏—Å—ä–∫–∞.

–ß—Ä–µ–∑ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ –Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω–∏ –º–µ—Ö–∞–Ω–∏–∑–º–∏ –∫–∞—Ç–æ –∑–∞–∫–ª—é—á–≤–∞–Ω–∏—è –º–æ–∂–µ–º –¥–∞ –æ—Å–∏–≥—É—Ä–∏–º –±–µ–∑–æ–ø–∞—Å–µ–Ω –¥–æ—Å—Ç—ä–ø –¥–æ —Å–ø–æ–¥–µ–ª–µ–Ω–∏ —Ä–µ—Å—É—Ä—Å–∏ –≤ –º–Ω–æ–≥–æ–Ω–∏—à–∫–æ–≤–∏ —Å—Ä–µ–¥–∏, –∫–∞—Ç–æ –ø–æ —Ç–æ–∑–∏ –Ω–∞—á–∏–Ω –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç—è–≤–∞–º–µ race condition.
### Exception Handling
–ò–∑–∫–ª—é—á–µ–Ω–∏—è—Ç–∞ –≤ –Ω–∏—à–∫–∏ –Ω–µ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç —É–ª–æ–≤–µ–Ω–∏ –∏–∑–≤—ä–Ω —Å–∞–º–∞—Ç–∞ –Ω–∏—à–∫–∞. –í –ø—Ä–∏–º–µ—Ä–∞:

```csharp
try
{
    new Thread(DoWork).Start();
}
catch (Exception ex)
{
    Console.WriteLine("Exception!");
}
```

–¢–æ–∑–∏ `catch` –Ω—è–º–∞ –¥–∞ —É–ª–æ–≤–∏ –∏–∑–∫–ª—é—á–µ–Ω–∏–µ—Ç–æ, —Ö–≤—ä—Ä–ª–µ–Ω–æ –≤ –Ω–∏—à–∫–∞—Ç–∞, –∑–∞—â–æ—Ç–æ –∏–∑–∫–ª—é—á–µ–Ω–∏—è—Ç–∞ –Ω–µ —Å–µ –ø—Ä–µ—Ö–≤—ä—Ä–ª—è—Ç –≤ –æ—Å–Ω–æ–≤–Ω–∏—è –ø–æ—Ç–æ–∫.

**Exception Handling ‚Äì the Right Way**

```csharp
new Thread(DoWork).Start();

public static void DoWork()
{
    try
    {
        throw new ArgumentNullException();
    }
    catch (Exception ex)
    {
        Console.WriteLine("Exception handled!");
    }
}
```

–ò–∑–∫–ª—é—á–µ–Ω–∏—è—Ç–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –æ–±—Ä–∞–±–æ—Ç–≤–∞—Ç –≤—ä—Ç—Ä–µ –≤ –∏–∑–ø—ä–ª–Ω—è–≤–∞–Ω–∏—è –º–µ—Ç–æ–¥(–∏).
## Tasks in CSharp
–¶—è–ª–∞—Ç–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç –ø—Ä–∏ —Ä–∞–±–æ—Ç–∞ —Å –Ω–∏—à–∫–∏ –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –∏–∑–±–µ–≥–Ω–∞—Ç–∞ –±–ª–∞–≥–æ–¥–∞—Ä–µ–Ω–∏–µ –Ω–∞ **Task** –≤ C#. –° **Tasks** –ø–µ—á–µ–ª–∏–º **–ø–æ-–≥–æ–ª—è–º–∞ –∞–±—Å—Ç—Ä–∞–∫—Ü–∏—è** –∏ **–ª–µ—Å–Ω–æ—Ç–∞ –ø—Ä–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –ø–∞—Ä–∞–ª–µ–ª–∏–∑—ä–º**, –∫–∞—Ç–æ —Å—ä—â–µ–≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–ø–∞–∑–≤–∞–º–µ –¥–æ–±—Ä–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª–Ω–æ—Å—Ç –∏ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç, –±–µ–∑ –¥–∞ —Å–µ –Ω–∞–ª–∞–≥–∞ –¥–∞ —Å–µ –∑–∞–Ω–∏–º–∞–≤–∞–º–µ —Å –Ω–∏—Å–∫–æ –Ω–∏–≤–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∏–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –Ω–∏—à–∫–∏.

**Task** –µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –≤ .NET, –∫–æ—è—Ç–æ –ø—Ä–∞–≤–∏ –ø–∞—Ä–∞–ª–µ–ª–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –º–Ω–æ–≥–æ –ø–æ-–ª–µ—Å–Ω–æ. –¢—è —Ä–∞–±–æ—Ç–∏ —Å –∫–æ–Ω—Ü–µ–ø—Ü–∏—è—Ç–∞ **–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏**, –∫–æ—è—Ç–æ –ø–æ–º–∞–≥–∞ –¥–∞ –∏–∑–ø—ä–ª–Ω—è–≤–∞–º–µ –∑–∞–¥–∞—á–∏ –ø–∞—Ä–∞–ª–µ–ª–Ω–æ, –±–µ–∑ –¥–∞ —Å–µ —Å–±–ª—ä—Å–∫–≤–∞–º–µ —Å –ø—Ä–æ–±–ª–µ–º–∏ –∫–∞—Ç–æ **race conditions** –∏–ª–∏ **–∑–∞–∫–ª—é—á–≤–∞–Ω–∏—è** –ø—Ä–∏ –¥–æ—Å—Ç—ä–ø –¥–æ —Å–ø–æ–¥–µ–ª–µ–Ω–∏ —Ä–µ—Å—É—Ä—Å–∏. –í—Å–∏—á–∫–æ —Ç–æ–≤–∞ —Å–µ —É–ø—Ä–∞–≤–ª—è–≤–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –æ—Ç —Å–∏—Å—Ç–µ–º–∞—Ç–∞.

–° Task –±–∏–±–ª–∏–æ—Ç–µ–∫–∞—Ç–∞, **–Ω–µ –µ –Ω—É–∂–Ω–æ –¥–∞ —Å–µ —Ç—Ä–µ–≤–æ–∂–∏–º –∑–∞ –Ω–∏—à–∫–∏—Ç–µ**, –∑–∞—â–æ—Ç–æ —Ç—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–∏ —É–ø—Ä–∞–≤–ª—è–≤–∞. –ú–æ–∂–µ–º –¥–∞ —Å–µ —Å—ä—Å—Ä–µ–¥–æ—Ç–æ—á–∏–º –≤—ä—Ä—Ö—É –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∞—Ç–∞, –¥–æ–∫–∞—Ç–æ .NET —Å–µ –≥—Ä–∏–∂–∏ –∑–∞ —Å—ä–∑–¥–∞–≤–∞–Ω–µ—Ç–æ, –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –∏ –ø—Ä–∏–∫–ª—é—á–≤–∞–Ω–µ—Ç–æ –Ω–∞ –Ω–∏—à–∫–∏—Ç–µ, –∫–∞–∫—Ç–æ –∏ –∑–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è—Ç–∞ –∏–º.

**–ü—Ä–∏–º–µ—Ä:**

```csharp
public async Task<int> DoSomeWorkAsync()
{
    // This task will be executed asynchronously
    await Task.Delay(2000); // Simulate a delay
    return 42; // The result of the task
}

public async Task RunTaskExample()
{
    int result = await DoSomeWorkAsync(); // Wait for the task to complete
    Console.WriteLine($"Result: {result}");
}
```

Task –∏ `async/await`

**Task** –∏ `async/await` pattern-a —Å–∞ –≤–∑–∞–∏–º–Ω–æ —Å–≤—ä—Ä–∑–∞–Ω–∏ –∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–≤–∞—Ç –Ω–∞—á–∏–Ω –∑–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ **–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏ –∑–∞–¥–∞—á–∏**. –í C# –∫–æ–≥–∞—Ç–æ –¥–µ—Ñ–∏–Ω–∏—Ä–∞–º–µ –º–µ—Ç–æ–¥, –∫–æ–π—Ç–æ –≤—Ä—ä—â–∞ **Task** (–∏–ª–∏ `Task<T>` –∑–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç), –Ω–∏–µ –≤—Å—ä—â–Ω–æ—Å—Ç –∫–∞–∑–≤–∞–º–µ –Ω–∞ –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞, —á–µ —Ç–æ–∑–∏ –º–µ—Ç–æ–¥ —â–µ –∏–∑–ø—ä–ª–Ω–∏ –Ω–µ—â–æ, –∫–æ–µ—Ç–æ —â–µ –æ—Ç–Ω–µ–º–µ –≤—Ä–µ–º–µ, –Ω–æ –Ω—è–º–∞ –¥–∞ –±–ª–æ–∫–∏—Ä–∞ —Ç–µ–∫—É—â–∏—è –ø–æ—Ç–æ–∫. –°–ª–µ–¥ —Ç–æ–≤–∞ –º–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –∫–ª—é—á–æ–≤–∏—Ç–µ –¥—É–º–∏ `async` –∏ `await` –∑–∞ –¥–∞ —É–ø—Ä–∞–≤–ª—è–≤–∞–º–µ –ø—Ä–æ—Ü–µ—Å–∞.

**–ö–ª—é—á–æ–≤–∏ –ø—Ä–µ–¥–∏–º—Å—Ç–≤–∞ –Ω–∞ Task:**

1. **–õ–µ—Å–Ω–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –Ω–∏—à–∫–∏—Ç–µ:** Task –±–∏–±–ª–∏–æ—Ç–µ–∫–∞—Ç–∞ –∞–±—Å—Ç—Ä–∞—Ö–∏—Ä–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ—Ç–æ –Ω–∞ –Ω–∏—à–∫–∏—Ç–µ. –ù–∏–µ –Ω–µ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –ø—Ä–∏—Ç–µ—Å–Ω—è–≤–∞–º–µ –∑–∞ —Å—ä–∑–¥–∞–≤–∞–Ω–µ, —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –∏–ª–∏ —Å–ø–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–∏—à–∫–∏.

2. **–ü–∞—Ä–∞–ª–µ–ª–∏–∑—ä–º –±–µ–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏:** Task —É–ø—Ä–∞–≤–ª—è–≤–∞ race conditions –∏ –¥—Ä—É–≥–∏ –ø—Ä–æ–±–ª–µ–º–∏, –∫–æ–∏—Ç–æ –≤—ä–∑–Ω–∏–∫–≤–∞—Ç –ø—Ä–∏ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–∏.

3. **–ì—ä–≤–∫–∞–≤–æ—Å—Ç**: Task –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞–Ω –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ, –∫–æ–µ—Ç–æ –ø–æ–∑–≤–æ–ª—è–≤–∞ –Ω–∞ –Ω–∞—à–µ—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–∞ –∏–∑–≤—ä—Ä—à–≤–∞ –¥—Ä—É–≥–∏ –∑–∞–¥–∞—á–∏, –¥–æ–∫–∞—Ç–æ —á–∞–∫–∞ –¥–∞–¥–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è –¥–∞ –ø—Ä–∏–∫–ª—é—á–∏.

–í **ASP.NET** –≤—Å–∏—á–∫–æ —Å–≤—ä—Ä–∑–∞–Ω–æ —Å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç —Å–µ –ø—Ä–∞–≤–∏ —Å –ø–æ–º–æ—â—Ç–∞ –Ω–∞ **Task**. –ù–∞–ø—Ä–∏–º–µ—Ä –ø—Ä–∏ —Ä–∞–±–æ—Ç–∞ —Å –±–∞–∑–∏ –¥–∞–Ω–Ω–∏, –º—Ä–µ–∂–æ–≤–∏ –∑–∞—è–≤–∫–∏ –∏–ª–∏ –¥—Ä—É–≥–∏ –¥—ä–ª–≥–æ—Ç—Ä–∞–π–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏, –≤–º–µ—Å—Ç–æ –¥–∞ –±–ª–æ–∫–∏—Ä–∞–º–µ –æ—Å–Ω–æ–≤–Ω–∞—Ç–∞ –Ω–∏—à–∫–∞ (–∫–∞–∫—Ç–æ –±–∏—Ö–º–µ –Ω–∞–ø—Ä–∞–≤–∏–ª–∏ —Å `Thread`), –∏–∑–ø–æ–ª–∑–≤–∞–º–µ **`async`** –∏ **`await`**, –∑–∞ –¥–∞ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–º–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏ –∑–∞–¥–∞—á–∏, –∫–æ–∏—Ç–æ –ø–æ–∑–≤–æ–ª—è–≤–∞—Ç –Ω–∞ –Ω–∞—à–∏—è —Å—ä—Ä–≤—ä—Ä –¥–∞ –æ–±—Å–ª—É–∂–≤–∞ –ø–æ–≤–µ—á–µ –∑–∞—è–≤–∫–∏ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.

–ü—Ä–∏–º–µ—Ä —Å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞ —Ä–∞–±–æ—Ç–∞ —Å—ä—Å —Å—ä—Ä–≤—ä—Ä–Ω–∞ –∑–∞—è–≤–∫–∞: _(–º–æ–∂–µ –¥–∞ —Å–µ –¥–æ–±–∞–≤–∏ –ø—Ä–∏–º–µ—Ä –ø–æ –∂–µ–ª–∞–Ω–∏–µ)_

```csharp
public async Task<IActionResult> GetDataAsync()
{
    var data = await FetchDataFromDatabaseAsync();
    return View(data);
}

private async Task<List<Data>> FetchDataFromDatabaseAsync()
{
    // Simulating asynchronous data retrieval from a database
    await Task.Delay(1000); // simulating delay
    return new List<Data> { new Data() };
}
```

**–ó–∞–∫–ª—é—á–µ–Ω–∏–µ**

–ò–∑–ø–æ–ª–∑–≤–∞–Ω–µ—Ç–æ –Ω–∞ **Task** –Ω–∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è —Å–∏–ª–Ω–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏ –∑–∞ –ø–∞—Ä–∞–ª–µ–ª–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –≤ .NET, –∫–æ–∏—Ç–æ —Å–∞ –ª–µ—Å–Ω–∏ –∑–∞ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ –∏ –æ–±–ª–µ–∫—á–∞–≤–∞—Ç –º–Ω–æ–≥–æ –æ—Ç –∑–∞–¥–∞—á–∏—Ç–µ, —Å–≤—ä—Ä–∑–∞–Ω–∏ —Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –Ω–∏—à–∫–∏. –°—ä—â–µ–≤—Ä–µ–º–µ–Ω–Ω–æ, –Ω–µ –µ –Ω—É–∂–Ω–æ –¥–∞ —Å–µ —Å–ø—Ä–∞–≤—è–º–µ —Å –≤—Å–∏—á–∫–∏ **—Å–ª–æ–∂–Ω–∏ –¥–µ—Ç–∞–π–ª–∏** –∏ –ø—Ä–æ–±–ª–µ–º–∏ –Ω–∞ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ—Å—Ç—Ç–∞, —Ç—ä–π –∫–∞—Ç–æ Task –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≥–∏ —Ä–µ—à–∞–≤–∞.

- Task –µ –≤–∏—Å–æ–∫–æ –Ω–∏–≤–æ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ –Ω–∞ –ø–∞—Ä–∞–ª–µ–ª–Ω–∞ —Ä–∞–±–æ—Ç–∞.

- –ò–∑–ø—ä–ª–Ω—è–≤–∞ —Å–µ –ø–∞—Ä–∞–ª–µ–ª–Ω–æ —Å –≥–ª–∞–≤–Ω–∞—Ç–∞ –Ω–∏—à–∫–∞.

- –ú–æ–∂–µ –¥–∞ –Ω–µ –ø–æ–ª–∑–≤–∞ –Ω–æ–≤–∞ –Ω–∏—à–∫–∞ (—Ä–µ—à–∞–≤–∞ CLR - Common Language Runtime).

- –ü—Ä–µ–¥–ª–∞–≥–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –æ–ø–µ—Ä–∞—Ü–∏–∏:  
	- –°—ä–∑–¥–∞–≤–∞–Ω–µ, —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –∏ –≤—Ä—ä—â–∞–Ω–µ –Ω–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç.

	- –ü—Ä–æ–¥—ä–ª–∂–∞–≤–∞–Ω–µ —Å –¥—Ä—É–≥–∞ –∑–∞–¥–∞—á–∞ (–≤–µ—Ä–∏–∂–Ω–æ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ).

	- –ö–æ—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–æ—Ç–≤–∞–Ω–µ –Ω–∞ –∏–∑–∫–ª—é—á–µ–Ω–∏—è.

	- –û—Ç—á–∏—Ç–∞–Ω–µ –Ω–∞ –ø—Ä–æ–≥—Ä–µ—Å/—Å—ä—Å—Ç–æ—è–Ω–∏–µ.
### Creating Tasks
–°—ä–∑–¥–∞–≤–∞–Ω–µ—Ç–æ –Ω–∞ –∑–∞–¥–∞—á–∏ –º–æ–∂–µ –¥–∞ —Å–µ –Ω–∞–ø—Ä–∞–≤–∏ –ø–æ –Ω—è–∫–æ–ª–∫–æ –Ω–∞—á–∏–Ω–∞: 

- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–æ–≤ –æ–±–µ–∫—Ç

```csharp
Task task = new Task(() => { Console.WriteLine(""); });
```

- `Task.Run()`

```csharp
// Using the static method Run()
Task.Run(() => TraverseMatrix());
```

- `Task.Factory.StartNew()` - –ø–æ–∑–≤–æ–ª—è–≤–∞ –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∞ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –∑–∞–¥–∞—á–∞—Ç–∞.

```csharp
Task.Factory.StartNew(() => CopyFileContents("got-s03ep1.avi"), TaskCreationOptions.LongRunning)
```
### Generic Tasks
`Task` –Ω–µ –≤—Ä—ä—â–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç, –∑–∞—â–æ—Ç–æ –µ —Ç–∏–ø `void`. –ê–∫–æ –∏—Å–∫–∞–º–µ –¥–∞ –≤—ä—Ä–Ω–µ–º —Ä–µ–∑—É–ª—Ç–∞—Ç, —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ **generic task**.

`Task<T>` –µ task, –∫–æ–π—Ç–æ —â–µ –≤—ä—Ä–Ω–µ —Ä–µ–∑—É–ª—Ç–∞—Ç –≤ –±—ä–¥–µ—â–µ.

```csharp
Task<long> task = Task<long>.Run(() =>
{
    long sum = 0;
    for (int i = 0; i < 10000; i++) sum += i;
    return sum;
});

Console.WriteLine(task.Result); // Blocks the calling thread until the task returns a result.
```

–†–µ–∑—É–ª—Ç–∞—Ç—ä—Ç —â–µ –±—ä–¥–µ –æ—Ç —Ç–∏–ø `Task<T>` –∏ –º–æ–∂–µ –¥–∞ —Å–µ –¥–æ—Å—Ç—ä–ø–∏ —á—Ä–µ–∑ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞—Ç–∞ —Å `.Result`, –∫–æ–π—Ç–æ —â–µ –∏–∑—á–∞–∫–∞ —Ç–∞—Å–∫–∞ –¥–∞ –ø—Ä–∏–∫–ª—é—á–∏, –ø—Ä–µ–¥–∏ –¥–∞ –∏–∑–ø—ä–ª–Ω–∏ –∫–æ–º–∞–Ω–¥–∞—Ç–∞. –ö–æ–≥–∞—Ç–æ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ `.Result`, –∏–∑–≤–∏–∫–≤–∞—â–∞—Ç–∞ –Ω–∏—à–∫–∞ —â–µ –∏–∑—á–∞–∫–∞ –ø–æ–ª—É—á–∞–≤–∞–Ω–µ—Ç–æ –Ω–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞, –∫–æ–µ—Ç–æ —è –±–ª–æ–∫–∏—Ä–∞, –¥–æ–∫–∞—Ç–æ –∑–∞–¥–∞—á–∞—Ç–∞ –Ω–µ –∑–∞–≤—ä—Ä—à–∏.
### Exception Handling
–ò–∑–∫–ª—é—á–µ–Ω–∏—è—Ç–∞, –∫–æ–∏—Ç–æ —Å–∞ –≤—ä–∑–Ω–∏–∫–Ω–∞–ª–∏ –≤ —Ç—è–ª–æ—Ç–æ –Ω–∞ –µ–¥–∏–Ω task, –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç —É–ª–æ–≤–µ–Ω–∏ –∏ –æ–±—Ä–∞–±–æ—Ç–µ–Ω–∏ –∏–∑–≤—ä–Ω –Ω–µ–≥–æ.

**–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ –∏–∑–∫–ª—é—á–µ–Ω–∏—è –≤ –∑–∞–¥–∞—á–∏:**

```csharp
var task = SliceAsync(VideoPath, DestinationPath, 5);
try
{
    task.Wait();
}
catch (AggregateException ex)
{
    // Handle exception...
}
```

–ú–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ **`AggregateException`**, –∑–∞ –¥–∞ –æ–±–≥—ä—Ä–Ω–µ—Ç–µ –≤—Å–∏—á–∫–∏ –∏–∑–∫–ª—é—á–µ–Ω–∏—è, —Ö–≤—ä—Ä–ª–µ–Ω–∏ –æ—Ç —Ä–∞–∑–ª–∏—á–Ω–∏ –Ω–∏—à–∫–∏.
## Tasks with async / await
–ö–ª—é—á–æ–≤–∏—Ç–µ –¥—É–º–∏ **async** –∏ **await** –≤–∏–Ω–∞–≥–∏ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –∑–∞–µ–¥–Ω–æ.
### async
–ü–æ–¥—Å–∫–∞–∑–≤–∞ –Ω–∞ –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞, —á–µ –º–µ—Ç–æ–¥—ä—Ç –º–æ–∂–µ –¥–∞ —Ä–∞–±–æ—Ç–∏ –ø–∞—Ä–∞–ª–µ–ª–Ω–æ.

–ù–µ –ø—Ä–∞–≤–∏ –º–µ—Ç–æ–¥—ä—Ç –¥–∞ —Ä–∞–±–æ—Ç–∏ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ (—Ç–æ–≤–∞ –ø—Ä–∞–≤–∏ **await**).

```csharp
static async void SliceFileAsync(string file, int parts)
```

–ö–∞–∑–≤–∞ –Ω–∞ –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞ "—Ç–æ–∑–∏ –º–µ—Ç–æ–¥ –º–æ–∂–µ –¥–∞ –∏–∑—á–∞–∫–∞ —Ä–µ—Å—É—Ä—Å –∏–ª–∏ –æ–ø–µ—Ä–∞—Ü–∏—è".

–ê–∫–æ –∑–∞–ø–æ—á–Ω–µ –¥–∞ —á–∞–∫–∞, —Å–µ –≤—Ä—ä—â–∞ –∫—ä–º –∏–∑–≤–∏–∫–≤–∞—â–∏—è –º–µ—Ç–æ–¥.

–ö–æ–≥–∞—Ç–æ —á–∞–∫–∞–Ω–µ—Ç–æ –ø—Ä–∏–∫–ª—é—á–∏, —Å–µ –≤—Ä—ä—â–∞ –∫—ä–º –∏–∑–≤–∏–∫–∞–Ω–∏—è –º–µ—Ç–æ–¥.
### await
**await** —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ —Å–∞–º–æ –≤ –º–µ—Ç–æ–¥, –∫–æ–π—Ç–æ –∏–º–∞ –∫–ª—é—á–æ–≤–∞—Ç–∞ –¥—É–º–∞ **async**. 

–¢–æ–≤–∞ –µ –º—è—Å—Ç–æ—Ç–æ, –∫—ä–¥–µ—Ç–æ –Ω–∞—à–∏—è –º–µ—Ç–æ–¥ —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–∑—á–∞–∫–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –æ—Ç –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—Ç–∞ –æ–ø–µ—Ä–∞—Ü–∏—è. –°—Ç–∏–≥–∞–π–∫–∏ –¥–æ **await** –Ω–∏—à–∫–∞—Ç–∞ –µ —Å–≤–æ–±–æ–¥–Ω–∞ –¥–∞ —Å–µ –≤—ä—Ä–Ω–µ –µ–¥–Ω–æ –Ω–∏–≤–æ –Ω–∞–¥–æ–ª—É –∏ –¥–∞ –∏–∑–ø—ä–ª–Ω—è–≤–∞ –¥—Ä—É–≥–∏ –Ω–µ—â–∞ –∏ –∞–∫–æ —Å—Ç–∏–≥–Ω–µ –¥–æ –¥—ä–Ω–æ—Ç–æ –Ω–∞ —Å—Ç–µ–∫–∞, —â–µ –±—ä–¥–µ —Å–≤–æ–±–æ–¥–µ–Ω –∑–∞ –∏–∑–ø–æ–∑–ª–≤–∞–Ω–µ –æ—Ç –Ω—è–∫–æ–π –¥—Ä—É–≥.
–í –º–æ–º–µ–Ω—Ç–∞ –≤ –∫–æ–π—Ç–æ –∏–º–∞–º–µ –≤—ä—Ä–Ω–∞—Ç —Ä–µ–∑—É–ª—Ç–∞—Ç, –Ω–∏—à–∫–∞—Ç–∞ —â–µ –æ—Ç–∏–¥–µ —Ç–∞–º –∏ —â–µ –ø—Ä–æ–¥—ä–ª–∂–∏ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ, –Ω–æ –¥–æ–∫–∞—Ç–æ –µ –±–∏–ª –æ—Å–≤–æ–±–æ–¥–µ–Ω, –Ω—è–∫–æ–π –¥—Ä—É–≥ –µ –ø–æ–∑–ª–≤–∞–ª —Ç–æ–∑–∏ —Ä–µ—Å—É—Ä—Å. 

–¢–æ–≤–∞ –µ –º—è—Å—Ç–æ—Ç–æ, –∫—ä–¥–µ—Ç–æ –º–µ—Ç–æ–¥—ä—Ç –Ω–∏ —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–∑—á–∞–∫–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –æ—Ç –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—Ç–∞ –æ–ø–µ—Ä–∞—Ü–∏—è. –°—Ç–∏–≥–∞–π–∫–∏ –¥–æ **await**, –Ω–∏—à–∫–∞—Ç–∞ –µ —Å–≤–æ–±–æ–¥–Ω–∞ –¥–∞ —Å–µ –≤—ä—Ä–Ω–µ –µ–¥–Ω–æ –Ω–∏–≤–æ –Ω–∞–∑–∞–¥ –∏ –¥–∞ –∏–∑–ø—ä–ª–Ω—è–≤–∞ –¥—Ä—É–≥–∏ –∑–∞–¥–∞—á–∏. –ê–∫–æ –¥–æ—Å—Ç–∏–≥–Ω–µ –¥—ä–Ω–æ—Ç–æ –Ω–∞ —Å—Ç–µ–∫–∞, —Ç—è —Å—Ç–∞–≤–∞ —Å–≤–æ–±–æ–¥–Ω–∞ –∑–∞ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ –æ—Ç –¥—Ä—É–≥ –ø—Ä–æ—Ü–µ—Å.
–í –º–æ–º–µ–Ω—Ç–∞, –≤ –∫–æ–π—Ç–æ –±—ä–¥–µ –≤—ä—Ä–Ω–∞—Ç —Ä–µ–∑—É–ª—Ç–∞—Ç—ä—Ç, —Å—ä—â–∞—Ç–∞ –∏–ª–∏ –¥—Ä—É–≥–∞ –Ω–∞–ª–∏—á–Ω–∞ –Ω–∏—à–∫–∞ —â–µ –ø–æ–µ–º–µ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ—Ç–æ –æ—Ç—Ç–∞–º, –æ—Ç–∫—ä–¥–µ—Ç–æ –µ –±–∏–ª–æ —Å–ø—Ä—è–Ω–æ. –ü—Ä–µ–∑ –≤—Ä–µ–º–µ—Ç–æ, –¥–æ–∫–∞—Ç–æ –µ –±–∏–ª–∞ –æ—Å–≤–æ–±–æ–¥–µ–Ω–∞, **–¥—Ä—É–≥–∞ –æ–ø–µ—Ä–∞—Ü–∏—è –º–æ–∂–µ –¥–∞ –µ –∏–∑–ø–æ–ª–∑–≤–∞–ª–∞ —Ç–∞–∑–∏ –Ω–∏—à–∫–∞**.

–ó–∞–ø–∞–∑–≤–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –≤ state machine (–º–∞—à–∏–Ω–∞ –Ω–∞ —Å—ä—Å—Ç–æ—è–Ω–∏—è—Ç–∞).

–ú–∞—Ä–∫–∏—Ä–∞ —á–∞–∫–∞–Ω–µ—Ç–æ –Ω–∞ —Ä–µ—Å—É—Ä—Å (–∑–∞–¥–∞—á–∞, –∫–æ—è—Ç–æ —Ç—Ä—è–±–≤–∞ –¥–∞ –ø—Ä–∏–∫–ª—é—á–∏).

–†–µ—Å—É—Ä—Å—ä—Ç —Ç—Ä—è–±–≤–∞ –¥–∞ –±—ä–¥–µ –æ—Ç —Ç–∏–ø **`Task<T>`**.

–í—Ä—ä—â–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç –æ—Ç —Ç–∏–ø **T** –æ—Ç **`Task<T>`**, –∫–æ–≥–∞—Ç–æ –∑–∞–≤—ä—Ä—à–∏, –Ω–æ –∫—Ä–∞–π–Ω–∏—è —Ä–µ–∑—É–ª—Ç–∞—Ç —â–µ –±—ä–¥–µ `<T>`, –∫–æ–≥–∞—Ç–æ —Å–º–µ –ø–æ–ª–∑–≤–∞–ª–∏ **await**.

```csharp
await DownloadStringAsync("https://softuni.org"); // Returns Task<string>
```

**async / await Example:**

```csharp
static void Main()
{
    DownloadFileAsync(FileUrl, "book.pdf"); // After the method is over the calling thread gets back to the calling method
    // Do some other work
}

static async void DownloadFileAsync(string url, string fileName)
{
    Console.WriteLine("Downloading...");
    // The calling thread exits the method on await
    await Task.Run(() =>
    {
        // Download the file
    });
    
    Console.WriteLine("Download successful."); // When the waiting is over, the calling thread proceeds with method execution
}
```

**Summary:**

–í ASP.NET –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –Ω–∏ –≤—Å–∏—á–∫–∏ –º–µ—Ç–æ–¥–∏ —Ç—Ä—è–±–≤–∞ –¥–∞ –±—ä–¥–∞—Ç –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏, —Å –µ–¥–Ω–æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–æ –∏–∑–∫–ª—é—á–µ–Ω–∏–µ ‚Äî –∞–∫–æ –º–µ—Ç–æ–¥—ä—Ç –Ω–µ –ø—Ä–∞–≤–∏ –Ω–∏—â–æ –¥—Ä—É–≥–æ, –æ—Å–≤–µ–Ω –¥–∞ –≤—ä—Ä–Ω–µ `View` –ø—Ä–∏–º–µ—Ä–Ω–æ, —Ç–æ–≥–∞–≤–∞ –º–æ–∂–µ –¥–∞ –æ—Å—Ç–∞–Ω–µ —Å–∏–Ω—Ö—Ä–æ–Ω–µ–Ω.

–í –º–æ–º–µ–Ω—Ç–∞, –≤ –∫–æ–π—Ç–æ –∏–º–∞ –æ–±—Ä—ä—â–µ–Ω–∏–µ –∫—ä–º –±–∞–∑–∞ –¥–∞–Ω–Ω–∏ –∏–ª–∏ –¥—Ä—É–≥ –≤—ä–Ω—à–µ–Ω —Ä–µ—Å—É—Ä—Å, –º–µ—Ç–æ–¥—ä—Ç **–∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ —Ç—Ä—è–±–≤–∞ –¥–∞ –±—ä–¥–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–µ–Ω**. Microsoft –ø—Ä–µ–ø–æ—Ä—ä—á–≤–∞ –≤—Å—è–∫–∞ –æ–ø–µ—Ä–∞—Ü–∏—è, –∫–æ—è—Ç–æ –æ—á–∞–∫–≤–∞–º–µ –¥–∞ –æ—Ç–Ω–µ–º–µ –ø–æ–≤–µ—á–µ –æ—Ç **50 –º–∏–ª–∏—Å–µ–∫—É–Ω–¥–∏**, –¥–∞ –±—ä–¥–µ —Ä–µ–∞–ª–∏–∑–∏—Ä–∞–Ω–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ.

–ù–∞ –ø—Ä–∞–∫—Ç–∏–∫–∞ —Ç–æ–≤–∞ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ **–≤—Å—è–∫–∞ –æ–ø–µ—Ä–∞—Ü–∏—è, –∫–æ—è—Ç–æ –¥–æ—Å—Ç—ä–ø–≤–∞ –≤—ä–Ω—à–µ–Ω —Ä–µ—Å—É—Ä—Å**, —Ç—Ä—è–±–≤–∞ –¥–∞ –±—ä–¥–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞ ‚Äî –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –¥–∞–ª–∏ —Å—Ç–∞–≤–∞ –¥—É–º–∞ –∑–∞ –±–∞–∑–∞ –¥–∞–Ω–Ω–∏, —Ñ–∞–π–ª–æ–≤–∞ —Å–∏—Å—Ç–µ–º–∞, —É–µ–± —É—Å–ª—É–≥–∞ –∏–ª–∏ –Ω–µ—â–æ –¥—Ä—É–≥–æ –∏–∑–≤—ä–Ω —Ç–µ–∫—É—â–∏—è –ø—Ä–æ—Ü–µ—Å. 

–†–µ–∞–ª–Ω–æ –∫–æ–¥—ä—Ç –∏–∑–≥–ª–µ–∂–¥–∞ –∫–∞—Ç–æ –æ–±–∏–∫–Ω–æ–≤–µ–Ω —Å–∏–Ω—Ö—Ä–æ–Ω–µ–Ω –∫–æ–¥, –Ω–æ —Å –ø—Ä–µ–¥–∏–º—Å—Ç–≤–æ—Ç–æ, —á–µ –¥–∞–≤–∞–º–µ –≤—ä–∑–º–æ–∂–Ω–æ—Å—Ç –Ω–∞ —Ñ—Ä–µ–π–º—É—ä—Ä–∫–∞ –¥–∞ –≥–æ –∏–∑–ø—ä–ª–Ω–∏ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ. –¢–∞–∫–∞ –ø–æ–∑–≤–æ–ª—è–≤–∞–º–µ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ **—Å–ø–æ–¥–µ–ª—è–Ω–µ –Ω–∞ –Ω–∏—à–∫–∏ –∫–∞—Ç–æ —Ä–µ—Å—É—Ä—Å**, –∫–æ–µ—Ç–æ –≤–æ–¥–∏ –¥–æ **–∑–Ω–∞—á–∏—Ç–µ–ª–Ω–æ –ø–æ-–≤–∏—Å–æ–∫–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª–Ω–æ—Å—Ç –∏ –ø–æ-–¥–æ–±—ä—Ä scaling** –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –Ω–∏.
# Misc
# ChatGPT
## üßµ What is a thread
A **thread** is the smallest unit of execution in a program. You can think of it as a **separate worker** doing a specific task. All threads within the same program **share the same memory (resources)**, but each thread has its own **execution context** ‚Äî meaning it knows what it‚Äôs doing and where it left off.

üß† **What is the main thread?**

When a program starts, it begins with a **main thread** by default.  
If you don‚Äôt create any additional threads, **everything runs sequentially inside that main thread**.

ü§ù **How do threads correlate or interact?**

- **They share resources**: All threads have access to the same memory ‚Äî variables, files, databases.

- **They can block each other**, if two threads try to access the same resource at the same time without coordination ‚Üí this leads to issues like race conditions or deadlocks.

- **Synchronization** is needed when threads need to communicate or coordinate ‚Äî using tools like `lock`, `mutex`, `await`, `join`, `signal`, etc.

üìå **What‚Äôs the difference between the main thread and other threads?**

|**Main Thread**|**Other (Secondary) Threads**|
|---|---|
|Starts automatically|Created manually or via libraries|
|Runs the main program code|Handle specific parallel tasks|
|If it finishes, the program ends|Can end independently|
|Shouldn't be blocked for long tasks|Help offload work from the main thread|

üß† **Analogy:**

Imagine the main thread is a **receptionist** in an office.  
If they have to do everything ‚Äî answer calls, print documents, make coffee ‚Äî productivity drops.  
But if you bring in **helpers (threads)** for certain tasks, the receptionist (main thread) can focus on the most important things.
## The Role of `await` in Thread Management and Concurrency
If we don‚Äôt use the `await` pattern, there will be no difference as long as there are threads available. Let‚Äôs say there are 8 threads available and only 8 users hit the controller. In this case, even if their operations take a long time and we don‚Äôt release the threads with the `await` pattern, there will be no difference since no other users try to reach the controller. The `await` pattern will only be useful if another user hits the controller while all threads are busy. Thanks to `await`, the threads will be released, allowing the server to handle more user requests, is this correct?

**ChatGPT said:**

Yes, exactly! You've got it right. Let's break this down further to make sure everything is clear.

**Without `await`:**

If you don't use the `await` pattern and just execute everything synchronously, the following happens:

- When a **User hits the controller**, a thread from the **thread pool** (let's say you have 8 threads) is allocated to handle that request.

- **If the operation takes a long time** (e.g., a database call or some lengthy computation), the thread will be **blocked** until that operation is completed.

- If **only 8 users** hit the controller, and there are 8 threads available, then **each request** gets its own thread from the pool and each will execute fully on that thread without interference.

- Since no new requests are coming in while all threads are used, there is **no real "concurrency" issue** ‚Äî each thread is just serving its respective user request one after the other.

So, in this case, **there is no issue** ‚Äî each thread is busy, and everything runs as expected for each request.

**With `await`:**

The **`await`** pattern helps in situations where there are **more users** or long-running asynchronous operations, and it helps **free up threads** during I/O-bound operations (e.g., database calls, HTTP requests, etc.).

- When you use `await`, the thread **doesn't stay blocked** while waiting for the operation to complete.

- When a request hits the controller, it gets a thread from the pool.

- If that operation involves **waiting for something** (like a database query or calling an external API), the thread is **released back** to the pool and can be reused for other tasks (such as serving other requests).

- If another user hits the controller, **and threads are available** (or they are freed up by the `await` pattern), the server can use those threads to handle the new request **immediately**.

**The key difference**:

- **Without `await`**: The threads are **blocked** and not available for other requests until the long operation finishes.

- **With `await`**: Threads are **freed up** during waiting, so they can be reused to handle new requests, improving overall efficiency, especially when there are many concurrent requests.

**What happens when all threads are used?**

- **Without `await`**: If all 8 threads are used up (because all 8 users are making long-running requests), any **new user requests** will have to wait until a thread becomes available.

- **With `await`**: When `await` is used, and there are more than 8 requests coming in, the threads will be **freed up** once the I/O-bound tasks (like database calls) are awaiting, which means **more requests** can be processed simultaneously, without blocking all threads.

**Summary:**

- **Without `await`**, if you only have 8 threads and 8 requests, there is no immediate problem ‚Äî but **if more users come in** and all threads are busy, they'll be blocked until threads are free.

- **With `await`**, threads are released during I/O operations, and **other requests can be processed concurrently** if needed, making the system more responsive, especially when there are a lot of concurrent requests or long-running tasks.

In essence, the **`await` pattern** shines in scenarios with **high concurrency** or **waiting operations** because it maximizes the use of available threads, keeping the server responsive.
## What Happens to the Main Thread During `Task.Run()`
When `Task.Run()` is called, the **main thread** (or whichever thread calls `Task.Run`) does not block waiting for the task inside `Task.Run()` to finish. Instead, the main thread:

1. **Schedules the task to run on a separate thread** (from the ThreadPool).

2. **Continues to execute** the rest of the program without waiting for the task in `Task.Run()` to complete.

**Step-by-Step Flow:**

1. **Main thread starts execution** and calls `Task.Run()`:

```csharp
await Task.Run(() =>
{
    Console.WriteLine($"[Task.Run] Running - Thread ID: {Thread.CurrentThread.ManagedThreadId}");
    Thread.Sleep(1000); // Simulate work
});
```

1. **Main thread schedules the task** to run on a new thread from the `ThreadPool`. This **new thread** starts immediately and executes the code inside `Task.Run()` (the task).

2. **Main thread continues executing** the next lines of code after `Task.Run()` without waiting for the task inside `Task.Run()` to finish. If the main thread has more code after `Task.Run()`, it will execute it **immediately**, allowing the program to do other work.

3. When the task inside `Task.Run()` finishes (after the `Thread.Sleep(1000)`), control is returned to the main thread, but only if you are **waiting** for the task, such as using `await` or `Task.Wait()`.

**Visualizing the Flow:**

- **Main thread:** Runs `Task.Run()`, hands off the task to a new thread, and continues immediately with the next instruction.

- **New thread (`ThreadPool` thread):** Runs the code inside `Task.Run()`.

üìë **Example:**

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Console.WriteLine($"Main thread starts. Thread ID: {Thread.CurrentThread.ManagedThreadId}");

        await Task.Run(() =>
        {
            Console.WriteLine($"[Task.Run] Running on thread ID: {Thread.CurrentThread.ManagedThreadId}");
            Thread.Sleep(1000);  // Simulate work
        });

        Console.WriteLine("Main thread continues after Task.Run.");
        Console.WriteLine($"Main thread ends. Thread ID: {Thread.CurrentThread.ManagedThreadId}");
    }
}
```

üßÆ **Expected Output:**

```
Main thread starts. Thread ID: 1
[Task.Run] Running on thread ID: 4  // New thread from ThreadPool
Main thread continues after Task.Run.
Main thread ends. Thread ID: 1
```

**What Happens:**

- The **main thread** (thread ID `1`) starts and immediately calls `Task.Run()`, sending work to a **new thread** from the ThreadPool (`thread ID 4`).

- While `Task.Run()` runs on the new thread, the **main thread** continues and **does not wait** for the task to complete. It outputs `Main thread continues after Task.Run.` and ends.

- The main thread does not block, and it finishes its execution while the task continues to run on the separate thread.

‚ö° **Key Points:**

- The **main thread** does **not wait** for the task in `Task.Run()` to complete unless you specifically tell it to wait using `await` or `Task.Wait()`.

- If you **don't `await`** the task, the main thread will **immediately continue** with the next code after calling `Task.Run()`, even if the task is still running.

- If you **`await`** the task, the main thread will pause at `await` until the task finishes, but it will not block ‚Äî other work can happen on the main thread during that time.
## Only One Thread Available For Two Users
What happens if we have user A and user B and both hit a controller and there is only one thread available?

**ChatGPT said:**

Perfect ‚Äî let's imagine **only one thread** exists (say, in a simplified web server) and both **User A** and **User B** hit the same controller **at roughly the same time**, and the controller uses `await`.

**üß© Controller code (simplified):**

```csharp
public async Task<IActionResult> GetData()
{
    Console.WriteLine("Start");

    await Task.Delay(1000); // Simulate DB or API

    Console.WriteLine("End");
    return Ok();
}
```

üß† **What happens with just one thread**:

1. User A makes a request:

- Server starts `GetData()` on the **main thread**.

- It prints `"Start"`.

- Hits `await Task.Delay(1000)` ‚Üí the method **pauses**.

- The **main thread is freed**.

- Timer starts in the background (doesn't need a thread).

2. User B makes a request (while User A is paused):

- The main thread is **free**, so it handles **User B**'s `GetData()`.

- It prints `"Start"`.

- Also hits `await Task.Delay(1000)` ‚Üí **User B**'s method also **pauses**.

- Now both User A and User B are **waiting** for their delays to finish.

- The thread is still **not blocked**.

**3. After 1 second:**

- **User A**'s delay finishes.

- Its continuation (`Console.WriteLine("End")`) is **queued** to the main thread.

- The main thread resumes User A‚Äôs code, prints `"End"`, returns `Ok()`.

**4. Then:**

- **User B**'s delay finishes too (nearly at the same time).

- Its continuation is also queued.

- After User A finishes, the thread moves to **User B**'s continuation, prints `"End"`, and returns `Ok()`.

**‚è∏ Summary (with only one thread):**

|Time|Thread is doing|Notes|
|---|---|---|
|0 ms|User A starts, prints "Start"|Thread is busy with User A|
|~10 ms|User A hits `await`, thread freed|User A is waiting (via timer)|
|~11 ms|User B starts, prints "Start"|Thread now runs User B|
|~20 ms|User B hits `await`, thread freed|Both A and B are now "paused"|
|1000 ms|User A's delay completes|User A‚Äôs code resumes|
|1001 ms|Prints "End" for User A||
|1002 ms|User B's delay completes|User B resumes after A|
|1003 ms|Prints "End" for User B||

**‚úÖ Key Takeaways:**

- Even with just **one thread**, `await` allows multiple requests to **coexist** efficiently.

- The thread **never blocks** on I/O ‚Äî it always moves forward.

- Each request resumes only when its awaited operation completes and the thread is available.

- Execution is **not truly parallel**, but it's **non-blocking and concurrent**.

**You said:**

What if the user's A database operation finishes before the thread reaches the user's B await database operation? Will it immediately switch back to user A, or will it reach the await operation and then switch back to user A? If the latter, this means there was a time when the operation for user A was finished, but they had to wait for the ongoing thread processing of user B?

**ChatGPT said:**

Excellent and **very insightful** question.

Let‚Äôs walk through your exact scenario in a single-threaded environment where two users (User A and User B) hit the same controller. The controller awaits a database call (simulated as `Task.Delay(1000)` for simplicity).

üîç **Scenario Breakdown:**

We assume:

- Only **one thread** (the main thread).

- `async/await` is used (non-blocking).

- The **awaited operation is I/O-bound** (e.g., DB call, network call), so it doesn't need a thread to wait.

üë£ S**tep-by-step Timeline**

Let‚Äôs say:

1. **User A** starts at time `0ms`

2. **User B** starts at time `200ms`

3. The DB operation for **User A finishes at 1000ms**

4. The DB operation for **User B finishes at 1200ms`


Here‚Äôs what happens:

|Time|What Happens|
|---|---|
|0ms|User A starts. Hits `await dbCall`. Control returns. Main thread is **free**.|
|200ms|User B starts. Hits `await dbCall`. Control returns. Now both A and B are **awaiting**.|
|1000ms|User A's DB operation finishes. Its continuation is **queued**. But thread is **busy with B**?|
|1000ms - 1200ms|**If** the thread is **currently processing B‚Äôs code before reaching await**, it must **finish up to the await**.|
|~1200ms|Then the thread picks up A‚Äôs continuation. Executes A‚Äôs `after await` code.|
|~1300ms|Then picks up B‚Äôs continuation. Executes B‚Äôs `after await` code.|

üß† **So, to your question:**

> **If User A‚Äôs DB operation finishes before User B even reaches the `await`, does the thread switch back to User A immediately?**

‚ùå **No.**

It **does not preempt** execution.

- The thread is **not interrupted**.

- Even if User A‚Äôs result is ready, it has to **wait in the continuation queue**.

- The thread finishes **what it‚Äôs currently doing** (e.g., processing User B **up to the `await`**).

- Only then will it pick the next ready continuation (like User A‚Äôs).

‚úÖ **Conclusion:**

Yes, **User A can finish waiting earlier**, **but still wait longer** to resume execution, **because the single thread was busy** running synchronous code for User B.

This is **not wasteful**, but just a natural limitation of **single-threaded, cooperative concurrency**.

In this particular scenario, with `await`, User A might wait a little longer because the thread doesn't block and is free to process other tasks (like User B‚Äôs operation) while User A‚Äôs task is still waiting for an async operation to complete.

However, the key advantage is that once User A's task is done, subsequent users (like User B) will experience shorter wait times because the thread can switch between tasks efficiently.

This trade-off ‚Äî where User A may wait slightly longer, but all subsequent users benefit from shorter wait times ‚Äî is one of the core advantages of using asynchronous programming. It improves overall throughput by allowing the thread to handle more tasks concurrently.
## Similarities between C# `async/await` and JavaScript's Event Loop

1. **`await` pauses execution**:

    - In both C# and JavaScript, `await` **does not block the thread**.

    - It **schedules the continuation** (the rest of the function) to run **later**, once the awaited task is complete.

2. **Continuations go to a queue**:

    - In C#, it's the **task scheduler or synchronization context**.

    - In JavaScript, it's the **microtask queue** (for promises).

    - In both cases, even if the task completes **immediately**, the continuation goes to the back of the queue.

3. **The thread/loop runs one task at a time**:

    - Both systems rely on a **single-threaded model** (C# can be multithreaded, but async/await doesn't require it).

    - Only **one continuation is executed at a time**, in the order they were scheduled.

üß† **Key Insight:**

In both JavaScript and C#, the "magic" of `await` is not in starting new threads, but in **delaying the continuation** and **not blocking** the current thread or loop.
## Hardware vs. Software Threads
**Hardware threads** (from CPU cores):

- Limited by physical CPU capabilities (e.g., 16 cores √ó 2 = 32 hardware threads).

- These are the **actual parallel execution lanes**.

‚úÖ **Software threads** (created by your application):

- .NET (and other runtimes) can create **many more software threads** than hardware threads.

- These threads are **managed by the OS scheduler**.

- The OS time-slices them ‚Äî meaning it switches between them rapidly on the same hardware thread, not literal simultaneous execution.

üß† **Example:**

Your server might have:

- **32 logical cores**

- But your ASP.NET app can spawn **hundreds of concurrent software threads.**

They won‚Äôt all run _at the exact same moment_, but the OS schedules them **as fast as possible**, making it seem concurrent.

So:  
üó£Ô∏è When we say ‚Äúhundreds of threads,‚Äù we mean **many tasks can be handled concurrently**, not that the CPU is physically doing 100+ things at once.
## `await Task.Run()`
Is `await Task.Run()` useful when we want to ensure that the main thread isn't blocked by resource-intensive work, allowing us to protect the main thread and wait for another thread to handle the task?

**ChatGPT said:**

Exactly! You‚Äôve got it right. Using `await Task.Run()` is particularly useful in scenarios where you have limited threads (e.g., only one thread left or you're managing a thread pool with a set number of threads), and you want to **protect your main thread** from being blocked by resource-intensive work.

Here's why:

1. **Protecting the Main Thread**:

    - Without `await Task.Run()`, if your main thread is doing some **resource-intensive work**, it will **block** and be **unavailable** to handle other tasks or incoming requests.

    - By using `await Task.Run()`, you **offload** that work to a **background thread**, so the main thread doesn‚Äôt get bogged down. The main thread can keep handling other incoming requests (or other tasks) while the background thread works on the CPU-bound task.

2. **Handling Limited Threads**:

    - Imagine you have only **one main thread** in a web application, or you‚Äôre working with a **small thread pool**. If the main thread is stuck waiting on a task, no other work can be done on that thread.

    - By using `await Task.Run()`, you can **free up the main thread** so it can be used for other operations. The CPU-intensive work will be handled by another thread (from the thread pool), meaning the main thread isn't wasted.

3. **When a Background Thread is Available**:

    - When you call `Task.Run()`, it schedules the task to be run on a **background thread**.

    - If a background thread is **free**, it will start immediately. If all background threads are busy, it will wait until one becomes available.

    - While this happens, the **main thread** is not blocked and can continue processing other requests or tasks.

**Use Case Example:**

If your web server or application is handling HTTP requests from multiple users and the tasks involved are **CPU-bound** (e.g., data processing, image manipulation), you might want to make sure that:

- The **main thread** is available to **serve other user requests**.

- CPU-intensive tasks like data processing are **offloaded to a separate thread** so they don‚Äôt block the main thread.


This makes your application more responsive and can handle more users effectively.

**Flow:**

1. **Main thread** receives a request (e.g., User A makes a GET request).

2. The **main thread** starts processing, but hits `await Task.Run()`, offloading the **CPU-bound task** to a **background thread**.

3. While the background thread is working, the **main thread** is free and can handle **other requests** (e.g., User B's request).

4. Once the background thread finishes the CPU-intensive task, the **main thread** resumes execution, continuing after `await` to return the response to the client.

**In Code:**

```csharp
public async Task<IActionResult> HandleRequestAsync()
{
    // The main thread is freed up while the background thread processes the task.
    await Task.Run(() => DoCpuIntensiveWork());

    // Once the background task finishes, the main thread resumes.
    return Ok("Request completed!");
}

public void DoCpuIntensiveWork()
{
    // Simulating CPU-intensive operation
    Thread.Sleep(5000);  // Placeholder for actual CPU work
}
```

In this case:

- **Main thread**: Handles the HTTP request and immediately hands off the CPU-bound work to a background thread using `await Task.Run()`.

- **Background thread**: Runs the CPU-intensive work (like `Thread.Sleep()` in this example).

- **Main thread**: Is free to process other tasks while the background thread is busy.

**Conclusion:**

By using `await Task.Run()`, you ensure that your **main thread is protected** from being blocked by CPU-intensive work. This is especially helpful in environments where you have a limited number of threads (e.g., a thread pool) and want to maximize throughput without waiting for threads to become free.

**You said:**

Why not use only `run()` with `await`?

**ChatGPT said:**

That's a great question! Let's break down why we use **`Task.Run()`** _and_ **`await`** together, rather than just using **`Task.Run()`** alone.

1. **`Task.Run()`**:

- **Purpose**: It schedules a task to be run on a **separate thread** (typically from the thread pool).

- **When to use**: You use `Task.Run()` when you have a **CPU-bound operation** that you don‚Äôt want to block the main thread with. It ensures the work is offloaded to another thread, freeing up the main thread for other tasks.

However, using **`Task.Run()`** by itself doesn't allow your application to "pause" and wait for the result of the CPU-bound task. The task will execute in the background, but you don't get any asynchronous behavior ‚Äî you still have to wait for it in a blocking manner (i.e., the thread will block while waiting for the result of that CPU task).

2. **`await`**:

- **Purpose**: It tells the **asynchronous code** to "pause" the execution of the method until the task is complete.

- **When to use**: You use `await` when you want to **pause** the method execution and **not block the main thread**. `await` is useful primarily for **I/O-bound operations** (like waiting for database queries or HTTP requests), because it allows other requests to be handled in the meantime.

Why Use Both (`Task.Run()` + `await`)?

1. **Asynchronous Execution**:

    - Using **`Task.Run()`** on a CPU-bound operation ensures that the work happens on a separate thread, not blocking the main thread.
    
    - **`await`** allows the method to **pause** without blocking the calling thread. The execution flow of the method can return control to the thread pool while waiting for the task to complete, thus **avoiding blocking**.

2. **Main Thread and Request Handling**:

    - If you just use **`Task.Run()`**, the CPU-bound task will execute on a separate thread, but you won‚Äôt be able to **pause** the execution of the method to handle other incoming requests.

    - By using **`await Task.Run()`**, the thread is released back to the thread pool while the background work happens. This is important in web server scenarios (like **ASP.NET Core**), where you need to keep threads available for other incoming requests.

**Example Without `await`:**

```csharp
public IActionResult HandleRequest()
{
    var result = Task.Run(() => PerformHeavyCalculation()).Result; // Blocking operation
    return Ok(result);
}
```

- Here, the `Result` property will **block** the calling thread while the task is running.

- Even though `Task.Run()` ensures the heavy work happens on a separate thread, the main thread is still blocked until the task finishes.

**Example With `await`:**

```csharp
public async Task<IActionResult> HandleRequest()
{
    var result = await Task.Run(() => PerformHeavyCalculation()); // Non-blocking
    return Ok(result);
}
```

- Here, the **`await`** ensures the calling thread isn‚Äôt blocked while waiting for the result, and the thread is free to handle other requests.

- The `await` pauses the method and frees up the main thread, which is important in web environments like ASP.NET Core, where you might have multiple users and limited threads available.

**Summary:**

- **`Task.Run()`** ensures the CPU-bound work is executed on a separate thread.

- **`await`** ensures that the main thread is **not blocked** while waiting for the task to complete, allowing other operations to run concurrently.

- **Together**, they enable non-blocking behavior for resource-intensive tasks, freeing up the main thread for other requests, especially in environments like **ASP.NET Core**.

Without `await`, you‚Äôd end up blocking your threads and limiting the ability to process concurrent requests. The combination of both allows you to make your code **asynchronous** and **efficient**.

**You said:**

Another key advantage of using `await` in combination with `Task.Run()` is that it allows us to use the result of the returned task after it finishes. Without `await`, if the main thread continues execution before the task completes, any attempt to access the result later may cause an error.

**ChatGPT said:**

Exactly! You've highlighted a key advantage of using **`await`** alongside **`Task.Run()`**. Let's break this down:

Key Advantages of Using `await Task.Run()`:

1. **Releasing the Thread**:

    - As you mentioned, when you use **`await Task.Run()`**, the main thread is **released back to the thread pool** while the background task executes. This is especially crucial in web server scenarios like **ASP.NET Core**, where you want to maximize the number of requests your server can handle without blocking threads. If you don‚Äôt release the thread, you might exhaust the available threads in the thread pool, leading to a poor user experience.
  
2. **Avoiding Errors When Accessing Results**:

    - Another critical advantage, as you've pointed out, is that **`await`** ensures that the method **pauses** and **doesn‚Äôt continue** until the background task has completed and returned its result. This is particularly useful when you need to use the result of the task **immediately after it finishes**.


    If you don‚Äôt use **`await`**, your code would continue executing, potentially accessing the result of the task **before it has completed**. This leads to errors, such as **`NullReferenceException`**, **`InvalidOperationException`**, or others, because the result might not be available when you try to use it.

**Example:**

**Without `await` (Problematic Code):**

```csharp
public IActionResult HandleRequest()
{
    var task = Task.Run(() => PerformHeavyCalculation()); // Starts the task
    var result = task.Result;  // Blocks the thread here
    return Ok(result);  // Potential error if task isn't completed yet
}
```

In this code, the thread might **block** while waiting for `task.Result`, and if the task hasn't completed yet, accessing the result could lead to issues, especially in more complex cases (e.g., asynchronous I/O operations).

**With `await` (Safe and Proper):**

```csharp
public async Task<IActionResult> HandleRequest()
{
    var result = await Task.Run(() => PerformHeavyCalculation());  // Awaits completion
    return Ok(result);  // Result is guaranteed to be available after await
}
```

In this case, the method **waits** for `PerformHeavyCalculation()` to finish and then returns the result. The `await` ensures that the main thread isn‚Äôt blocked unnecessarily, and once the task completes, the result can be used safely without errors.

**Summary:**

- **Using `await`** with `Task.Run()` allows your code to **pause execution** and **safely wait** for the result of a background task, without blocking the main thread.

- Without `await`, if the result is needed immediately after the task is run, you could face errors due to the task not being completed, as the main thread continues execution without waiting for the task to finish.

- **`await`** makes it easier to manage **asynchronous code**, and **ensures correctness** by ensuring that the task has completed before attempting to access its result.

So yes, **`await`** makes sure that the result is available when needed, preventing potential runtime errors when the task isn't yet completed.

**You said:**

But if there isn't a second thread available and we dont use `await`, the resource-intensive task will not start, but the main thread will continue executing the method and eventually finish before the resource-intensive task completes. This means that if the result of the task is not needed later in the method, the main thread will simply complete the method and be free to handle incoming requests?

**ChatGPT said:**

You're absolutely correct in pointing out a nuance in how the application behaves when there is only one thread available.

Let‚Äôs break this down:

1. **No Second Thread in the Pool**:

    - If **only one thread is available** in the pool, and the main thread is busy executing the code, the **resource-intensive task** initiated via **`Task.Run()`** will not start immediately because there are no other threads available to process it. The task is effectively **queued** until a thread becomes available.

    - Meanwhile, the main thread **will continue** executing any remaining code, possibly completing the method, depending on how much work is left to do after starting the task.

2. **Main Thread Finishes Before Task**:

    - If the resource-intensive task is **non-blocking** (e.g., it just starts and doesn't require immediate interaction), the main thread can continue executing, potentially completing the method and freeing itself up for other requests.

    - The main thread doesn‚Äôt need to **wait** for the result of the task if the result is **not used** below, meaning there‚Äôs no actual deadlock or freeze. The main thread is free to complete the method and return to the thread pool.

3. **Potential Issue**:

    - If **you need the result** of the background task in the same method and don‚Äôt `await` it, the application could encounter **problems later**, as the result will not be available when needed (this is the point where you would run into issues like accessing an incomplete task result).

    - If the task is CPU-bound and the main thread is the only one available, you‚Äôre just not utilizing multi-threading. In this case, you'd want to **protect** the main thread from becoming blocked (so it can handle more incoming requests).

**Potential Deadlock and Freezing Misconception**:

- **Deadlock** in this scenario isn‚Äôt very likely if you're not waiting on the result of the background task. The **main thread** will finish its execution and return to the pool, while the **background task** remains in the queue until it gets processed.

- The deadlock you mentioned in the case of **`await Task.Run()` without await** typically happens when the **main thread waits for the task‚Äôs result synchronously** (for example, with `.Result` or `.Wait()`), and **if no threads are available** to run the task, you could get into a deadlock.


So, your understanding is correct:

- If the main thread doesn't **need the result** of the task, and there is only one thread available, the main thread will **continue** and complete the method while the task remains in the queue.

- There's no "freeze" because the method can complete without waiting for the resource-intensive task, as long as the result of that task is **not used** further in the method.

Example:

If you're not awaiting the result of the resource-intensive task, like this:

```csharp
public IActionResult HandleRequest()
{
    Task.Run(() => PerformHeavyCalculation());  // Starts a resource-intensive task
    // Main thread continues to execute other code
    return Ok();  // Main thread finishes, task continues in the background
}
```

Here, the main thread doesn't wait for `PerformHeavyCalculation` to complete. It will return the response immediately, and the task will continue running in the background (assuming a thread becomes available).

So **no deadlock** will occur, and **no freeze** will happen. The only issue might arise if **you expect a result** from the task in the same method. If the task doesn‚Äôt finish before you attempt to use its result, you could encounter issues.

**You said:**

How will this work? Let's say the main thread finishes the `HandleRequest` method, and after it's completed, another thread becomes available. Will it start executing the `PerformHeavyCalculation` method, or will it be aborted since the main method has already finished?

**ChatGPT said:**

Great follow-up! Let's walk through this situation carefully:

**Scenario Breakdown:**

1. **Main Thread Completes `HandleRequest()`**:

    - The main thread starts executing the `HandleRequest` method.

    - It runs `Task.Run(() => PerformHeavyCalculation())` to start the `PerformHeavyCalculation` task, but **does not await** it. This means it doesn't block on waiting for the task to finish.

    - The main thread then completes the method and exits, returning the response (`Ok()`).

2. **Task in the Queue**:

    - Since the task (`PerformHeavyCalculation()`) was started with `Task.Run()`, it is now in the **queue of tasks waiting to be executed**. The task itself is **asynchronous** and doesn't run immediately unless a thread becomes available to process it.

3. **Thread Becomes Available**:

    - After the main thread finishes its execution (completing the `HandleRequest()` method), another thread from the **thread pool** becomes available.

    - The **task is not aborted**. Instead, once a thread is free, it will pick up the `PerformHeavyCalculation()` task and begin executing it.

**Key Points:**

- The task that was started by `Task.Run()` will **not be aborted** when the main thread finishes executing the `HandleRequest()` method.

- Even though the main thread finishes and returns the response, **the background task (the one you ran with `Task.Run()`) will continue execution** as long as a thread is available to execute it.

- The **main thread's completion** of `HandleRequest()` **does not affect the background task**. Once a thread is available, it will continue executing the task that was queued.

üß†**Important Distinction:**

- **In ASP.NET** (e.g., controller methods like `HandleRequest()`), the process **stays alive** long after a single method returns. So background tasks from `Task.Run()` **will usually continue**.
    
- **In console apps**, the process can end as soon as the last foreground thread ends ‚Äî unless you're explicitly holding it open.

**Example Flow:**

1. **Request hits the controller**: Main thread starts handling the request.

2. **Task is started with `Task.Run()`**: Background task (`PerformHeavyCalculation()`) is queued.

3. **Main thread finishes**: The main thread completes the method and returns a response to the client.

4. **Another thread becomes available**: A free thread picks up the queued background task (`PerformHeavyCalculation()`).

5. **Background task execution**: The task executes on the available thread, even though the main thread has already completed and returned the response.

So, the task does **not get aborted** just because the main method finishes. The background task will continue executing once a thread is available from the thread pool.
### `Task.Run()` With and Without `await` Example
Consider the following example:

```csharp
class Program
{
    static async Task Main()
    {
        Task.Run(() => ParallelThread());

        for (int i = 0; i <= 100; i++)
        {
            Console.WriteLine($"Main thread in for loop, i = {i}");
        }

        Console.WriteLine("Main thread finishes.");
    }

    static void ParallelThread()
    {
        for (int i = 0; i <= 100; i++)
        {
            Console.WriteLine($"Parallel thread in for loop, i = {i}.");
        }

        Console.WriteLine("Parallel thread finishes.");
    }
}
```

‚úÖ **Without `await`**

```csharp
Task.Run(() => ParallelThread());
```

- The **parallel thread starts**, but `Main` **does not wait** for it to finish.
    
- The main thread continues running its `for` loop independently.
    
- Both threads run **in parallel**, and you'll see **interleaved output** in the console.

‚úÖ **With `await`**

```csharp
await Task.Run(() => ParallelThread());
```

- The **parallel thread starts**, and `Main` **waits** for it to complete before continuing.
    
- The `for` loop in `Main` runs **after** the parallel thread finishes (if placed after the `await`).
    
- Ensures the background work **completes fully** before `Main` proceeds or exits.

You have to be careful, because without using `await` the program may **finish before the parallel thread completes** if the main thread ends quickly. When you start a parallel thread using `Task.Run(...)` **without `await`**, the main thread **does not wait** for it. If the main thread finishes its execution quickly (like reaching the end of `Main`), the entire program may **exit** before the parallel thread finishes its work ‚Äî especially if that thread is doing something slow (e.g., `Thread.Sleep`). This is because the application exits as soon as all foreground work in `Main` is done, regardless of background threads still running.

This is clearly visible in the example below where the `Async()` method will never finish:

```csharp
class Program
{
    static async Task Main()
    {
      Async();

      Console.WriteLine("Main Method finishes.");  
    }

    static async Task Async()
    {
        Console.WriteLine("Entering Async Method.");

        await Task.Delay(3000);

        Console.WriteLine("Async Method finishes.");
    }
}
```

**There is a distinction:**

- In a **console app**,  if the `Main` method finishes before the `async` method completes (and you're not awaiting it), the process may exit early, and the async method might **never complete**.
    
- In **ASP.NET**, the method won‚Äôt be aborted immediately, but:
    
    - It becomes **detached** from the request lifecycle.
        
    - It may finish later ‚Äî but you‚Äôve lost the ability to observe or manage it (unless you explicitly track it).
        
    - **Unobserved exceptions** can go unnoticed.

	- ASP.NET **won‚Äôt capture errors**, and **won‚Äôt delay the HTTP response** based on that background operation.

	- It behaves like a background task ‚Äî so it **might or might not finish**, depending on timing and whether the app shuts down before it's done.
#### `Task.Wait()`
To make sure the program **waits for the parallel task to finish**, even without using `await`, you can store the `Task` and call `.Wait()` on it.

Here‚Äôs how:

```csharp
class Program
{
    static void Main()
    {
        // Store the task reference
        Task task = Task.Run(() => ParallelThread());

        for (int i = 0; i <= 100; i++)
        {
            Console.WriteLine($"Main thread in for loop, i = {i}");
        }

        Console.WriteLine("Main thread waiting for the parallel thread to finish...");

        // Force the main thread to wait for the task to complete
        task.Wait();

        Console.WriteLine("Main thread finishes.");
    }

    static void ParallelThread()
    {
        for (int i = 0; i <= 100; i++)
        {
            Console.WriteLine($"Parallel thread in for loop, i = {i}.");
        }

        Thread.Sleep(3000); // Simulate longer work
        Console.WriteLine("Parallel thread finishes.");
    }
}
```

üîç **Explanation:**

- `Task.Run()` launches the background task.

- `.Wait()` pauses the main thread until the parallel task completes.

- This ensures the application won‚Äôt exit early, even if the background work takes longer.

- If you have **multiple parallel methods**, you should store **each `Task`** separately and then wait for **all of them together** using `Task.WaitAll(...)`.
### `await` and `async` ‚Äî How They Help
When you use the `async`/`await` pattern:

- **Awaiting** on an operation means **releasing** the thread to the thread pool, freeing up CPU time for other threads.

- The CPU doesn‚Äôt keep allocating resources to the thread while it is "awaiting" a task. This is a big benefit: instead of wasting CPU time, it **suspends** the thread and allows the CPU to do other useful work.

So, by using `await`, the thread **doesn't take up CPU time** when it's not performing any meaningful work. It essentially "pauses" its execution, allowing the CPU to handle other threads.

**Summary**

- **Without `await`**: If a thread is running an operation (even an idle one), it **still takes CPU resources** because it remains on the scheduling queue.

- **With `await`**: The thread is **released** and doesn't take up CPU time until the awaited operation completes, allowing the CPU to work on other threads.

Thus, if your thread is **doing nothing** (or blocked), it still consumes resources **unless you use asynchronous programming** (`async`/`await`), which allows the CPU to efficiently allocate resources elsewhere.
## Thread Management and Parallel Execution
A **thread** is essentially a unit of work that corresponds to a specific part of a program that is running. Each thread has its own **call stack** (e.g., 1MB in .NET by default). It‚Äôs like an individual **worker** assigned to handle a task. However, threads themselves are not physically tied to any specific CPU core. Instead, they are more **logical** in nature. The **operating system** and **scheduler** decide how and where they will run, optimizing performance based on available resources.

üß† **Breakdown Example:**

üß© **Hardware:**

You have 10 **physical cores**, but each of these cores can handle **2 logical cores** (hyper-threading).  
So, in total, you have **20 logical cores** (or **20 workstations**) that can run threads in parallel.

‚öôÔ∏è **How the Scheduler Works:**

The **scheduler** is like a **manager** who assigns tasks (threads) to the available workstations (logical cores).

- The **scheduler** can assign threads to these 20 workstations (logical cores).

- It keeps track of how much work each core is doing (the load).

- If one workstation (logical core) is overloaded and does not have enough processing power (the **capacity** of a core to allocate time for each thread to run), the scheduler can **move** threads from one core to another to balance the workload and improve efficiency.

üîÑ **Thread Movement:**

- The **scheduler** doesn‚Äôt just stick to one physical core.

- If a thread is running on logical core 1 (on physical core 1) and needs more resources (needs **more uninterrupted or timely CPU attention**, which translates to **more execution time**), the scheduler may **move it to logical core 19** (on physical core 10) to optimize performance.

- This movement is **transparent** to the program ‚Äì it's managed entirely by the operating system and its scheduler.

üèóÔ∏è **Analogy: Workers and Desks**

|**Element**|**Analogy**|
|---|---|
|**Logical Core**|A **work desk**|
|**Physical Core**|A **room** with desks|
|**Thread**|A **worker**|
|**Scheduler**|The **manager**|
|**Program**|A **task** being done by workers|

üßë‚Äçüíº **What‚Äôs Happening in the Office:**

1. You have **20 desks** (logical cores).

2. You have many **workers** (threads).

3. The **manager** (scheduler) assigns workers to desks.

4. The manager ensures no one is left idle, and if a desk is overloaded, workers can be moved between desks.

üîë **Important Concepts to Remember:**

1. **Threads are Logical:**

    - Each **thread** corresponds to a specific part of the program you‚Äôre running, like a worker assigned to a task.

    - The thread is **not bound** to a specific CPU core. It‚Äôs a **logical concept** that represents a segment of the program.

2. **Schedulers Control Assignment:**

    - The **scheduler** decides which thread gets executed on which logical core.

    - If there are more threads than available logical cores, the scheduler switches threads in and out of the cores as needed to maximize efficiency.

3. **Physical Cores & Logical Cores:**

    - You can have more threads than physical cores because of **hyper-threading**. Each physical core can handle multiple threads (logical cores).

    - In our example, with **10 physical cores** and **20 logical cores**, the scheduler has **20 places** to distribute the threads, but the threads themselves are not directly tied to these cores.

üìå **Conclusion:**

- **Threads** are the tasks your program does, and they are not tied to specific CPU cores. They are **logical constructs**.

- The **scheduler** (the office manager) assigns these threads to the available logical cores (desks).

- **Threads can move** between logical cores as needed, depending on the system‚Äôs needs and the scheduler's decisions.

- So, even though you may have 10 physical cores, **20 logical cores** give you **20 workstations** where threads (tasks) can run **in parallel**. The **scheduler** makes sure no workstation is idle unless necessary.

This allows efficient handling of tasks and better **parallelism**, improving the performance of your program!

**üßµ Thread Lifecycle**

1. **Own Call Stack**

    - Every thread has its own **call stack** ‚Äî this holds the function calls, local variables, and return addresses used by that thread only.

    - This separation is what allows multiple threads to run concurrently without stepping on each other‚Äôs toes.

2. **Termination**

    - When a thread finishes its execution (e.g., the code inside it ends or is aborted):

        - Its **stack is cleared**.

        - All **resources are released** (unless something is leaked).

        - The thread is **removed from the scheduler‚Äôs queue**.

        - It essentially **ceases to exist**.

3. **After Termination**

    - It‚Äôs no longer part of the process.

    - It doesn‚Äôt consume CPU time, memory, or appear in system monitoring tools.


Think of it like a temporary worker at a workstation: once their job is done, their desk is cleaned out and someone else may use that spot. ü™ë‚úÖ

**You said:**

In theory, we can create a program with 5,000 threads, but depending on how heavy each thread is, the processor will take significantly more time to handle them. After all, it only has about 20 "work desks" (cores or logical processors) to process those 5,000 threads‚Äîalong with all the threads coming from other programs and the operating system itself, is this correct?

**ChatGPT said:**

Exactly ‚Äî that's **absolutely correct**.

üß† Here's how it plays out:

You can absolutely create **5000 threads** in your program (the OS usually allows tens or hundreds of thousands, depending on available memory). But here's what happens:

**‚öôÔ∏è Real-World Impact of 5000 Threads:**

üî¢ 1. **Limited CPU Work Desks**

If your CPU has 20 **logical cores** (work desks), the OS scheduler can _only_ run 20 threads at the **same exact time**.

The other ~4980 threads will be:

- Sitting in a **queue**

- Or being **paused** (preempted) while others take turns

üìä 2. **Scheduling Overhead**

With more threads:

- The **scheduler works harder** to juggle which thread runs next

- This can lead to **context switching overhead**, where threads are frequently paused/resumed, which consumes CPU cycles

üïí 3. **Execution Time Increases**

If the threads are **CPU-intensive**, the program can become **slower**, not faster. You‚Äôre dividing limited time between too many heavy tasks.

üíæ 4. **Memory Usage**

Each thread has its own **call stack** (e.g., 1MB in .NET by default), so 5000 threads = **~5GB of memory** just for stacks ‚Äî not including your actual app logic.

üë• 5. **Competition with Other Apps**

You‚Äôre not alone. The OS and other apps also create threads. All of them share the same pool of CPU cores.

**üìå Summary:**

- Yes, you can create thousands of threads.

- But only a small number (equal to the number of logical cores) can run simultaneously.

- The rest will wait their turn.

- Having **too many threads can degrade performance** due to overhead and resource contention.

**You said:**

A thread is always associated with a single program‚Äîmore specifically, with a particular part of that program, such as the main thread.

**ChatGPT said:**

‚úÖ Exactly ‚Äî a **thread is always associated with a single process (program)** and handles the execution of **a specific path of code** within that program.

üß† **Breakdown:**

- **A process** = your running program

- **A thread** = one flow of instructions inside that program

- The **main thread** starts executing the `main()` method (or its equivalent)

- You can then create **additional threads** to run other parts of the program concurrently (e.g., handling UI, network, or background tasks)

üîí **A thread cannot:**

- Jump between programs

- Execute code from another process

It lives, runs, and dies **inside the boundaries** of the program (process) that created it.

**You said:**

If a thread in an ASP.NET controller reaches an `await` in an async method and gets released, is that thread terminated? And when a new request hits the controller, is a new thread created to handle it?

**ChatGPT said:**

Great question ‚Äî and you're thinking exactly in the right direction when it comes to **asynchronous execution** and **thread management**.

Let‚Äôs break it down with your example:

üß© **Scenario:**

You have a **web controller** (say in ASP.NET Core) with an `async` method. Inside that method, you `await` something like `await SomeIOOperationAsync();`

üîÅ **What happens when `await` is hit:**

1. **The current thread is _not deleted_** ‚Äî but it is **released back to the thread pool**.

    - It _stops executing_ your method and becomes available for other work.

2. The method‚Äôs **state is saved** (by the compiler-generated state machine).

    - This includes local variables and the exact line to resume from.

3. When the awaited operation (e.g., a DB call or HTTP request) **completes**, the continuation of your method is:

    - **Queued** to resume ‚Äî typically on a **different** thread from the pool.

    - There is **no guarantee it will be the same thread** as before.

üßµ **So what about new requests?**

- Yes, when a **new request hits** your controller:

    - A **new thread from the thread pool** is assigned to handle that request.

    - It executes the controller action up until it hits any `await`.

    - Then it's returned to the pool and reused for other tasks.

üìå **Summary:**

- **Threads are not deleted** after an `await`; they‚Äôre just returned to the pool.

- **Continuation** after the await may run on a **different thread**.

- **Each new HTTP request** is handled by a separate thread from the pool.

**You said:**

But if a new thread handles the resumed async operation, does it also receive the original call stack?

**ChatGPT said:**

Great question! Let's clarify that:

When a thread is released after hitting an `await` in an `async` method, **the call stack** does not directly carry over to the new thread that resumes the operation. Here's a more detailed explanation:

**The Flow of Execution (Breaking It Down)**

1. **Before `await`:**

    - When your thread is running the method, it has a **call stack** (local variables, execution state).

    - You‚Äôre executing some code (let‚Äôs say doing some calculations or processing).

2. **Hitting `await`:**

    - When you reach `await`, the **current thread is released back to the pool**. However, the method‚Äôs execution doesn‚Äôt completely stop.

    - The **state of the method** (local variables, current line of execution, etc.) is saved in a **state machine** generated by the compiler.

    - This **state machine** is responsible for resuming execution after the awaited operation completes.

3. **Resumption on a New Thread:**

    - When the awaited operation completes (e.g., data is fetched or IO is done), the **task scheduler** picks a thread from the pool to resume execution.

    - However, **this new thread does not carry the original call stack**. Instead:

        - It picks up the **state machine** that was saved when `await` was hit, which contains the method‚Äôs execution state (the call stack is not literally transferred).

        - The new thread **executes the next part of the method** where it left off, using the **saved execution context**.

    - This is why asynchronous methods don‚Äôt require the exact same thread to resume ‚Äî only the **execution state** is needed.

üß† **Why the Call Stack is Not Passed:**

- **Call Stack**: It's specific to each thread, containing information about function calls, local variables, etc. Once a thread is released, its call stack is discarded.

- **Execution State**: This refers to the data that is needed to resume the method (like local variables, the point in the method where execution paused, etc.). This state is saved in a **state machine** and can be picked up by any thread.

üìå **In Conclusion:**

- A **new thread** picks up where the `await` left off using the saved **state machine** and does not need the original call stack.

- The **new thread** doesn't carry over the exact "call stack" but continues the execution by referencing the saved **state**.

**You said:**

If we don't release a thread using the async/await pattern, will the CPU cores still spend processing time on it‚Äîeven if it's doing nothing‚Äîjust to keep it alive?

**ChatGPT said:**

Yes, you're absolutely right. If a thread doesn't reach an `await` and continues to run while doing nothing meaningful, it will still consume CPU resources, even if it isn't performing any useful work. Let's break this down:

**How Threads Work When They Are "Idle" or "Doing Nothing"**

- When a thread is executing in your program and **isn't performing any useful work**, such as being blocked on I/O, waiting, or just idling, it still occupies a **slot** on a CPU core.

- It remains active, meaning it's still **waiting for its turn** in the CPU scheduling queue, even if it's not executing any important task.

This can happen if the thread:

1. **Is blocked** ‚Äî such as waiting for a resource, like a file, or another operation, or if it is **waiting synchronously** (e.g., `Thread.Sleep()` or `Thread.Wait()`).

2. **Is running an infinite loop** ‚Äî without yielding control back or waiting on any condition.

3. **Does nothing** ‚Äî i.e., it‚Äôs simply running and consuming resources, like memory, but not performing any meaningful operation.

CPU Consumption and Scheduler

- **CPU Time**: If a thread is active, even if doing nothing, it will **consume CPU time**. The CPU scheduler will assign some processing time to the thread to allow it to run, even if it doesn't do anything productive.

- **Idle Thread (Not Yielding)**: If you have a thread that doesn‚Äôt yield control (such as an infinite loop without waiting for any event), it will **continuously use CPU resources**. This is inefficient because it **prevents other tasks from executing**.

**You said:**

What about the thread pool‚Äîdoes the program dynamically decide when to create and remove threads? And is there a limit to the number of threads an ASP.NET application can create?

**ChatGPT said:**

Yes, thread pooling and thread management are key aspects of how applications, like those in ASP.NET, handle concurrency efficiently. Let's dive into thread pools, how the program dynamically handles threads, and whether there are limits to the number of threads an ASP.NET application can create.

1. **What is a Thread Pool?**

- A **thread pool** is a collection of reusable threads managed by the operating system or the application. Instead of creating and destroying threads for each request, which is expensive in terms of system resources and time, the system **reuses existing threads** from the pool.

- Thread pools allow for **efficient handling of concurrent tasks** by reducing the overhead of repeatedly creating and destroying threads. The threads are allocated, used, and then returned to the pool after completing their task, ready to be reused.

2. **Thread Pool in ASP.NET**

- In ASP.NET, **task-based programming** (with `async/await`) and thread pooling play important roles in how threads are managed for web requests.

- **ASP.NET** (and other .NET applications) rely on the **.NET thread pool**, which is managed by the .NET runtime.

- When a request is made, **ASP.NET schedules the task** (such as handling a request in a controller) on a thread from the pool. Once the task is completed, the thread is returned to the pool.

- **Asynchronous programming** (using `async/await`) allows ASP.NET to be **non-blocking**, meaning it can release threads back to the pool during I/O-bound operations (e.g., waiting for a database query, file I/O) instead of keeping a thread occupied during that time.

3. **Dynamic Thread Creation and Deletion**

- **Dynamic Thread Creation**: The thread pool is managed by the operating system and the runtime, which means it dynamically creates threads when needed. However, the pool starts with a certain minimum size (a small number of threads) and can **expand** as needed when the demand for threads increases.

- **Thread Deletion**: Threads in the pool are not deleted when they complete their task. Instead, they are returned to the pool for reuse. However, after a period of inactivity, threads in the pool may be **recycled** or destroyed to save system resources, depending on the configuration of the thread pool and the runtime environment.

4. **Limit on Thread Creation**

- **Thread Pool Limits**: Yes, there are limits to how many threads the thread pool can create in an ASP.NET application, but these limits are dynamic and depend on several factors:

    - **Maximum Threads**: The thread pool has a **maximum number of threads** that it can allocate, which is typically determined by the operating system and configuration settings. For example, on Windows, the thread pool can create a large number of threads, but the number is finite to avoid overwhelming the system.

    - In ASP.NET, the maximum number of threads in the pool is usually set to a reasonable value based on the system‚Äôs resources and workload requirements.

- **Thread Pool Settings in .NET**:

    - The default **maximum number of threads** that can be created is usually determined automatically by the system based on the number of processors available.

    - You can **configure the thread pool** using the `.NET ThreadPool` class (e.g., `ThreadPool.SetMinThreads()` and `ThreadPool.SetMaxThreads()` methods) if you need more control over the minimum or maximum number of threads.

    However, these settings are typically adjusted based on system load and the available resources.

- **Blocking and Starvation**: If all threads are in use and new threads are needed, the requests might be queued up (waiting for a thread to become available). If the system is overwhelmed and doesn't have enough threads to handle all incoming requests, the system may experience **thread starvation**, where threads are not able to process tasks in a timely manner.

  This is why it's important to ensure that the thread pool isn't overwhelmed. In high-load applications, strategies like **asynchronous programming** or **offloading work to background queues** can help prevent blocking the main thread pool.

5. **Scaling and Resource Management**

- **Thread Pool Scaling**: The thread pool in ASP.NET can dynamically scale to meet demand, but it will be constrained by system resources (like CPU and memory) and the configured settings. The pool can **grow** to accommodate more threads when necessary, but it will also **shrink** when demand decreases, returning unused threads to the system.

- **System Resources**: While you can adjust thread pool settings, there are physical system limitations, such as CPU core count and memory, which will influence how effectively the thread pool can scale.

6. **Handling High Concurrency in ASP.NET**

- ASP.NET makes heavy use of **asynchronous I/O** operations to avoid blocking threads. For example, when an HTTP request is handled, the server may initiate an async I/O operation (like database queries or HTTP calls) and **release the thread back to the pool** while waiting for the operation to complete.

- This allows ASP.NET to handle **thousands of concurrent requests** efficiently, without consuming excessive resources for each one.

- The **Thread Pool** is particularly useful for handling **CPU-bound tasks** or tasks that involve long-running operations, as the threads can be reused for other tasks when not in use.

7. **Why Thread Pools are Efficient in ASP.NET**

- **Reducing Overhead**: Without a thread pool, the system would need to create and destroy threads for every request, which is an expensive operation. The thread pool eliminates this overhead by keeping threads ready for reuse.

- **Avoiding Thread Creation Bottlenecks**: If your application is handling high concurrency, thread creation and destruction can become a bottleneck. The thread pool mitigates this by keeping threads ready to handle multiple tasks without needing to create new threads for each one.

- **Efficient Resource Management**: Thread pools allow the system to balance between having enough threads to handle requests and avoiding having too many threads, which could saturate the system‚Äôs CPU and memory.

Summary:

- **Thread Pool**: ASP.NET uses a thread pool to manage threads efficiently. Threads are **reused** rather than created and destroyed for each request.

- **Dynamic Creation**: The thread pool dynamically creates threads when needed, within limits, and manages their lifecycle (releasing or recycling threads).

- **Limits**: There are limits to how many threads the pool can create, typically configurable by the system and developer. These limits depend on available system resources and configuration settings.

- **Efficiency**: Thread pools are key to handling high concurrency without overwhelming the system. Asynchronous programming in ASP.NET ensures threads are not kept busy unnecessarily, freeing up resources for other tasks.

This setup enables ASP.NET to handle a large number of concurrent requests efficiently, but it's essential to monitor and adjust thread pool settings, particularly for applications with high throughput or demanding workloads.

**You said:**

*"When a request is made, ASP.NET schedules the task (such as handling a request in a controller) on a thread from the pool. Once the task is completed, the thread is returned to the pool. Asynchronous programming (using async/await) allows ASP.NET to be non-blocking, meaning it can release threads back to the pool during I/O-bound operations (e.g., waiting for a database query, file I/O) instead of keeping a thread occupied during that time."*

So even if we don‚Äôt use `async/await`, many users can still interact with the application without it freezing. However, this means a new thread must be used for each user request, which can eventually exhaust the thread pool if the number of concurrent users grows large?

**ChatGPT said:**

Yes, you're correct! Even without using `async/await`, ASP.NET can handle multiple concurrent requests, but there are some important considerations about how threads and the thread pool are managed.

**Here's how it works:**

1. **Handling Requests Without `async/await`**:

    - When a user sends a request to an ASP.NET application, a thread from the thread pool is assigned to handle that request. If the request involves CPU-bound operations (e.g., processing data), the thread will be kept busy until the task completes. This means the thread is **blocked** during that time and cannot be reused for another request until it finishes its task.

    - **If multiple users are making requests simultaneously**, ASP.NET will assign additional threads from the thread pool to handle those requests, assuming there are threads available. This works fine as long as the thread pool has enough resources to allocate threads for each incoming request.

2. **Impact on the Thread Pool**:

    - **More Users = More Threads**: If you have many concurrent users, and each request requires a thread from the pool, the number of threads being used will increase. The thread pool has a **limited number of threads** that can be allocated at any given time (although the size of the pool can grow dynamically depending on system resources and configuration).

    - As you get more users and more threads are allocated, the thread pool can get **exhausted** if there are too many simultaneous requests. This can cause **thread starvation**, meaning requests will have to wait for a thread to become available. If the pool is saturated and there are not enough threads to handle requests, the application may experience delays or timeouts.

3. **Asynchronous Programming (`async/await`)**:

    - When you use `async/await`, the key advantage is that you **release the thread back to the pool during I/O-bound operations** (like waiting for a database query or making HTTP requests). This makes it non-blocking, meaning the thread is not sitting idle while waiting for these operations to complete. Instead, it is free to handle other requests.

    - This way, you can **handle many more concurrent requests** without consuming additional threads for tasks that would otherwise be blocked (such as waiting for database queries or file I/O). The **async thread does not occupy a thread** while waiting, which greatly reduces the load on the thread pool.

**To clarify:**

- **Without `async/await`**: Each request occupies a thread in the pool for the entire duration of the request's processing, even if the request is waiting for I/O (like database queries). This can quickly fill up the thread pool when there are many concurrent requests.

- **With `async/await`**: The thread is released back to the pool while waiting for I/O, which means the thread is not blocked, and the same thread can be reused to handle other requests. This improves the scalability of the application, allowing it to handle many more concurrent requests without running into thread pool limits.

**Example:**

- Suppose you have a web application with 1000 concurrent requests and no `async/await`:

    - Each request uses one thread in the pool for its entire duration, even if it's waiting for a database query. If each request takes a long time (e.g., 5 seconds), the thread pool will be consumed very quickly, and requests will start waiting for available threads, potentially leading to a slow application or timeouts.

- With `async/await`:

    - When a request reaches an `await` (e.g., waiting for a database query), the thread that was handling the request is released back to the pool, and a new thread is not needed for the waiting period. After the I/O operation completes, the thread pool picks up the continuation of the request and resumes processing. This means the system can handle **many more concurrent requests** without running into the same thread pool exhaustion problem.

**Thread Pool Management:**

ASP.NET and the .NET runtime are quite efficient at managing the thread pool, but it still has limits:

- **Minimum Threads**: There is a minimum number of threads that are always available in the pool, even under low load.

- **Maximum Threads**: There is also a maximum number of threads the pool can grow to, depending on the system's resources and the configuration.

If your application uses `async/await` properly for I/O-bound operations, the **thread pool usage is much more efficient**, and you can scale better with higher concurrency. On the other hand, if you're handling a lot of CPU-bound tasks or blocking I/O, the thread pool will quickly become a bottleneck as threads get occupied for longer periods of time.

**Conclusion:**

- Even without `async/await`, your ASP.NET application can handle concurrent requests, but the threads in the thread pool are occupied for the full duration of the request, which limits the scalability.

- With `async/await`, you improve scalability by releasing threads during I/O-bound operations, allowing more users to interact with your application without overloading the thread pool.

So yes, without `async/await`, every user request will use a new thread from the thread pool, and as the number of users increases, the thread pool will eventually become full, potentially slowing down the system.
## `Thread(...)` vs `Task.Run(...)`
`new Thread(...)`

- **Always creates a new OS thread**.

- Higher memory and scheduling overhead.

- Gives full control over the thread (e.g., priority, lifetime).

- Useful for long-running or isolated operations.

`Task.Run(...)`

- **Queues the work to the `ThreadPool`**.

- Reuses existing threads if possible (more efficient).

- Thread lifetime is managed by the `ThreadPool`.

- Preferred for short-lived, I/O-bound, or background tasks.

**Example:**

```csharp
// Creates a new, dedicated thread
Thread thread = new Thread(() => Console.WriteLine("Hello from Thread!"));
thread.Start();

// Uses ThreadPool
Task.Run(() => Console.WriteLine("Hello from Task!"));
```

With `System.Threading.Thread` you're demanding a new thread directly, while `Task.Run` is a **request for asynchronous execution**, and the runtime decides the most efficient way to do it.
## `ThreadPool` vs Dedicated Thread - Efficiency vs Control
**‚úÖ The `ThreadPool`:**

- **Reuses real OS threads**, but we don't control them directly.

- Think of them as **"logical workers"** managed by the .NET runtime.

- `ThreadPool` threads are **backed by real threads**, but not one-to-one.

- They're designed for **short-lived, background, non-blocking tasks**.

- Efficient because they **avoid the overhead** of creating and destroying threads.

- The number of threads is **dynamically adjusted** by the runtime based on workload and system resources.

‚úÖ **`new Thread(...)` (`System.Threading.Thread`):**

- Always creates a **dedicated, real OS thread**.

- That thread is mapped to a **hardware thread** (or scheduled by the OS across cores).

- These are more **resource-intensive**.

- Gives more control but less efficient if overused.

- Useful when you need:

    - Long-running tasks

    - Thread affinity

    - Explicit control over thread lifetime

‚úÖ **Physical cores and threads:**

- A **CPU core** can run one or two hardware threads simultaneously (with **Hyper-Threading**).

- But the OS may schedule **hundreds of logical threads** on a limited number of cores.

- These logical threads **take turns** using the available physical cores, managed by the OS scheduler.

**Dedicated Threads vs `ThreadPool` ‚Äì Resource Control vs Optimization**

When you use `new Thread(...)`:

- You're **reserving a dedicated OS thread**.
    
- That thread is **not managed by the `ThreadPool`**.
    
- It stays alive until it finishes, even if it's idle ‚Äî so it **consumes more resources**.
    
- You're **taking away a thread** that could otherwise be reused by the framework for other tasks.
    
- This **reduces overall efficiency**, especially if you create many such threads.
    
- The **`ThreadPool` is optimized** to manage limited resources by:

    - Queuing work

    - Scaling the number of threads dynamically

    - Reusing threads to avoid expensive creation/destruction

**‚úÖ In short:**

Using `ThreadPool` (e.g., via `Task.Run`) allows the .NET framework to **optimize CPU usage and resource allocation**.  
Manually creating threads with `new Thread()` should be **reserved for very specific needs**, like:

- Long-running background work

- Threads with special affinity or isolation

- Real-time systems where you need strict control

üß† **Summary:**

You can think of **`ThreadPool` threads as lightweight, reused wrappers around real OS threads**, while `new Thread()` creates a fresh **dedicated OS thread**, consuming more resources and bypassing the optimization of the pool.
Using `new Thread()` gives you full control but consumes more system resources and bypasses the .NET `ThreadPool`. In contrast, `Task.Run` leverages the `ThreadPool` for efficient, scalable, and optimized thread management. Use dedicated threads only when you need strict control or isolation.
### Thread vs. Task: Main Difference
```csharp
// Using Task.Run()
class Program
{
    static void Main()
    {
        // Start a new task using the thread pool to run ParallelThread asynchronously
        Task.Run(() => ParallelThread());

        Console.WriteLine("Main thread finishes.");
    }

    static void ParallelThread()
    {
        for (int i = 0; i <= 100; i++)
        {
            Console.WriteLine($"Parallel thread in for loop, i = {i}.");
        }

        Console.WriteLine("Parallel thread finishes.");
    }
}

// Using Thread
class Program
{
    static void Main()
    {
        // Creating and starting a new thread
        Thread t = new Thread(() => ParallelThread());
        t.Start();

        Console.WriteLine("Main thread finishes.");
    }

    static void ParallelThread()
    {
        for (int i = 0; i <= 100; i++)
        {
            Console.WriteLine($"Parallel thread in for loop, i = {i}.");
        }

        Console.WriteLine("Parallel thread finishes.");
    }
}
```

1. **`Task.Run()`**:

    - A `Task` is not necessarily tied to a **physical thread** in the same way. When you use `Task.Run()`, the task is typically scheduled to run on a **`ThreadPool` thread**, which is a managed set of threads in .NET.

    - If the main thread exits before the task completes, the **`ThreadPool`** may decide to terminate the task or allow it to run, but the main thread **won't wait** unless you explicitly tell it to wait (e.g., `task.Wait()`).

    - `Task` is part of a **higher-level abstraction** provided by the .NET runtime that manages threads for you. The **`ThreadPool`** reuses threads, and if the main thread exits, the task may not continue running (depending on the environment and the way the thread pool is managed).

2. **`Thread`**:
    - When you use `new Thread(...)`, you're creating a new **physical thread** that runs independently of the main thread. The new thread will continue executing its code until it finishes, regardless of whether the main thread is still running or has already finished.
    
    - The **thread is independent**: The application doesn't automatically wait for a `Thread` to finish unless you explicitly tell it to (e.g., using `Join()`).

    - This is why the `Thread` continues running after the main thread finishes, as it's a separate **system thread** managed by the OS, and it doesn't "die" when the main thread exits.

Why Does a `Thread` Continue After the Main Thread Exits?

- **Threading model**: When you create a `Thread`, you're directly managing a physical OS-level thread. The OS doesn't care if your main thread finishes; the background thread continues running until it finishes its execution.

- **Thread lifecycle**: The lifecycle of a `Thread` is independent of the main thread. The main thread can finish, but the background thread will still execute until it completes its task (unless the OS terminates the process).

Why Does `Task.Run()` Behave Differently?

- **Task scheduling**: A `Task` runs on a thread managed by the **`ThreadPool`**, and the `ThreadPool`'s threads can be reused by other tasks or threads, especially if the main thread finishes quickly. The lifecycle of a `Task` is also more dependent on the thread pool and may be affected by things like **garbage collection** or **thread pool management**.

- **Main thread exit**: If the main thread finishes and the only remaining task is a background `Task`, the runtime may decide that the process can be terminated, as there are no more active threads running from the perspective of the application (especially in cases where no `task.Wait()` or `task.Result` is used). This can cause the program to exit before the task finishes.

**Why the `Thread` Doesn't Stop When Main Thread Exits:**

- A `Thread` is a **system thread**, and the OS manages its execution independently of the main thread. When you call `Start()` on a `Thread`, it schedules the thread for execution, and it will keep running until it's finished ‚Äî the main thread exiting doesn't stop the thread unless explicitly terminated.

**Conclusion:**

- **`Thread`**: The background thread will continue running even after the main thread exits because it's an independent system-level thread.

- **`Task.Run()`**: The task is scheduled in the **`ThreadPool`**, and the runtime may decide to terminate the application once the main thread finishes if no other tasks are actively running.

This distinction is important in scenarios where you want a background operation to continue running after the main thread finishes. If you want to ensure the task or thread completes before the program exits, you can use `task.Wait()` for tasks or `thread.Join()` for threads.
If you want the behavior of the `Thread` to match the `Task` (in terms of stopping when the main thread finishes), you could explicitly handle the completion of the `Thread` using `Thread.Join()` or other synchronization mechanisms. 
## `await / async` Pattern
‚úÖ **When a method is marked `async`:**

1. **It's just like a normal method** ‚Äî until it hits an `await`.

    - All synchronous code runs **immediately**, just like in a normal method.

    - The `await` is where the method **can pause** and yield control, allowing other work to happen.

2. **It must return** one of the following:

    - `Task` ‚Äî if it returns nothing

    - `Task<T>` ‚Äî if it returns a result

    - `void` ‚Äî only in specific cases (e.g., event handlers; not awaitable)

In an `async` method, the compiler **automatically wraps** your return value in a `Task` or `Task<T>` behind the scenes.

- If the method is `async Task`, you don‚Äôt need to return anything explicitly ‚Äî the compiler returns a `Task` for you.

- If the method is `async Task<T>`, you just `return` a value of type `T`, and the compiler wraps it in a `Task<T>`.

- All non-`void` `async` methods **always return a `Task` or `Task<T>`** ‚Äî never the raw value directly.

‚úÖ **Differences between a normal method and an `async` method:**

|Feature|Normal Method|Async Method|
|---|---|---|
|Can use `await` inside|‚ùå No|‚úÖ Yes|
|Return type|Any (`void`, value)|Must be `Task`, `Task<T>`, or `void`|
|Execution|Immediate, all code|Immediate until `await`|
|Asynchronous behavior|‚ùå No|‚úÖ Yes, if using `await`|

üß† **Key Insight**

If you **mark a method `async` but never `await` anything inside**, it's still valid, but:

- It will **run synchronously**.

- The compiler will give a **warning**: "This async method lacks 'await' operators and will run synchronously."

üß™ **Example**

```csharp
async Task SayHello()
{
    Console.WriteLine("Hello");  // runs immediately
    await Task.Delay(1000);      // yields control here
    Console.WriteLine("World");  // resumes after delay
}
```
### await
In asynchronous programming, **`await`** is a powerful tool that helps manage the flow of your program without blocking threads. Here's how it works and why it's important:

**What `await` Does:**

1. **"Don't Continue Until This Task Finishes"**:

    - The keyword `await` tells the program to **pause execution** at that point until the asynchronous operation (represented by a `Task`) completes.

    - The program **does not continue** past the `await` statement until the task is finished. However, this pause is **non-blocking**, meaning the thread is free to handle other tasks while waiting for the asynchronous operation to complete.

    **Example**:

```csharp
public async Task<int> FetchDataAsync()
{
    var data = await GetDataFromDatabaseAsync();
    return data;
}
```

In this example, the `FetchDataAsync` method will wait until `GetDataFromDatabaseAsync()` completes. The program won‚Äôt continue executing after the `await` statement until it has the result from the database.

2. **Automatic Unpacking of the Result**:

- When you use `await` on a `Task<T>`, it automatically "unwraps" the result from the `Task`. This means you can access the returned value directly without needing to call `.Result` or `.Wait()`, which are often used in synchronous code.

**Example:**

```csharp
var result = await FetchDataAsync();
Console.WriteLine(result);  // Accesses the result directly
```

**How `await` Differs from `.Result`**:

- When you use `.Result`, you are **explicitly blocking the thread** until the `Task` completes. This means the thread is **not idle**; instead, it is actively waiting, preventing it from doing any other work during that time. In other words, the thread is **blocked**, not free to be used elsewhere, which **defeats the purpose of asynchronous programming**‚Äîwhere the goal is to allow threads to be free to do other work while waiting for a task to complete.

**Example (Blocking):**

```csharp
var result = myTask.Result;  // Blocks the thread until myTask finishes
Console.WriteLine(result);
```

Using `.Result` blocks the current thread until `myTask` completes, which can lead to performance issues, especially in UI or server-side applications where responsiveness is important.

**Why `await` is Preferred**:

- **Non-blocking**: `await` allows the program to continue executing other tasks in the background while waiting for the task to complete. The thread is not blocked, meaning it can handle other operations during the wait.

- **Automatic Unpacking**: Using `await` simplifies the code since you don‚Äôt have to deal with manually extracting the result from the `Task` object. It makes asynchronous code cleaner and more readable.

**Conclusion**:

- **`await`** is used to pause execution without blocking the thread, allowing for efficient, asynchronous operations.

- **It automatically unpacks** the value from the `Task`, so you don‚Äôt need to use `.Result` (which blocks the thread).

- **Avoid blocking the thread** with `.Result` or `.Wait()` in asynchronous code, as these can lead to performance bottlenecks and defeat the purpose of asynchronous programming.

By using `await`, you ensure that your program remains responsive, especially in scenarios involving I/O-bound tasks like file reading, network requests, or database queries.
## CSharp Task vs JavaScript Promise
**üß† First, a key distinction:**

‚öôÔ∏è **JavaScript:**

In JavaScript, the `Promise` class is the **core abstraction** of asynchronous computation. It is **manually constructed** and explicitly wired with an executor function:

```javascript
const promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve(42), 1000);
});
```

‚öôÔ∏è **C#:**

In C#, the core class is **`Task` / `Task<T>`**, and **not** a `Promise` class.

- The C# `Task` represents **an ongoing operation**, and yes, `async/await` is also **syntax sugar**, but it's built over `Task` and the **compiler-generated state machine**.

- Unlike JS, you do **not** manually wire `resolve` and `reject`. Instead, you rely on the `TaskCompletionSource<T>` class when you want to manually control task completion.


Example:

```csharp
var tcs = new TaskCompletionSource<int>();

// Somewhere in your code
tcs.SetResult(42);  // Like resolve
tcs.SetException(new Exception()); // Like reject

Task<int> task = tcs.Task;
```

‚úÖ **Summary Comparison: `Promise` vs. `Task`**

|Feature|JavaScript `Promise`|C# `Task`|
|---|---|---|
|Base class|`Promise`|`Task` / `Task<T>`|
|Manual control|Yes (with `resolve`, `reject`)|Yes (with `TaskCompletionSource<T>`)|
|Syntax sugar|`async/await`|`async/await`|
|Threading|Single-threaded event loop|Multi-threaded, uses thread pool|
|Execution model|Event loop (non-blocking)|Thread pool or async IO (e.g., I/O Completion Ports)|
|Cancelation|No built-in cancellation|Yes (`CancellationToken`)|
|Exception handling|`.catch()` or `try/catch`|`try/catch` and `task.Exception`|
|Result access|`.then()` or `await`|`.Result`, `.ContinueWith()` or `await`|

üí° **Is `Task` like a `Promise`?**

**Yes, conceptually**: both are placeholders for future results.

**But implementation-wise**, C#‚Äôs `Task` is:

- Tied to the CLR thread pool and task scheduler.

- Often backed by OS-level asynchronous primitives (like overlapped I/O or completion ports).

- Able to be completed manually via `TaskCompletionSource`.


JavaScript Promises are:

- Lightweight and completely managed in the JS engine.

- Not tied to threads ‚Äî they rely on the **event loop** and **microtask queue**.

- Always execute their `.then()` handlers asynchronously (after the current call stack clears).

üîß **Behind the scenes in C#: `async/await`**

When you write this:

```csharp
async Task<int> Foo()
{
    await Task.Delay(1000);
    return 42;
}
```

The C# compiler:

- Transforms it into a **state machine**.

- It wires continuations via `TaskAwaiter` (e.g., `.GetAwaiter().OnCompleted()`).

- It schedules the rest of the method as a **continuation** once the `awaited` task completes.


So yes ‚Äî similar to Promises and `.then()` in JS ‚Äî **but entirely separate implementations.**

üîö **In Short:**

- C# does **not** use Promises under the hood ‚Äî it has its own powerful system with `Task`, `TaskCompletionSource`, and compiler-generated state machines.

- `async/await` is syntax sugar in both languages.

- They serve similar purposes but are implemented very differently due to the runtime environments (CLR vs JS engine).
# Bookmarks
Completion: 01.05.2025