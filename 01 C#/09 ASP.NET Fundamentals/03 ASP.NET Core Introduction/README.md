# General
## Overview
ASP.NET Core е кросплатформен, с отворен код, фреймуърк за разработка на бекенд приложения с C#.

ASP.NET Core Web Pages: Това е опция за изграждане на прости уеб приложения, които използват Razor view engine за вграждане на C# код директно в HTML. Подходящо е за по-малки проекти и бързо създаване на динамично съдържание.

ASP.NET Core MVC: Тази опция следва архитектурния модел Model-View-Controller (MVC), който разделя приложението на три основни компонента: модел (данни и бизнес логика), изглед (UI) и контролер (обработва входа от потребителя). Подходящо е за по-сложни, големи приложения, които изискват добра структура и разделение на отговорностите.

ASP.NET Core Web API: Това е опция за изграждане на RESTful уеб услуги, които могат да се използват за комуникация между различни приложения и устройства, като мобилни приложения или уеб фронтенд решения. Подходящо е за създаване на API интерфейси за обмен на данни, обикновено чрез JSON формат.

Отлична документация: [ASP.NET documentation | Microsoft Learn](https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-9.0)

ASP.NET Core предлага:

- Интеграция с модерни клиентски фреймуърци (Angular, React, Blazor и други): Това позволява лесно свързване на съвременни уеб технологии с ASP.NET Core, като осигурява по-добро взаимодействие между сървър и клиент и позволява изграждането на динамични и интерактивни уеб приложения.

- Работни потоци за разработка (MVC, WebAPI, Razor Pages, SignalR): Разработчиците имат избор от различни архитектурни подходи, в зависимост от типа приложение, което искат да изградят. MVC предлага структурирано разделение на компонентите, WebAPI е подходящо за RESTful услуги, Razor Pages е опростен начин за създаване на динамични уеб страници, а SignalR е подходящ за изграждане на реално време комуникация в приложенията.

ASP.NET Core приложенията могат да се изпълняват както на .NET Core, така и на .NET Framework: Това осигурява гъвкавост и възможност за стартиране на приложения както на модерната, кросплатформена среда .NET Core, така и на традиционната .NET Framework, което е важно за съществуващи проекти, които се нуждаят от съвместимост.
## Main Features
Единен фреймуърк за изграждане на уеб UI и уеб API, с архитектура за тестване – можем лесно да изграждаме, поддържаме и тестваме приложенията си в една обща структура.

Възможност да разработваме и стартираме на Windows, macOS и Linux – така избираме най-удобната за нас операционна система.
- Възможност да хостваме на IIS, Nginx, Apache, Docker или самостоятелно в собствен процес – това ни дава свобода при избора на инфраструктура.

Вградена dependency injection – внедряваме зависимости по чист и гъвкав начин, който подобрява тестването на нашите приложения.

Лек, високопроизводителен и модулен HTTP request pipeline (middlewares) – конфигурираме гъвкаво как се обработват HTTP заявките в нашето приложение.

Razor Pages е програмен модел, базиран на страници, който улеснява изграждането на уеб UI – така бързо структурираме потребителския интерфейс.

Blazor ни позволява да използваме C# в браузъра и да споделяме логика между сървъра и клиента – това ни спестява нуждата от JavaScript в много случаи.

Razor markup предоставя синтаксис за Razor Pages, MVC изгледи и Tag Helpers – така комбинираме C# и HTML в единен изразителен синтаксис.

Cloud-ready конфигурационна система, базирана на среди – задаваме настройки според средата, в която работим (например development, staging, production).

Side-by-side версии на приложения – стартираме няколко версии едновременно, когато ни е нужно да тестваме или поддържаме съвместимост.

Инструменти, които улесняват съвременната уеб разработка (Visual Studio, VS Code, CLI) – използваме ги, за да ускорим и опростим процеса на писане и поддръжка на код.
## The MVC Pattern
Формулиран е за първи път в края на 70-те години от Trygve Reenskaug като част от езика Smalltalk – обектно-ориентиран език, от който можем да проследим много от съвременните концепции.

Поддържа повторна употреба на кода и ясно разделение на отговорностите – това ни позволява да изграждаме по-модулярни и поддържани приложения.

Първоначално е създаден за настолни приложения, но впоследствие е адаптиран за интернет среди – така можем да го прилагаме успешно и в уеб разработката.
## The Model-View-Controller (MVC) Pattern
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250412214520.png)

**Controller (Контролер)**

Обработва действията на потребителя и връща отговор – реагира на входящите заявки и генерира съответните резултати.

Обработва заявките с помощта на изгледи и модели – използва View и Model, за да оформи крайния отговор.

Представлява набор от класове, чрез които:  
– приема комуникация от потребителя  
– управлява цялостния поток на приложението  
– съдържа специфичната логика на приложението

Всеки контролер съдържа едно или повече „действия“ (Actions), чрез които се изпълняват конкретни функционалности при дадени заявки.

**Model (Модел)**

Набор от класове, които описват данните, които показваме в потребителския интерфейс (UI).  
Може да съдържа правила за валидиране на данните, за да се осигури тяхната коректност.

Съществуват два основни типа модели: 

1. View model / binding model  
   Съответства на потребителския интерфейс на уеб страницата чрез C# клас.  
   Използва се за прехвърляне на данни между View и Controller.  
   Част е от архитектурата на MVC и помага за управлението на формата на данните, с които взаимодействаме в потребителския интерфейс.

2. Database model / domain model
   Съответства на таблица в базата данни чрез C# клас, използвайки ORM (напр. Entity Framework).  
   Представя реалната структура на данните, които се съхраняват в базата.

**View (Изглед)**

Дефинира как потребителският интерфейс на приложението ще бъде показан – определя визуалното оформление и структура на приложението.

Може да поддържа главни изгледи (layouts) и под-изгледи (partial views или контроли) – използва се за създаване на по-сложни и многократни елементи на интерфейса.

В уеб приложения: шаблон за динамично генериране на HTML – осигурява начин за създаване на съдържание, което се обновява в зависимост от данните.
## MVC Steps
1. Входящата заявка се насочва към Контролер.

2. Контролерът обработва заявката и създава модел (view model).
	- Също така избира подходящия резултат (например: View).

3. Моделът се подава към изгледа (View).

4. View преобразува модела в подходящ изходен формат (HTML).

5. Генерира се отговор (HTTP Response).

**View** – User clicks a button  
**Controller** – Handles the event and converts it into a request  
**Model** – Executes the request and retrieves the data  
**Controller** – Passes the retrieved data to the view  
**View** – Displays the data to the user
## Web MVC Frameworks
Уеб MVC frameworks се използват за изграждане на уеб приложения.

Осигуряват структурата и енджина на MVC за изграждане на уеб приложения.  

Контролерите обработват HTTP GET / POST заявки и връщат изглед.  

Изгледите визуализират HTML + CSS, базирани на моделите.  

Моделите съдържат данни на приложението за изгледите, подготвени от контролерите.

**Примери за уеб MVC frameworks:**

ASP.NET Core MVC (C#), Spring MVC (Java), Express (JavaScript), Django (Python), Laravel (PHP), Ruby on Rails (Ruby), Revel (Go)
## ASP.NET Core MVC
ASP.NET Core MVC предоставя функционалности за изграждане на уеб API и уеб приложения.

Използва дизайнерския шаблон Model-View-Controller (MVC).

Лек е, с отворен код, лесен за тестване и с добра поддръжка от инструменти.

Използва Razor синтаксис за Razor Pages и MVC изгледи.

Поддържа изграждането на RESTful услуги чрез ASP.NET Core Web API.
- Има вградена поддръжка за множество формати на данни, съдържателно договаряне (content negotiation) и CORS.

Позволява постигане на висококачествена архитектура и оптимизиране на работата ни като разработчици.
- Прилага принципа „Конвенции пред конфигурации“, което означава, че следваме общи правила вместо да правим излишни настройки.

Механизмът за свързване на модела (model binding) автоматично картографира данни от HTTP заявки.

ASP.NET поддържа валидация на модели както от страна на клиента, така и от страна на сървъра. Основният принцип, който трябва да спазваме, е че **всички лъжат** — не бива да вярваме на никого, дори на себе си. Затова платформата ни предоставя възможност за двустепенна валидация: първо на клиента, после на сървъра.
Клиентската валидация служи основно за подобряване на потребителското изживяване (UX), но не е сигурна, защото се изпълнява от самия клиент. Той може да променя HTML и JavaScript кода, да премахне `required` полета или да заобиколи ограничения чрез инструменти като browser developer tools или Postman. Затова сървърната валидация е задължителна и единствената, на която можем да разчитаме за сигурна обработка на данните.

Често го комбинираме с Entity Framework за обектно-релационно съпоставяне (ORM).
### Features
ASP.NET Core предоставя **routing механизъм** за съпоставяне на HTTP заявки към контролери и действия. 

**Dependency Injection** се използва за инжектиране на компоненти по време на изпълнение, което улеснява модулността и тестването на приложенията.

С **Razor view engine** можем да създаваме **строго типизирани изгледи**, които комбинират C# код с HTML по ясен и подреден начин. 

**Model binding** автоматично свързва данните от HTTP заявките с C# модели, а **валидацията** се извършва както на клиента, така и на сървъра за по-голяма сигурност.

Чрез **Tag Helpers** можем да вграждаме сървърен код директно в HTML елементи. ASP.NET Core поддържа и мощни инструменти като **филтри**, **зони (Areas)** и **middlewares**, които осигуряват гъвкавост в изграждането на архитектурата.

Вградените **системи за сигурност** включват **ASP.NET Identity**, чрез която можем да управляваме потребители, роли и автентикация. Има още множество възможности, които подпомагат разработката на модерни и сигурни уеб приложения.
## Creating an ASP.NET Core MVC App
1. Създаваме нов проект във Visual Studio и избираме шаблона **ASP.NET Core Web App (Model-View-Controller)**.

2. Избираме желаната .NET версия. Ако искаме функционалност за потребителски акаунти, на `Authentication type` избираме **Individual Accounts** и маркираме **Configure for HTTPS**.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250413171321.png)
### Static files
Всички статични ресурси на приложението – JavaScript файлове, CSS стилове, изображения, икони и др.
### `Program.cs`
Основният клас, чрез който се конфигурира приложението. Тук се задават настройките за **inversion of control container (IoC)**, конфигурира се **middleware pipeline-а**, и се стартира приложението. Имаме `builder`, който има пропърти `Services` – това е контейнерът за зависимостите (IoC), в който се регистрират услуги, включително `DbContext`. След като всички услуги са регистрирани (независимо в какъв ред), извикваме `builder.Build()`, за да изградим приложението.
След `Build()` започва конфигурирането на **middleware pipeline-а** – това е поредица от компоненти, които обработват HTTP заявките. Всеки ред в тази конфигурация има значение и редът на изпълнение е важен. Например, `app.UseAuthentication()` трябва да бъде извикан преди `app.UseAuthorization()`, за да може първо потребителят да бъде идентифициран (автентикация), и след това да му бъдат зададени права (авторизация). Ако тези две извиквания се разместят, `Identity` няма да функционира правилно. След като middleware-ите са конфигурирани, приложението се стартира с `app.Run()`.
### `appsettings.json`
Съдържа конфигурационни настройки за приложението, като например връзки към бази данни, логване и други параметри. Важно е да не се съхраняват чувствителни данни като пароли или API ключове в този файл, тъй като съдържанието му става публично при качване в GitHub. Разликата между този файл и **`secrets.json`** е, че **`appsettings.json`** се намира в директорията на проекта и се включва в source control системата, докато **`secrets.json`** се намира извън проекта – в потребителска папка на компютъра – и не се качва в source control. Проблемът при **`secrets.json`** е, че другите участници в проекта не разполагат с него по подразбиране, затова е необходимо да се измисли начин да им се предадат необходимите ключове и настройки – например чрез документ с инструкции или чрез използване на защитен vault.
### Areas 
Когато създадем ASP.NET Core MVC приложение с **Individual Accounts** (при избиране на тип автентикация), **Identity framework** се добавя автоматично. Той се намира в специална папка **`Areas/Identity`**, която следва архитектурата на Razor Pages. В тази папка се съдържат Razor страници (като Login, Register, Forgot Password и др.), чрез които се управляват потребителите, ролите и процесите по автентикация и авторизация.
### Controllers 
Папката, в която се съхраняват всички контролери на приложението. При създаване на проект с шаблона, по подразбиране имаме един контролер – `HomeController`. Контролер е клас, който наследява базовия клас `Controller`, като по конвенция името му завършва на `Controller` (например `ProductController`). Всеки публичен метод в него се нарича action – той обработва входящи HTTP заявки и връща отговор (обикновено HTML чрез View, JSON, redirect и други). Контролерите са отговорни за логиката на приложението – получават данни от модела и избират каква View да върнат на клиента.
Контролерът избира кое View да върне според името на action метода. По конвенция, в папката `Views` има подпапка с името на контролера (без наставката `Controller`), а в нея се намират `.cshtml` файловете с имената на съответните action-и. Например, `HomeController` с метод `Index()` ще върне View от `Views/Home/Index.cshtml`. Освен това, в метода може да се подаде и стринг с името на конкретното View, което да се върне, ако не следваме конвенцията за имената.
Ако контролерът не намери съответното View в папката с името на контролера, следващото място, където ще търси, е в папката **Shared**. Тази папка се използва, когато искаме да споделим дадено View между няколко контролера. В случай, че и там не бъде открито, ще бъде хвърлена грешка.
### Dependencies
Показват зависимостите на проекта. Имаме **Frameworks**, които включват множество библиотеки, използвани от приложението. Вътре в един framework можем да видим всички включени библиотеки, които той използва. Освен тях, можем да добавим и допълнителни външни библиотеки според нуждите на проекта – те се изтеглят и съхраняват в папката **packages**.
# Misc
# ChatGPT
## .NET as a Platform vs. Frameworks – Key Concepts and Relationship
**.NET is a platform**, not just a framework. It provides a complete development environment that includes a **runtime** (like the .NET CLR), various **tools** (such as compilers, debuggers, and IDEs), and a rich set of **libraries** (like the Base Class Library - BCL). It supports multiple **frameworks** for building different kinds of applications—such as **ASP.NET Core** for web development, **EF Core** for data access, and **MAUI** for cross-platform mobile and desktop apps.

A **framework** is typically a specialized set of **libraries** designed to help developers build specific types of applications. It operates within the platform. In general, frameworks are **collections of libraries** that enforce certain patterns and conventions. They often provide a structure to the application and call your code as part of the execution flow (inversion of control).

For example:

- **ASP.NET Core** is a web framework built on the .NET platform.
    
- **Entity Framework Core** is a framework for working with databases using ORM techniques.

In summary:

- **.NET** is a broad platform with tools, runtime, and libraries.
    
- **Frameworks** are focused tools built on top of the platform, essentially structured libraries designed for specific tasks.
# Bookmarks
[ASP.NET documentation | Microsoft Learn](https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-9.0)

Completion: 14.04.2025