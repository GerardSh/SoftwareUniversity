# General
## Internet
Интернет е обширна мрежа, която свързва милиарди устройства по целия свят.  

Свързаността се осъществява чрез оптични влакна, медни кабели, сателити или мобилни мрежи.  

Получаваме достъп до интернет индиректно – чрез доставчици на интернет услуги (ISP – Internet Service Providers). ISP доставчика поддържа собствени мрежи, чрез които осигурява достъп до глобалната комуникационна среда и връзка с останалите мрежи. Тези мрежи могат да бъдат свързани с по-големи доставчици (upstream providers) или с интернет обменни точки (IXPs), където се осъществява обмен на трафик между различни мрежи. В крайна сметка интернет представлява мрежа от взаимно свързани доставчици на различни нива.
## History
Началото на интернет започва с развитието на електронните компютри през 50-те години.

През края на 60-те години се разработват мрежи с пакетно предаване на данни (packet switching).

През 70-те години се създава интернет протоколът (IP), който позволява комуникация между различни мрежи.

През 80-те години в CERN Тим Бърнърс-Лий създава World Wide Web – първият уебсайт, който свързва хипертекстови документи в информационна система, достъпна от всяка точка в мрежата.
## Networks and Internet
Мрежа означава група от две или повече устройства, които могат да комуникират помежду си.

Състои се от различни компютърни системи, свързани чрез физически и/или безжични връзки.

Мащабът може да варира – от един компютър, който споделя базови периферни устройства, до огромни центрове за данни, разположени по целия свят, чак до самия интернет.

Интернет се състои от стотици хиляди мрежи и милиарди компютри и устройства, свързани физически.

Тези различни системи се свързват помежду си, комуникират и работят заедно благодарение на стандарти, които определят как се предават данните.
### RFC (Request for Comments)
В началото, когато мрежите са били ограничени основно до университетите, някой измисля идея как да подобри комуникацията между тях. Знае, че идеята му е добра, но за да разбере дали ще е полезна и за останалите, изпраща писмо, в чийто subject записва **RFC** – _Request for Comments_ (заявка за коментари).

С това писмо той споделя идеята си с други специалисти и ги приканва да дадат мнение – дали предложението е удачно, как може да се подобри и коя би била най-добрата реализация.

Останалите започват да отговарят и чрез тази колаборация се стига до създаване на стандарт, който впоследствие се прилага в системите, позволявайки им да комуникират ефективно.

С течение на времето тези документи започват да се **номерират** (RFC 1, RFC 2, ...), и някои от тях се превръщат в **официални интернет стандарти** – например протоколите TCP/IP, HTTP, SMTP и други с което поставят основата на процеса по стандартизиране на обмена на данни между всички свързани мрежи.
## Web Server Work Model
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250406172959.png)

**Important Definitions**

За да разберем как работи интернетът, първо трябва да се запознаем с няколко основни определения:

- Server and Client
- Network Protocol
- Packets
- TCP vs UDP
### Servers and Clients
Имаме две основни роли – **Web Client** и **Web Server**. Сървърите предоставят услуги и ресурси, докато клиента дава възможност на потребител или друга машина да достъпи тези ресурси. Клиентите консумират тези ресурси. Когато говорим за клиент и за сървър, трябва да имаме предвид, че тези роли не се ограничават до конкретни устройства и могат да бъдат изпълнявани от всякакви видове устройства. Едно устройство може да изпълнява и двете роли. Например, в един случай, компютърът може да бъде **клиент**, когато изпраща заявка за достъп до уеб страница, а същият компютър може да бъде и **сървър**, когато хоства сайт и предоставя ресурси на други устройства. Това означава, че ролите на клиент и сървър са динамични и зависими от контекста на комуникацията.

Клиентът, чрез определена технология, консумира ресурси, предоставяни от сървъра. За да може сървърът да осигури тези ресурси, той също трябва да разполага с технология. В нашия случай тази технология е **ASP.NET**, която дава възможност на сървъра да предоставя уеб услуги, като обработва HTTP заявки и връща отговори, например уеб страници или данни от база данни.

Така, в основата си, ролята на сървъра е да предоставя ресурсите, а ролята на клиента е да ги консумира. Технологиите, като **ASP.NET**, играят ключова роля в осигуряването на тези възможности.

Моделът на работа в интернет винаги е **на заявка и отговор**. Това означава, че всяка комуникация между клиент и сървър се осъществява чрез **системата на заявки (requests)** и **отговори (responses)**.

1. **Заявка (Request)**: Клиентът (например, уеб браузър или приложение) изпраща заявка към сървъра, който съдържа информация за това какъв ресурс или услуга се иска. Заявката може да съдържа различни данни като метод на заявка (например **GET** или **POST**), адрес на ресурса (URL), заглавия, параметри и понякога тя може да включва и тяло (body), в зависимост от типа на заявката.
    
2. **Отговор (Response)**: След като сървърът получи заявката, той я обработва и връща отговор към клиента. Отговорът съдържа информация за изпълнението на заявката, като статусен код (например 200 за успешен отговор или 404 за не намерена страница), заглавия (headers) и самия ресурс (например HTML страница, JSON данни или изображение), който е поискан.

Този модел на комуникация е основополагащ за интернет услугите и уеб приложенията. Чрез него се осигурява обменът на информация между различни системи и устройства по целия свят.
### Network Protocol
Набор от правила и стандарти, които позволяват комуникация между мрежови устройства.  

Мрежовите протоколи включват механизми, които позволяват на устройствата да се идентифицират и да осъществяват връзки помежду си.  

Примери за стандартни мрежови протоколи:  

TCP, QUIC, UDP, IP, ARP  

HTTP, FTP, TFTP, SFTP, SMTP, SSH

Примерно, всеки един език може да се разглежда като различен протокол. Днес може да говорим с някого на български, а с друг на английски, тоест използваме подходящия протокол, за да се свържем с другата страна в комуникацията. Мрежовите протоколи работят по сходен начин – те са различни и обикновено устройствата познават множество мрежови протоколи. Когато трябва да комуникират помежду си, те се разбират кой протокол да използват.

Понякога тази уговорка за протокол се осъществява автоматично между устройствата, а в други случаи потребителят може да избере кой протокол да се използва, знаейки, че устройството от другата страна поддържа този протокол. Например, ако компютърът на едната страна поддържа HTTP, а този на другата – HTTPS, тогава може да бъде уговорено дали да се използва защитената версия на протокола за по-сигурна комуникация.
### Packets
Всичко, което се създава на компютър, се превежда в цифрови данни, използвайки битове. Битовете трябва да имат начин да бъдат предавани през интернет.

Всяко съобщение, файл или поток от данни се разделя на малки части, наречени пакети. Рутерите отговарят за определянето на маршрута, по който тези пакети преминават през мрежата, за да стигнат до крайната си дестинация.

Когато пакетите се изпращат през интернет, обикновено пътуват през мрежата заедно. Понякога обаче може да се наложи да поемат различен маршрут, за да стигнат до крайната цел, като последните пакети могат да пристигнат преди първите. Затова е важно да се следи не само дали всички пакети са пристигнали и не са повредени, но и дали са получени в правилния ред. Ако даден пакет се загуби или повреди, се изпраща нов пакет.

Всеки пакет съдържа важна информация вътре в себе си, наречена хедър (header). Тази информация включва:

- Откъде е изпратен пакетът, кой е изпращачът. 
- На къде е насочен, кой е получателят.
- Колко е общата дължина на пакета в байтове, включително данните и header-а. Тази информация е важна за получателя, защото му позволява да определи дали е получил целия пакет или трябва да поиска нов. Всеки пакет съдържа информация за общия брой пакети, които трябва да пристигнат, както и за поредността, в която е изпратен. Това помага на получателя да събере пакетите в правилния ред и да идентифицира липсващи или повредени пакети.
- Как се проверява дали пакетът е цял.

 Всички пакети в съобщението са с еднакъв размер и съдържат информация за това колко пакета има в общото съобщение.
### Internet Protocol
Един от най-важните протоколи, използвани в интернет комуникацията, е Интернет протоколът (IP).

Всички устройства в интернет имат адреси и се наричат IP адреси.
### IP Address
Рутерите рутират пакетите по различни маршрути в зависимост от текущото състояние на мрежата. По същия начин, както когато използваме Google Maps – той ни насочва по най-подходящия път спрямо моментната натовареност и състоянието на пътната инфраструктура. 
За да може да се случи каквато и да било маршурутизация трябва да имаме адрес, да знаем от къде тръгваме и къде искаме да отидем. Всяко едно устройство в интернет има адрес, благодарение на интернет протокола. Адресите трябва да са уникални в рамките на мрежата в която се намират устройствата. Примерно може да имаме еднакви адреси, но в различни градове. Така е и при IP адресите, една от частите в номера, дефинира главната мрежа, към която трябва да бъде пратен пакета.

IP адресът има няколко части, организирани йерархично – част от него идентифицира мрежата (или подсистемата), а друга част – конкретното устройство в нея.

Пример:

**192.168.14.120** – тази версия на адресацията се нарича IPv4. В класическия случай числото **14** определя подмрежата (subnetwork), а **120** е адресът на конкретното устройство. Частта **192.168** можем да оприличим на града, в който се намираме – тя определя по-широката мрежова област.

IPv4 използва 32-битови адреси, разделени на 4 части, което позволява над 4 милиарда уникални IP адреса (по-точно 2³² = 4 294 967 296). Форматът представлява поредица от четири числа, разделени с точка.

Всяко от тези числа може да бъде в диапазона от 0 до 255.

IPv4 адресите вече не са достатъчни за всички устройства, свързани с интернет.  
Затова през 1995 г. е създадена нова версия на интернет протокола – наречена IPv6.
### IP Address Classes
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250406172522.png)

Използвайки тази класификация, IP адресите се разпределят неравномерно. На определени организации се предоставят повече адреси, отколкото реално могат да използват. Този механизъм не е достатъчно гъвкав и води до бързо изчерпване на наличните адреси.

Първоначално е създаден новият протокол IPv6, но впоследствие е въведена и оптимизация на съществуващия IPv4, за да стане по-гъвкав. Тази оптимизация води до създаването на CIDR (Classless Inter-Domain Routing).
#### CIDR (Classless Inter-Domain Routing)
```
| CIDR Range             | IP Address Range                | Class |
|------------------------|---------------------------------|-------|
| 10.0.0.0/8             | 10.0.0.0 – 10.255.255.255       | A     |
| 172.16.0.0/12          | 172.16.0.0 – 172.31.255.255     | B     |
| 192.168.0.0/16         | 192.168.0.0 – 192.168.255.255   | C     |
```

CIDR е схема за IP адресиране, която подобрява начина, по който се разпределят IP адресите.

Тя заменя стария класов модел, базиран на класове A, B и C.

Тази схема значително удължава живота на IPv4 и забавя нарастването на таблиците за маршурутизация.

Освен това, компаниите често използват **gateway** устройства, за да оптимизират използването на IP адреси. Например, една фирма с 600 компютъра не е нужно да има 600 публични IP адреса. Всички устройства в локалната мрежа използват **вътрешни (private)** IP адреси и изпращат заявките си към **gateway** (рутер). Gateway-ят има един публичен IP адрес, с който достъпва външни ресурси (като уебсайтове). След като получи отговора, той знае на кое вътрешно устройство да го върне. Този механизъм се нарича **NAT (Network Address Translation)** и позволява споделянето на един публичен адрес между много устройства.

CIDR ни позволява след IP адреса на мрежата да добавим едно допълнително число – това число е **битова маска**, която показва **колко от битовете са заделени за мрежовата част на адреса**. Така можем да определим **колко голяма е мрежата** и **колко устройства могат да бъдат адресирани в нея**.

С тази схема можем **гъвкаво да регулираме** коя част от IP адреса се отнася за мрежата и коя – за устройствата (хостовете) в нея. Това прави разпределението на адресите **по-ефективно**, отколкото при старите класове (A, B, C).

За да се избегне объркване, **IP адресите и мрежовите маски се разбират най-добре, когато се разглеждат в двоична форма**, защото така ясно се вижда кои битове са част от мрежата и кои – от устройствата.

**Важно уточнение:** Ако в даден октет (група от 8 бита) има **смесване на битове за мрежата и за хостовете**, в **десетична форма нещата изглеждат по-сложни**. Причината е, че това десетично число се променя **в зависимост от различните комбинации**, които се получават от променящите се битове за устройствата. Така едни и същи първи битове (за мрежа) могат да дадат различни десетични стойности в зависимост от това какви стойности имат останалите битове (за хост).
**Битовете, заделени за мрежата, не се променят** – те са фиксирани и еднакви за всички устройства в една и съща мрежа. **Разликата в десетичната стойност идва от битовете, предназначени за хостовете (устройствата)**. Те се променят, за да дадат уникален адрес на всяко устройство в мрежата.

>[!IMPORTANT]
>IP адресите се разбират най-лесно, когато се разглеждат в **двоичен вид** – там ясно личи коя част е фиксирана (мрежата) и коя варира (устройствата).
### IPv6
**IPv6 използва 128 бита – което позволява около 340 ундецилиона уникални адреса**. Това е повече от броя на атомите на повърхността на Земята.

Тези 128 бита са организирани в **осем 16-битови секции**.

Всяка секция се **преобразува в шестнадесетична бройна система** и се разделя с двоеточие (`:`)

Пример за пълен IPv6 адрес:  `3FFE:F200:0234:AB00:0123:4567:8901:ABCD`

**Водещите нули** във всяка секция обикновено могат да се пропускат (въпреки че това не винаги се препоръчва, за да се избегне объркване).
### DNS (Domain Name System)
Домейн името е **удобен за хора начин** да достъпваме IP адреси на устройства и уебсайтове по целия свят.

То представлява **последователност от фрази**, които се свързват с огромна интернет-база данни от IP адреси.

Когато въведем домейн в браузъра (напр. `google.com`), се изпраща заявка към **DNS** (Domain Name System).

Този сървър държи **кеш (временна памет)** с множество домейн имена и съответстващите им IP адреси.
### TCP (Transmission Control Protocol)
Пакетите се изпращат от едно място на друго и могат да преминат през различни пътища. Когато достигнат до дестинацията, може да бъдат неорганизирани или непълни. Затова съобщението трябва да бъде проверено и възстановено, за да се подреди правилно.
**TCP** е протоколът, който осигурява точно този процес, като гарантира, че пакетите са правилно подредени и пълни преди да формират оригиналното съобщение.

TCP използва процес, при който разглежда всички пакети в съобщението и ги проверява.
Използвайки информацията в хедъра на всеки пакет, той знае:

- Колко пакета има.
- Колко трябва да бъдат големи.
- В какъв ред трябва да бъдат пакетите.

С помощта на този списък за проверка, може да подреди пакетите в правилния ред.
Ако открие, че даден пакет не съвпада с очакваните характеристики, той се изхвърля.
След това потвърждава данните и пакетите се обединяват, за да възстановят оригиналния файл, който е бил на устройството на изпращача.
### UDP (User Datagram Protocol)
UDP не установява сесия и не гарантира доставката на данни. Той е известен като "fire-and-forget" протокол. Изпраща данни и не се интересува дали те ще бъдат получени на другия край, самият протокол не се опитва да оправи грешките.
Има случаи, в които това е много полезно, защото търсим бързодействие, а не сигурност, че задачата е изпълнена.

Чисто програмно може да имаме проверка и да реагираме, когато има проблем. В TCP това е вградено в протокола и е задължително, следвайки определен алгоритъм, докато при UDP имаме избор дали да направим проверка по наш алгоритъм.
### TCP vs UDP
TCP поставя надеждността на по-висок приоритет отколкото скоростта или латентността.

В случаи, когато надеждността не е толкова важна, но скоростта е, се използва UDP.

UDP не извършва прекомерни проверки за надеждност, но може да изпраща информация с по-висока скорост.

TCP е основата на това как голяма част от данните се предават през мрежите. HTTP/1 и HTTP/2 използват TCP, но от версия 3, излязла преди няколко години, това се променя.
HTTP/3 е базиран на новия протокол **QUIC (Quick UDP Internet Connections)**, който използва UDP вместо TCP, за да предложи по-бързо установяване на връзка и подобрена производителност, особено при висока латентност и загуба на пакети. Тенденцията е да се използва все повече UDP.

HTTP/2 използва мултиплексинг на връзките, което означава, че може да създаде една връзка и да изпрати няколко отделни потока от данни през нея. Това значително увеличава скоростта в сравнение с HTTP/1, където за всеки JS или CSS файл трябва да се отваря отделна връзка. Например, за 10 JS файла, се изискват 10 различни връзки. HTTP/2 разрешава този проблем чрез мултиплексинга, но използва TCP, което води до ново предизвикателство – ако някой от тези потоци загуби пакет, всички останали потоци могат да бъдат блокирани, докато не се извърши корекция на загубения пакет. Причината за това е, че контролът на пакетите се извършва на ниво цяла връзка, което блокира успешните предавания, ако някои потоци не са успешни.

При HTTP/3 се запазва предимството на мултиплексинга, като разработчиците не е необходимо да събират всички файлове в един. Това означава, че изпращането на паралелно 20 по-малки файла ще бъде много по-бързо от изпращането на един голям файл. Освен това, HTTP/3 позволява паралелни потоци, без да блокира всички при загуба на пакет, както се случва при HTTP/2. 

Изборът да се използва UDP вместо TCP е свързан с решаването на проблемите с връзките. Ако този проблем трябваше да се реши в TCP, това би изисквало значителни промени в самия протокол, което би отнело години обсъждания и внедряване, тъй като TCP е вграден в основите на всички операционни системи. Затова е решено да се използва UDP.
#### QUICK
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250408170527.png)

За да се запази надеждността (reliability), е добавена допълнителна проверка – QUICK, която се фокусира само върху конкретните потоци. Тъй като QUICK е нов и оптимизиран, той е значително по-бърз в сравнение с TCP, който е разработен преди много години. QUICK успява да поддържа надеждността на TCP, но постига по-висока скорост благодарение на UDP и бързите проверки.
Освен това, тези проверки са изнесени извън основния протокол. Ако се наложи бъдеща промяна в начина на проверка, тя може да бъде лесно имплементирана, като се промени само QUICK, без да е необходимо да се засягат основните протоколи в операционната система.
QUICK работи само с secure connection, като всеки пакет се енкриптва индивидуално, като използва **индивидуално криптиране** за всеки пакет. Това означава, че всяко предаване на данни през **QUICK** е криптирано, което осигурява високо ниво на защита и конфиденциалност.
## The OSI Model
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250408172058.png)

Моделът **OSI** означава **Open Systems Interconnection**. Това е концептуална рамка, която стандартизира функциите на комуникационната система в седем различни слоя. Всеки слой изпълнява специфични задачи и взаимодейства с слоевете, разположени директно над и под него. С други думи, този модел обяснява какво е необходимо, за да осъществим връзка между две приложения, например когато нашият браузър отваря дадено уеб приложение. За тази комуникация са необходими 7 слоя, като всеки слой обслужва горния и е обслужен от долния.

Ключови точки:

- **7 слоя**: Моделът OSI се състои от седем слоя, като всеки има своята функция.

- **Взаимодействие между слоевете**: Всеки слой обслужва слоя, разположен над него, и в замяна е обслужван от слоя под него, създавайки структура за комуникация.

- **Практически ползи**:

    - Помага при **отстраняване на проблеми** с мрежи, като изолира проблемите в конкретни слоеве.
    - Подобрява **комуникацията** между технически и нетехнически лица, като предоставя ясна структура за описване на начина, по който данни преминават през мрежата.

Чрез разбирането на модела OSI става по-лесно да разберем как комуникират системите и да открием проблеми в мрежовата комуникация.
### Application Layer 7
Това е единственият слой, който взаимодействат директно с потребителя. Софтуерни приложения, като уеб браузъри и имейл клиенти, разчитат директно на протоколите на този слой.

Протоколни примери са: DNS, FTP, HTTP, SMTP, POP3, IMAP.

Този слой е най-важният за софтуерни инженери, тъй като включва реалната комуникация между софтуерните приложения.
### Presentation Layer 6
Този слой е част от операционната система (OS). Той преобразува входящи и изходящи данни от един формат на представяне в друг.

Отговорен е за превод, криптиране и компресиране на данни.

Протоколни примери са: SSL, TLS.
### Session Layer 5
Този слой контролира диалозите (връзките) между компютрите.

Той установява, управлява и прекратява връзки между локалното и отдалеченото приложение.

Услугите му включват автентикация и възстановяване на връзката след прекъсване.

Протоколни примери са: RPC, PPTP.
### Transport Layer 4
Този слой е отговорен за комуникацията от край до край в мрежата.

Той прехвърля данни, като ги разделя на парчета (сегменти).

Осигурява логическа комуникация между процесите на приложенията.

Отговорен е за управлението на корекцията на грешки, осигурявайки качество и надеждност за крайния потребител.

Важна концепция за разработчиците на уеб приложения – порт номер. Tой осигурява уникално идентифициране на конкретни услуги или приложения, които работят на същата машина. Тъй като един и същи IP адрес може да бъде използван за множество връзки, портовете помагат да се различават тези връзки, така че данните да се изпратят към правилното приложение. Без портове различните приложения и услуги биха си пречели, като не биха могли да работят паралелно върху една и съща мрежова връзка.

Протоколни примери са: TCP, QUIC, UDP.
### Network Layer 3
Отговаря за прехвърлянето на пакети от възел към възел.  

Той отговаря на искания за услуги от транспортния слой и изпраща искания за услуги към слоя за връзка с данни. 

Протоколни примери: IP, IPv6, IPSec, ICMP, IGMP.

Важна концепция за уеб разработчици – IP адрес.

Този слой е отговорен за маршрутизацията на данни между различни мрежови устройства, като гарантира, че пакетите ще стигнат до правилния адрес. IP адресите са важни, защото идентифицират конкретни устройства в мрежата и определят маршрута за тяхното комуникиране.
### Data Link Layer 2
Предоставя прехвърляне на данни от възел до възел.  
Данните, които се прехвърлят, се разделят на пакети – рамки.  
Този слой открива и, ако е възможно, коригира грешки, които могат да възникнат в физическия слой.  
Разделя се на два подслоя:

- **Medium Access Control (MAC) слой** – контролира как устройствата в мрежата получават достъп до медията и разрешение за изпращане на данни.

- **Logical Link Control (LLC) слой** – идентифицира и инкапсулира протоколи на мрежовия слой, контролира проверката за грешки и синхронизация на рамките.

Протоколни примери: ATM, Ethernet, MAC.

Този слой е отговорен за контрола върху физическата комуникация между устройствата и осигурява надеждност и корекция на грешки на ниво връзка.
### Physical Layer 1
Отговаря за физическата връзка между две или повече устройства.  
Преобразува двоичната информация от горните слоеве в сигнали и ги предава през локалната медия – чрез електрически, светлинни или радио сигнали.

Примери за технологии на този слой са: Ethernet, USB, Bluetooth и 802.11a/b/g/n (Wi-Fi).

Това е най-ниският слой в OSI модела и се грижи за реалното пренасяне на битовете през физическата среда.
## TCP/IP Protocol Suite
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250408181624.png)

7-слойният OSI модел е твърде сложен и е създаден основно за мрежови инженери и експерти по комуникации.

В софтуерната разработка се използва по-опростен мрежов модел, наречен **TCP/IP protocol suite**, който има **4 слоя**:

**Link слой** обединява физическата среда и протоколите на канала за предаване на данни.

**Internet слой** се грижи за изпращането на пакети между два хоста.

**Transport слой** осигурява комуникация между две крайни точки.

**Application слой** определя начина, по който приложенията обменят информация помежду си.
## Network Hardware
Основни хардуерни компоненти в мрежата:

- Кабели.
- Рутери.
- Репитъри, хъбове и суичове.
- Мрежови мостове (Bridges).
- Шлюзове (Gateways).
- Мрежови интерфейсни карти (NIC).
### Cables and Routers
Мрежовите кабели са средата за пренос на данни между устройства. Те служат за физическото предаване на информация от едно устройство към друго.

Рутерът е свързващо устройство, което прехвърля пакети с данни между различни компютърни мрежи. Той работи на ниво 3 от OSI модела – мрежовото ниво – и има за задача да избира най-добрия маршрут за предаване на данните към техния краен получател.
### Repeaters, Hubs and Switches
Репитъри, хъбове и суичове свързват мрежови устройства, така че да функционират като единен сегмент.

Репитърът получава сигнал, усилва го и го препредава, което позволява пренос на данни на по-големи разстояния.

Хъбът е многопортов репитър и работи на ниво 1 от OSI модела. Той препраща данните към всички устройства в мрежата, без да ги насочва.

Суичът работи на ниво 2 от OSI модела и използва packet switching. Той получава данни от конкретен порт, определя предназначението на пакета и го изпраща само към устройството, за което е предназначен.
### Bridges and Gateways
**Bridge**

Бриджът свързва два отделни, но сходни Ethernet мрежови сегмента. Той препраща пакети от изходната мрежа към целевата мрежа и работи на ниво 2 от OSI модела.

**Gateway**

Гейтуеят е устройство или софтуерен компонент, свързващ мрежи, които използват различни протоколи. Действа като **преводач** между тях и е входната и изходната точка на мрежата и контролира достъпа до други мрежи. Може да оперира на ниво 4, 5, 6 или 7 от OSI модела — също както и защитните стени (firewalls).
Например, домашният рутер играе ролята на gateway, когато свързва вътрешната LAN мрежа с външния интернет. С други думи, gateway е **вратата между две мрежи** – особено когато тези мрежи "говорят на различни езици".
### Network Interface Cards – NIC
**NIC (Network Interface Card)** – това е компонент на компютъра, който го свързва с мрежа.  
Съществуват два основни вида мрежови карти:

- Вътрешни – инсталирани директно в дънната платка чрез слот (например PCIe).
- Външни – свързват се чрез външен порт като USB и се използват при нужда от допълнителен интерфейс или подмяна.
## The Future of the Internet
Едно типично съвременно домакинство включва устройства като: компютър, лаптоп, таблет, телефони, телевизор, охранителна камера, климатик, смарт часовник, принтер, музикална система, осветление и други.

Интернет на нещата - IoT (Internet of Things) ще се разширява все повече.  
Ще намира приложение в здравеопазването, земеделието, производството, както и в умни домове, автомобили и градове (например за мониторинг на замърсяване, паркиране и енергийна ефективност).

Очаква се през 2030 г. да има 50 милиарда устройства, свързани към Интернет на нещата.
# ChatGPT
## Understanding Confusion in IP Addressing with Subnet Masks
When working with IP addresses and subnet masks, things often seem clear in **binary form**, because you can easily see which bits belong to the **network** and which are used for **host devices**.

However, confusion arises when converting these addresses into **decimal form**, especially when using subnet masks that **don't align with full octets** (like `/10`, `/13`, etc.). That's because bits for the **network** and the **host** can be **mixed within the same decimal octet**.

For example:

- IP address: `10.10.0.1` → Binary: `00001010.00001010.00000000.00000001`

- Subnet mask: `/10` → Binary: `11111111.11000000.00000000.00000000`

Here:

- The **first 10 bits** define the **network**

- The remaining **22 bits** define the **host/device**

In binary, this separation is easy to understand.  
But in decimal (like `10.10.0.1`), you can't visually tell which part belongs to the network and which to the host, because **bits from both may combine into a single decimal number**.

**🔸 Key Takeaway:**

Always refer to the **binary representation** to understand how IP addresses are divided between **network** and **host** parts. Decimal form is just a human-readable version, but it can obscure that division.
## Understanding the Difference Between TCP and UDP
When transmitting data over a network, two major transport protocols are used: **TCP** and **UDP**. They serve similar purposes but work in very different ways, depending on the priorities of the communication—**reliability vs speed**.

**TCP: Focused on Reliability**

**TCP (Transmission Control Protocol)** is a **connection-oriented** protocol. This means that before data is sent, TCP first establishes a reliable connection using a **handshake process**.

TCP ensures:

- All packets arrive
- Packets are in the correct order
- Data is complete and error-checked

TCP does this by using sequence numbers, acknowledgments, and retransmissions when needed.

Because of this, TCP is:

- **Slower**, due to the overhead of checking and confirming packets

- **Reliable**, making it ideal for applications like:

    - Web traffic (HTTP/HTTPS)
    - File transfers (FTP)
    - Email (SMTP, IMAP)

**UDP: Focused on Speed**

**UDP (User Datagram Protocol)** is a **connectionless** protocol. It simply sends packets to the destination **without checking** if they arrive or are complete.

UDP:

- Doesn't guarantee delivery
- Doesn’t check for errors
- Doesn’t order packets

This makes UDP:

- Much faster, since there’s no overhead
- Less reliable, but ideal when speed is more important than accuracy

Common use cases include:

- Video and voice calls
- Online gaming
- Streaming
- DNS lookups

**Summary**

|Feature|TCP|UDP|
|---|---|---|
|Connection|Connection-oriented|Connectionless|
|Reliability|Guarantees delivery and order|No guarantees|
|Speed|Slower (more overhead)|Faster (minimal overhead)|
|Use Cases|Web, FTP, Email|Streaming, Games, VoIP|

> 💡 Newer protocols like **HTTP/3** use **UDP**, combining speed with reliability using higher-layer logic.
# Bookmarks
Completion: 08.04.2025