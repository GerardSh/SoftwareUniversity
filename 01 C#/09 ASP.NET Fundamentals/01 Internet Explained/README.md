# General
## Internet
Интернет е обширна мрежа, която свързва милиарди устройства по целия свят.  

Свързаността се осъществява чрез оптични влакна, медни кабели, сателити или мобилни мрежи.  

Получаваме достъп до интернет индиректно – чрез доставчици на интернет услуги (ISP – Internet Service Providers). ISP доставчика поддържа собствени мрежи, чрез които осигурява достъп до глобалната комуникационна среда и връзка с останалите мрежи. Тези мрежи могат да бъдат свързани с по-големи доставчици (upstream providers) или с интернет обменни точки (IXPs), където се осъществява обмен на трафик между различни мрежи. В крайна сметка интернет представлява мрежа от взаимно свързани доставчици на различни нива.
## History
Началото на интернет започва с развитието на електронните компютри през 50-те години.

През края на 60-те години се разработват мрежи с пакетно предаване на данни (packet switching).

През 70-те години се създава интернет протоколът (IP), който позволява комуникация между различни мрежи.

През 80-те години в CERN Тим Бърнърс-Лий създава World Wide Web – първият уебсайт, който свързва хипертекстови документи в информационна система, достъпна от всяка точка в мрежата.
## Networks and Internet
Мрежа означава група от две или повече устройства, които могат да комуникират помежду си.

Състои се от различни компютърни системи, свързани чрез физически и/или безжични връзки.

Мащабът може да варира – от един компютър, който споделя базови периферни устройства, до огромни центрове за данни, разположени по целия свят, чак до самия интернет.

Интернет се състои от стотици хиляди мрежи и милиарди компютри и устройства, свързани физически.

Тези различни системи се свързват помежду си, комуникират и работят заедно благодарение на стандарти, които определят как се предават данните.
### RFC (Request for Comments)
В началото, когато мрежите са били ограничени основно до университетите, някой измисля идея как да подобри комуникацията между тях. Знае, че идеята му е добра, но за да разбере дали ще е полезна и за останалите, изпраща писмо, в чийто subject записва **RFC** – _Request for Comments_ (заявка за коментари).

С това писмо той споделя идеята си с други специалисти и ги приканва да дадат мнение – дали предложението е удачно, как може да се подобри и коя би била най-добрата реализация.

Останалите започват да отговарят и чрез тази колаборация се стига до създаване на стандарт, който впоследствие се прилага в системите, позволявайки им да комуникират ефективно.

С течение на времето тези документи започват да се **номерират** (RFC 1, RFC 2, ...), и някои от тях се превръщат в **официални интернет стандарти** – например протоколите TCP/IP, HTTP, SMTP и други с което поставят основата на процеса по стандартизиране на обмена на данни между всички свързани мрежи.
## Web Server Work Model
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250406172959.png)

**Important Definitions**

За да разберем как работи интернетът, първо трябва да се запознаем с няколко основни определения:

- Server and Client
- Network Protocol
- Packets
- TCP vs UDP
### Servers and Clients
Имаме две основни роли – **Web Client** и **Web Server**. Сървърите предоставят услуги и ресурси, докато клиента дава възможност на потребител или друга машина да достъпи тези ресурси. Клиентите консумират тези ресурси. Когато говорим за клиент и за сървър, трябва да имаме предвид, че тези роли не се ограничават до конкретни устройства и могат да бъдат изпълнявани от всякакви видове устройства. Едно устройство може да изпълнява и двете роли. Например, в един случай, компютърът може да бъде **клиент**, когато изпраща заявка за достъп до уеб страница, а същият компютър може да бъде и **сървър**, когато хоства сайт и предоставя ресурси на други устройства. Това означава, че ролите на клиент и сървър са динамични и зависими от контекста на комуникацията.

Клиентът, чрез определена технология, консумира ресурси, предоставяни от сървъра. За да може сървърът да осигури тези ресурси, той също трябва да разполага с технология. В нашия случай тази технология е **ASP.NET**, която дава възможност на сървъра да предоставя уеб услуги, като обработва HTTP заявки и връща отговори, например уеб страници или данни от база данни.

Така, в основата си, ролята на сървъра е да предоставя ресурсите, а ролята на клиента е да ги консумира. Технологиите, като **ASP.NET**, играят ключова роля в осигуряването на тези възможности.

Моделът на работа в интернет винаги е **на заявка и отговор**. Това означава, че всяка комуникация между клиент и сървър се осъществява чрез **системата на заявки (requests)** и **отговори (responses)**.

1. **Заявка (Request)**: Клиентът (например, уеб браузър или приложение) изпраща заявка към сървъра, който съдържа информация за това какъв ресурс или услуга се иска. Заявката може да съдържа различни данни като метод на заявка (например **GET** или **POST**), адрес на ресурса (URL), заглавия, параметри и понякога тя може да включва и тяло (body), в зависимост от типа на заявката.
    
2. **Отговор (Response)**: След като сървърът получи заявката, той я обработва и връща отговор към клиента. Отговорът съдържа информация за изпълнението на заявката, като статусен код (например 200 за успешен отговор или 404 за не намерена страница), заглавия (headers) и самия ресурс (например HTML страница, JSON данни или изображение), който е поискан.

Този модел на комуникация е основополагащ за интернет услугите и уеб приложенията. Чрез него се осигурява обменът на информация между различни системи и устройства по целия свят.
### Network Protocol
Набор от правила и стандарти, които позволяват комуникация между мрежови устройства.  

Мрежовите протоколи включват механизми, които позволяват на устройствата да се идентифицират и да осъществяват връзки помежду си.  

Примери за стандартни мрежови протоколи:  

TCP, QUIC, UDP, IP, ARP  

HTTP, FTP, TFTP, SFTP, SMTP, SSH

Примерно, всеки един език може да се разглежда като различен протокол. Днес може да говорим с някого на български, а с друг на английски, тоест използваме подходящия протокол, за да се свържем с другата страна в комуникацията. Мрежовите протоколи работят по сходен начин – те са различни и обикновено устройствата познават множество мрежови протоколи. Когато трябва да комуникират помежду си, те се разбират кой протокол да използват.

Понякога тази уговорка за протокол се осъществява автоматично между устройствата, а в други случаи потребителят може да избере кой протокол да се използва, знаейки, че устройството от другата страна поддържа този протокол. Например, ако компютърът на едната страна поддържа HTTP, а този на другата – HTTPS, тогава може да бъде уговорено дали да се използва защитената версия на протокола за по-сигурна комуникация.
### Packets
Всичко, което се създава на компютър, се превежда в цифрови данни, използвайки битове. Битовете трябва да имат начин да бъдат предавани през интернет.

Всяко съобщение, файл или поток от данни се разделя на малки части, наречени пакети. Рутерите отговарят за определянето на маршрута, по който тези пакети преминават през мрежата, за да стигнат до крайната си дестинация.

Когато пакетите се изпращат през интернет, обикновено пътуват през мрежата заедно. Понякога обаче може да се наложи да поемат различен маршрут, за да стигнат до крайната цел, като последните пакети могат да пристигнат преди първите. Затова е важно да се следи не само дали всички пакети са пристигнали и не са повредени, но и дали са получени в правилния ред. Ако даден пакет се загуби или повреди, се изпраща нов пакет.

Всеки пакет съдържа важна информация вътре в себе си, наречена хедър (header). Тази информация включва:

- Откъде е изпратен пакетът, кой е изпращачът. 
- На къде е насочен, кой е получателят.
- Колко е общата дължина на пакета в байтове, включително данните и header-а. Тази информация е важна за получателя, защото му позволява да определи дали е получил целия пакет или трябва да поиска нов. Всеки пакет съдържа информация за общия брой пакети, които трябва да пристигнат, както и за поредността, в която е изпратен. Това помага на получателя да събере пакетите в правилния ред и да идентифицира липсващи или повредени пакети.
- Как се проверява дали пакетът е цял.

 Всички пакети в съобщението са с еднакъв размер и съдържат информация за това колко пакета има в общото съобщение.
### Internet Protocol
Един от най-важните протоколи, използвани в интернет комуникацията, е Интернет протоколът (IP).

Всички устройства в интернет имат адреси и се наричат IP адреси.
### IP Address
Рутерите рутират пакетите по различни маршрути в зависимост от текущото състояние на мрежата. По същия начин, както когато използваме Google Maps – той ни насочва по най-подходящия път спрямо моментната натовареност и състоянието на пътната инфраструктура. 
За да може да се случи каквато и да било маршурутизация трябва да имаме адрес, да знаем от къде тръгваме и къде искаме да отидем. Всяко едно устройство в интернет има адрес, благодарение на интернет протокола. Адресите трябва да са уникални в рамките на мрежата в която се намират устройствата. Примерно може да имаме еднакви адреси, но в различни градове. Така е и при IP адресите, една от частите в номера, дефинира главната мрежа, към която трябва да бъде пратен пакета.

IP адресът има няколко части, организирани йерархично – част от него идентифицира мрежата (или подсистемата), а друга част – конкретното устройство в нея.

Пример:

**192.168.14.120** – тази версия на адресацията се нарича IPv4. В класическия случай числото **14** определя подмрежата (subnetwork), а **120** е адресът на конкретното устройство. Частта **192.168** можем да оприличим на града, в който се намираме – тя определя по-широката мрежова област.

IPv4 използва 32-битови адреси, разделени на 4 части, което позволява над 4 милиарда уникални IP адреса (по-точно 2³² = 4 294 967 296). Форматът представлява поредица от четири числа, разделени с точка.

Всяко от тези числа може да бъде в диапазона от 0 до 255.

IPv4 адресите вече не са достатъчни за всички устройства, свързани с интернет.  
Затова през 1995 г. е създадена нова версия на интернет протокола – наречена IPv6.
### IP Address Classes
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250406172522.png)

Използвайки тази класификация, IP адресите се разпределят неравномерно. На определени организации се предоставят повече адреси, отколкото реално могат да използват. Този механизъм не е достатъчно гъвкав и води до бързо изчерпване на наличните адреси.

Първоначално е създаден новият протокол IPv6, но впоследствие е въведена и оптимизация на съществуващия IPv4, за да стане по-гъвкав. Тази оптимизация води до създаването на CIDR (Classless Inter-Domain Routing).
#### CIDR (Classless Inter-Domain Routing)
```
| CIDR Range             | IP Address Range                | Class |
|------------------------|---------------------------------|-------|
| 10.0.0.0/8             | 10.0.0.0 – 10.255.255.255       | A     |
| 172.16.0.0/12          | 172.16.0.0 – 172.31.255.255     | B     |
| 192.168.0.0/16         | 192.168.0.0 – 192.168.255.255   | C     |
```

CIDR е схема за IP адресиране, която подобрява начина, по който се разпределят IP адресите.

Тя заменя стария класов модел, базиран на класове A, B и C.

Тази схема значително удължава живота на IPv4 и забавя нарастването на таблиците за маршурутизация.

Освен това, компаниите често използват **gateway** устройства, за да оптимизират използването на IP адреси. Например, една фирма с 600 компютъра не е нужно да има 600 публични IP адреса. Всички устройства в локалната мрежа използват **вътрешни (private)** IP адреси и изпращат заявките си към **gateway** (рутер). Gateway-ят има един публичен IP адрес, с който достъпва външни ресурси (като уебсайтове). След като получи отговора, той знае на кое вътрешно устройство да го върне. Този механизъм се нарича **NAT (Network Address Translation)** и позволява споделянето на един публичен адрес между много устройства.

CIDR ни позволява след IP адреса на мрежата да добавим едно допълнително число – това число е **битова маска**, която показва **колко от битовете са заделени за мрежовата част на адреса**. Така можем да определим **колко голяма е мрежата** и **колко устройства могат да бъдат адресирани в нея**.

С тази схема можем **гъвкаво да регулираме** коя част от IP адреса се отнася за мрежата и коя – за устройствата (хостовете) в нея. Това прави разпределението на адресите **по-ефективно**, отколкото при старите класове (A, B, C).

За да се избегне объркване, **IP адресите и мрежовите маски се разбират най-добре, когато се разглеждат в двоична форма**, защото така ясно се вижда кои битове са част от мрежата и кои – от устройствата.

**Важно уточнение:** Ако в даден октет (група от 8 бита) има **смесване на битове за мрежата и за хостовете**, в **десетична форма нещата изглеждат по-сложни**. Причината е, че това десетично число се променя **в зависимост от различните комбинации**, които се получават от променящите се битове за устройствата. Така едни и същи първи битове (за мрежа) могат да дадат различни десетични стойности в зависимост от това какви стойности имат останалите битове (за хост).
**Битовете, заделени за мрежата, не се променят** – те са фиксирани и еднакви за всички устройства в една и съща мрежа. **Разликата в десетичната стойност идва от битовете, предназначени за хостовете (устройствата)**. Те се променят, за да дадат уникален адрес на всяко устройство в мрежата.

>[!IMPORTANT]
>IP адресите се разбират най-лесно, когато се разглеждат в **двоичен вид** – там ясно личи коя част е фиксирана (мрежата) и коя варира (устройствата).
### IPv6
**IPv6 използва 128 бита – което позволява около 340 ундецилиона уникални адреса**. Това е повече от броя на атомите на повърхността на Земята.

Тези 128 бита са организирани в **осем 16-битови секции**.

Всяка секция се **преобразува в шестнадесетична бройна система** и се разделя с двоеточие (`:`)

Пример за пълен IPv6 адрес:  `3FFE:F200:0234:AB00:0123:4567:8901:ABCD`

**Водещите нули** във всяка секция обикновено могат да се пропускат (въпреки че това не винаги се препоръчва, за да се избегне объркване).
### DNS (Domain Name System)
Домейн името е **удобен за хора начин** да достъпваме IP адреси на устройства и уебсайтове по целия свят.

То представлява **последователност от фрази**, които се свързват с огромна интернет-база данни от IP адреси.

Когато въведем домейн в браузъра (напр. `google.com`), се изпраща заявка към **DNS** (Domain Name System).

Този сървър държи **кеш (временна памет)** с множество домейн имена и съответстващите им IP адреси.
### TCP (Transmission Control Protocol)
Пакетите се изпращат от едно място на друго и могат да преминат през различни пътища. Когато достигнат до дестинацията, може да бъдат неорганизирани или непълни. Затова съобщението трябва да бъде проверено и възстановено, за да се подреди правилно.
**TCP** е протоколът, който осигурява точно този процес, като гарантира, че пакетите са правилно подредени и пълни преди да формират оригиналното съобщение.

TCP използва процес, при който разглежда всички пакети в съобщението и ги проверява.
Използвайки информацията в хедъра на всеки пакет, той знае:

- Колко пакета има.
- Колко трябва да бъдат големи.
- В какъв ред трябва да бъдат пакетите.

С помощта на този списък за проверка, може да подреди пакетите в правилния ред.
Ако открие, че даден пакет не съвпада с очакваните характеристики, той се изхвърля.
След това потвърждава данните и пакетите се обединяват, за да възстановят оригиналния файл, който е бил на устройството на изпращача.
### UDP (User Datagram Protocol)
UDP не установява сесия и не гарантира доставката на данни. Той е известен като "fire-and-forget" протокол. Изпраща данни и не се интересува дали те ще бъдат получени на другия край, самият протокол не се опитва да оправи грешките.
Има случаи, в които това е много полезно, защото търсим бързодействие, а не сигурност, че задачата е изпълнена.

Чисто програмно може да имаме проверка и да реагираме, когато има проблем. В TCP това е вградено в протокола и е задължително, следвайки определен алгоритъм, докато при UDP имаме избор дали да направим проверка по наш алгоритъм.
## TCP vs UDP
TCP поставя надеждността на по-висок приоритет отколкото скоростта или латентността.

В случаи, когато надеждността не е толкова важна, но скоростта е, се използва UDP.

UDP не извършва прекомерни проверки за надеждност, но може да изпраща информация с по-висока скорост.

TCP е основата на това как голяма част от данните се предават през мрежите. HTTP/1 и HTTP/2 използват TCP, но от версия 3, излязла преди няколко години, това се променя.
HTTP/3 е базиран на новия протокол **QUIC (Quick UDP Internet Connections)**, който използва UDP вместо TCP, за да предложи по-бързо установяване на връзка и подобрена производителност, особено при висока латентност и загуба на пакети. Тенденцията е да се използва все повече UDP.
# ChatGPT
## Understanding Confusion in IP Addressing with Subnet Masks
When working with IP addresses and subnet masks, things often seem clear in **binary form**, because you can easily see which bits belong to the **network** and which are used for **host devices**.

However, confusion arises when converting these addresses into **decimal form**, especially when using subnet masks that **don't align with full octets** (like `/10`, `/13`, etc.). That's because bits for the **network** and the **host** can be **mixed within the same decimal octet**.

For example:

- IP address: `10.10.0.1` → Binary: `00001010.00001010.00000000.00000001`

- Subnet mask: `/10` → Binary: `11111111.11000000.00000000.00000000`


Here:

- The **first 10 bits** define the **network**

- The remaining **22 bits** define the **host/device**

In binary, this separation is easy to understand.  
But in decimal (like `10.10.0.1`), you can't visually tell which part belongs to the network and which to the host, because **bits from both may combine into a single decimal number**.

**🔸 Key Takeaway:**

Always refer to the **binary representation** to understand how IP addresses are divided between **network** and **host** parts. Decimal form is just a human-readable version, but it can obscure that division.
# Bookmarks
Completion: 07.04.2025