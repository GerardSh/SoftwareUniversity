# General
## HTTP Basics
### What is a Protocol
Протокол за комуникация е набор от правила, които определят как две или повече страни си комуникират помежду си.

Това е като общ език, използван за комуникация между машини.
### HTTP Protocol
Протокол за комуникация, базиран на текст. Устройствата в интернет се делят условно на две големи групи - клиенти и сървъри. Обикновено клиентът изпраща някакво запитване, сървърът го обработва и връща отговор. Самото запитване се прави по HTTP протокола. Под HTTP трябва да стои още нещо, например TCP (или QUICK, ако се използва HTTP/3). TCP от своя страна използва IP и така заявката се придвижва надолу по слоевете в ОСИ модела. След това тръгва по обратния път, за да стигне до сървъра. След като заявката бъде обработена, сървърът връща отговор (response), който изминава същия път обратно към клиента.

Общоприложим клиент-сървър протокол, използван за прехвърляне на данни през уеба.

Използва се за прехвърляне на уеб ресурси (HTML файлове, изображения, стилове и др.).

Разчита на URL адреси.

Stateless - всяка HTTP заявка е независима от останалите. Сървърът отговаря на запитването, без да знае кой го пита. Протоколът не поддържа състояние (state), което означава, че всяка заявка се обработва изолирано и не е свързана с предишни запитвания.
Бисквитките и уеб хранилищата могат да преодолеят този проблем, като запазват информация на клиентската страна, но самият HTTP протокол няма вградена концепция за състояние.
Конкретният контекст на HTTP заявката се ограничава до самата заявка, а не до глобален контекст. Например, ако правим калкулатор и клиентът запитва сървъра за изчислението 2 + 2, което е 4, сървърът няма да помни тази операция, когато клиентът по-късно изпрати заявка с +8. Сървърът ще отговори с 8, защото не помни предишния резултат. Това показва, че HTTP е stateless – всяка заявка е самостоятелна и не помни какво е било отговорено миналия път. Затова при последващи запитвания е необходимо да изпращаме целия контекст на заявката, като в примера с калкулатора, за да може сървърът да извърши правилно изчислението.
Трябва да се постараем приложенията ни да се съобразяват с този принцип. Може да се съхранява state, но никога не трябва да бъде на сървъра. Под state се разбира всяка информация, която искаме да използваме между две заявки — например, да запазим резултат от една заявка, който да бъде използван в следващата. Това е state, който протоколът не поддържа, но можем да го добавим, ако решим.

HTTP използва **модел на заявка-отговор**, при който комуникацията винаги се състои от тази двойка – клиентът изпраща заявка, а сървърът връща отговор.

**HTTP request**

```
GET /courses/javascript HTTP/1.1
Host: www.softuni.bg
User-Agent: Mozilla/5.0
<CRLF> // The empty line denotes the end of the request header
```

- В първия ред имаме HTTP метода (`GET`), пътя към ресурса (`/courses/javascript`) и версията на протокола (`HTTP/1.1`).
- Следват **заглавни редове** (headers), всеки на отделен ред.
- Задължително след последния хедър трябва да има **празен ред**, който указва края на хедърите.
- При `GET` заявките **няма тяло**, затова комуникацията спира дотук.

**HTTP response**

```
HTTP/1.1 200 OK
Date: Mon, 5 Jul 2020 13:09:03 GMT
Server: Microsoft-HTTPAPI/2.0
Last-Modified: Mon, 12 Jul 2014 15:33:23 GMT
Content-Length: 54
<CRLF> // The empty line denotes the end of the response header
<html><title>Hello</title>
Welcome to our site</html>
```

- Първият ред съдържа **версията на протокола**, **статус кода** (`200`) и **текстовото описание** (`OK`). Кодът е за машинна обработка, а текстът – за хора.
- Следват хедъри (headers), отново по един на ред.
- Празният ред след последния хедър указва началото на **тялото на отговора**, ако има такова.
- Тялото съдържа съдържанието на отговора (в случая HTML).
## URL - Uniform Resource Locator
```
     http://mysite.com:8080/demo/index.php?id=27&lang=en#slides
|Protocol|     Host   |Port|      Path    | Query string| Fragment
```

URL == форматирания стринг се състои от:

**Network protocol** - (http, ftp, https...) – в повечето случаи се използва HTTP.

**Host or IP address** - (softuni.org, gmail.com, 127.0.0.1, web).

**Port** -(по подразбиране е 80) – цяло число в диапазона [0…65535].

**Path**- (`/forum, /path/index.php`).

**Query string** - (`?id=27&lang=en`). - използва се за да подадем параметри към сървъра. използва се, за да подадем параметри към сървъра.  
В примера искаме не просто да отворим `demo/index.php`, а конкретен запис с идентификатор **27**, и да го видим на **английски език**.
Тези параметри са необходими на сървъра, за да може да обработи заявката правилно и да върне подходящия резултат. Параметрите са във вида **key-value двойки** – `key=value`, а самите двойки се разделят със символа **`&`**.

**Fragment (#slides)** - използва се за навигация към конкретна секция в страницата.

ASP.NET ще парсне URL-а и ще го раздели на отделни части вместо нас, но е важно **ние самите да разбираме всяка от тези части**, за да можем да се ориентираме и да работим правилно с тях в кода си.
### URL Encoding
URL адресите се кодират съгласно **RFC 1738**.

Позволените символи в URL са: `[0-9a-zA-Z]`, както и `$`, `-`, `_`, `.`, `+`, `*`, `'`, `(`, `)`, `,`, `!`.

Всички останали символи се **кодират (escape-ват)** чрез **`%`**, последвано от шестнадесетичния код на символа – това се нарича **URL encoding**.

Пример:

- интервал → `%20` или `+`
- „щ“ → `%D1%89`
- `"` → `%22`
- `#` → `%23`
- `$` → `%24`
- `%` → `%25`
- `&` → `%26`

Пример за кодирана стойност:  
**Наков-爱-SoftUni** → **`%D0%9D%D0%B0%D0%BA%D0%BE%D0%B2-%E7%88%B1-SoftUni`**

Също така, **може да се използва кирилица и други не-ASCII символи директно в URL адреси**, благодарение на поддръжката на **Unicode** и **международни домейни (IDN)**.  
Въпреки това, **вътрешно браузърите и сървърите ще кодират** тези символи в URL с **URL encoding**, за да осигурят съвместимост с протоколите. Например, адресът `https://сайт.бг/страница` ще бъде кодиран като `https://сайт.бг/%D1%81%D0%B0%D0%B9%D1%82.%D0%B1%D0%B3/%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0`
## HTTP Request
### Message
Запитването, изпратено от клиент, се състои от:

- HTTP request line
	- Request method (GET / POST / PUT / DELETE / …)
	- Resource URI (URL)
	- Protocol version

- HTTP request headers
	- Additional parameters

- HTTP request body – (по избор), например полета от форма, изпратени с POST метода

```
<method> <resource> HTTP/<version>
<headers>
(empty line)
<body>
```
### Methods
HTTP дефинира методи, които показват желаното действие върху идентифицирания ресурс.

|Метод|Описание|
|---|---|
|GET|Извлича ресурс|
|POST|Създава / съхранява ресурс|
|PUT|Актуализира (замества) ресурс|
|DELETE|Изтрива (премахва) ресурс|
|PATCH|Частично актуализира ресурс (модифицира)|
|HEAD|Извлича само хедърите на ресурса|

**CRUD (Create, Read, Update, Delete)** са основните операции за работа с постоянни данни, като първите четири HTTP метода съвпадат с тези операции.

Други методи:

- CONNECT
- OPTIONS - Изпраща се за да се провери кои методи (GET, POST, PUT и т.н.) и хедъри са разрешени от сървъра за даден ресурс. Това е полезно в ситуации като CORS (Cross-Origin Resource Sharing), където преди реална заявка се проверява дали сървърът разрешава достъпа от различни източници.
- TRACE
#### GET
**GET** се използва за заявка на данни от определен ресурс.

Пример за HTTP GET заявка:

```
GET /index.html HTTP/1.1                  // HTTP request line
Host: localhost                           // HTTP request headers
<CRLF>
                                          // HTTP request body is empty
```
#### POST
**POST** прехвърля данни в тялото на HTTP заявката.

Пример за HTTP POST заявка:

```
POST /login.html HTTP/1.1                          // HTTP request line
Host: localhost                                    // HTTP request header
Content-Length: 59                                 // HTTP request header
Content-Type: application/x-www-form-urlencoded    // HTTP request header
<CRLF>
username=testUser&password=topSecret               // HTTP request body holds the submitted form data
<CRLF>
```
## HTTP Response
### Message
Отговорът, изпратен от HTTP сървъра, се състои от:

Отговорът, изпратен от HTTP сървъра, се състои от:

- HTTP response status line: Съдържа версия на протокола, статус код и статус фраза.
    - Protocol version: Версия на използвания HTTP протокол (например HTTP/1.1).
    - Status code: Триизмерен код, който показва резултата от обработката на заявката (например 200, 404).
    - Status phrase: Кратко текстово описание на статус кода (например "OK" за 200, "Not Found" за 404).

- Response headers
    - Осигуряват мета данни за върнатия ресурс (например Content-Type, Content-Length).

- Response body
    - Съдържанието на HTTP отговора, което може да бъде данни като HTML, JSON или изображения, в зависимост от заявения ресурс.

```
HTTP/<version> <status code> <status text>
<headers>
(empty line)
<response body – the requested resource>
```
### Status Codes
HTTP кодове за отговор по класове:
- 1xx: информационни (напр. "100 Continue")
- 2xx: успешни (напр. "200 OK", "201 Created")
- 3xx: пренасочвания (напр. "304 Not Modified", "301 Moved Permanently", "302 Found")
- 4xx: грешки на клиента (напр. "400 Bad Request", "404 Not Found", "401 Unauthorized", "409 Conflict")
- 5xx: грешки на сървъра (напр. "500 Internal Server Error", "503 Service Unavailable")

Важно е да се прави семантична разлика в кодовете. Когато сървърът връща статус 204 (No Content), това означава, че заявката е обработена успешно и сървърът е намерил резултат, но няма съдържание за връщане. Например, ако търсим всички потребители, родени на дадена дата, но няма такива, сървърът ще изпрати 204, за да покаже, че операцията е успешна, но няма данни, които да върне.

От друга страна, кодът 404 (Not Found) показва, че заявката е невалидна, защото ресурсът, който клиентът е търсил, не съществува. Например, ако търсим потребител със специфичен идентификатор или URL, който не съществува на сървъра, сървърът ще върне 404, защото не е намерил такъв ресурс. Разликата е, че 204 показва успешна обработка, но без съдържание, докато 404 означава, че търсеният ресурс въобще не съществува.
### Browser Redirection
**HTTP GET заявка към преместен URL**

Следният HTTP отговор със статус код **301 (Moved Permanently)** указва на браузъра, че ресурсът е преместен трайно и трябва да бъде поискан от друг URL.

**Пример за пренасочване от браузър:**

```
GET / HTTP/1.1
Host: http://softuni.org
User-Agent: Gecko/20100115 Firefox/3.6
<CRLF>

HTTP/1.1 301 Moved Permanently
Location: http://softuni.bg
```

В отговора се съдържа заглавие `Location`, което посочва новия адрес на ресурса. Браузърът автоматично следва това пренасочване и изпраща нова заявка към посочения URL.
### Content-Type and Disposition
HTTP заглавието `Content-Type` указва как трябва да се интерпретира съдържанието в тялото на отговора.

**Примери:**

```
Content-Type: text/html; charset=utf-8
```

Отговорът съдържа HTML документ, кодиран в UTF-8.

```
Content-Type: application/pdf
```

Отговорът съдържа PDF файл.

HTTP заглавието `Content-Disposition` определя как браузърът да третира съдържанието — дали да го покаже директно или да предложи изтегляне.

**Пример:**

```
Content-Disposition: attachment; filename="Report-April-2020.pdf"
```

Браузърът ще предложи изтегляне на файл с посоченото име.
## MIME and Media Types
MIME е съкращение от **Multipurpose Internet Mail Extensions**. Първоначално е създадено за разширяване на възможностите на електронната поща, така че освен обикновен текст, да може да се предават и **различни типове съдържание** – като изображения, аудио, видео и прикачени документи.

С помощта на MIME, получателят може да разбере **какъв е типът на съдържанието** и как да го **визуализира правилно**. Например, дали е HTML страница, изображение в JPEG формат или PDF документ. MIME е стандарт за описване на типа на съдържанието, така че приложенията да знаят как да го обработят и визуализират правилно.

Днес MIME типовете (известни още като **Content-Type**) се използват не само в електронната поща, а и **във всички HTTP комуникации** – включително в уеб сайтове, API отговори, браузъри и т.н.

Самият HTTP header `Content-Type` **съдържа MIME типа** на отговора (или заявката), за да каже на клиента какъв е форматът на съдържанието и как да го интерпретира. MIME типът се състои от две части, разделени с `/` като първата обозначава основния тип (напр. `text`, `image`, `application`), а втората — конкретния подтип (напр. `html`, `jpeg`, `json`).

`Content-Disposition` е HTTP header, който указва как браузърът да обработи съдържанието – дали да го **покаже директно**, или **да предложи сваляне като файл**.

**Common MIME Media Types:**

| MIME Type / Subtype | Description  |
| ------------------- | ------------ |
| application/json    | JSON data    |
| image/png           | PNG image    |
| image/gif           | GIF image    |
| text/html           | HTML         |
| text/plain          | Text         |
| text/xml            | XML          |
| video/mp4           | MP4 video    |
| application/pdf     | PDF document |
## Routing
**Web Routing** е механизъм, при който HTTP заявките се насочват към съответния код, който ги обработва.

- Заявките се насочват на базата на HTTP метода и пътя на заявката.
- HTTP заявките се съпоставят със съответните HTTP отговори.
- Пример: маршрутът `/` често се насочва към началната страница на приложението.

С други думи това е mapping между request-a и response-a, как от даден request, да получим даден response.
### Mapping Physical Files
**`RouteTable.Routes.MapPageRoute`** е начин за дефиниране на маршрути в ASP.NET Web Forms. Те определят как HTTP заявки ще бъдат насочвани към конкретни файлове в проекта.

Пример:

|Route Name|Route URL|Physical File Name|
|---|---|---|
|Home|Home/Index|Index.html|
|About|Home/About|About.html|

Route URL - User-friendly URL replacement of the physical file name

```csharp
void RegisterRoutes(RouteCollection routes)
{
 routes.MapPageRoute("Home","Home/Index","/wwwroot/Home/Index.html");
 routes.MapPageRoute("About","Home/About","/wwwroot/Home/About.html");
}
```

Тези маршрути указват, че когато потребителят посети `Home/Index`, ще се зареди физическият файл `Index.html`, а когато посети `Home/About`, ще се зареди `About.html`.
### HTTP Tools for Developers - Browser
Без значение от точния браузър, инструментите изглеждат почти еднакво и предлагат възможности за дебъгване и анализиране на HTTP заявки и отговори. Тези инструменти обикновено се намират в "Developer Tools" или "Inspect" менюто на браузъра.

Сред основните функции, които се предоставят, са:

- **Network**: Позволява наблюдение на всички HTTP заявки и отговори, които се извършват по време на зареждането на уеб страница, включително детайли като статус кодове, време за зареждане, заглавия на заявките и отговорите.
    
- **Console**: Използва се за преглед на грешки и съобщения от JavaScript кода, както и за отпечатване на различни логове от клиентската страна.
    
- **Elements**: Позволява преглед на HTML структурата на страницата и манипулиране с нея в реално време.
    
- **Application**: Разглеждане на ресурсите, които се съхраняват на клиентската страна, като Local Storage, Cookies и други, свързани с текущата уеб сесия.
## Web Server
Компютърна система, която обработва заявки чрез HTTP – основният мрежов протокол.

Той изчаква входящи HTTP заявки от клиенти (обикновено уеб браузъри), обработва ги и връща подходящ HTTP отговор, който често съдържа HTML страници, данни (като JSON), изображения или друго съдържание.
## Web Server Work Model
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250409230625.png)
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250409231120.png)

Технологията която се ползва в нашия случай е .NET и ASP.NET
## HTML Forms - Action Attribute
Когато искаме да изпратим данни, да създадем някакъв ресурс на сървъра, обикновено се използва форма.

```html
<form action="home.html">
  <input type="submit" value="Go to homepage"/>
</form>
```
### Method Attribute
Можем да подадем метод на формата в HTML, който определя как заявката ще бъде изпратена към сървъра – чрез `GET` или `POST`.

```html
<form action="/" method="get">
  Name: <input type="text" name="name">
  <br>
  <input type="submit" value="Submit">
</form>
```

Този HTML код създава форма, която изпраща въведеното име чрез HTTP метода **GET**. Когато потребителят натисне бутона **Submit**, стойността от полето `name` се добавя към URL адреса, като например:

```
http://localhost/?name=Pesho
```

Ако използваме метода **POST**, същата информация ще се предаде в **тялото на заявката**, а не в адресния ред. Така изглежда примерна POST заявка:

```
POST /index.html HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

name=Pesho
```

Използването на `POST` е по-подходящо, когато се изпращат по-чувствителни данни (например пароли или лична информация), тъй като те не се виждат в URL адреса и не се записват в историята на браузъра.
## URL Encoded Form Data - Example
Този пример показва как HTML форма с метод `POST` изпраща данни към сървъра:

```html
<form action="/" method="post">
  Name: <input type="text" name="name"/> <br/>
  Age: <input type="text" name="age"/> <br/>
  <input type="submit" />
</form>
```

Когато потребителят попълни формата (например с име "Maria Smith" и възраст "19") и натисне бутона за изпращане, браузърът изпраща HTTP POST заявка към сървъра. Заявката съдържа следните елементи:

```
POST http://localhost/cgi-bin/index.cgi HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 23

name=Maria+Smith&age=19
```

**Коментар:**

- `POST` методът предава данните в тялото на заявката, а не в URL адреса. Това е подходящо за предаване на по-големи обеми от информация или чувствителни данни.
- `Content-Type: application/x-www-form-urlencoded` указва, че данните са форматирани като двойки ключ-стойност, кодирани за предаване по HTTP (например интервалите се заменят с `+`, специални символи се кодират).
- Тялото съдържа въведените от потребителя стойности: `name=Maria+Smith&age=19`.

Такъв подход е класически за уеб формуляри – когато изпращаме информация към сървъра, който след това може да я обработи, запише или върне отговор на базата на въведеното.
Важно е да се отбележи, че в примера не се използва поддръжка за **file upload** (качване на файлове). За да може форма да приема файлове, е необходимо да се добави атрибут `enctype="multipart/form-data"` към тагът `<form>`. Това позволява на браузъра да изпрати файловете в специален формат, който сървърът може да разбере и обработи.
## GET vs POST Method
**POST:**

- Стойностите се намират в тялото на съобщението.
- Няма ограничение за дължината на данните.
- Трудно се кешира.
- Поддържа различни типове данни.
- Параметрите не се запазват в историята на браузъра.
- Резултатите не могат да бъдат добавени в отметки (bookmarked).

**GET:**

- Стойностите се намират в URL адреса.
- Има ограничение за дължината на данните (обикновено около 255 символа).
- Често се кешира.
- Поддържа само низови (string) типове данни.
- Параметрите се запазват в историята на браузъра.
- Резултатите могат да бъдат добавени в отметки (bookmarked).
## HTTP/2
**HTTP/2** (първоначално наречен HTTP/2.0) е основна ревизия на HTTP мрежовия протокол, използван в Световната мрежа.

- Поддържа се от повечето популярни уеб браузъри (Chrome, Mozilla, Opera и други).
- Бърз и оптимизиран.
- Отговаря на изискванията на съвременните уеб технологии.
- Напълно съвместим с по-старите версии (backwards-compatible).

**Какво е HTTP/2?**

- Към април 2023 г. 40% от всички уебсайтове поддържат HTTP/2 (според статистики на W3Techs).

**HTTP/2** има за цел да премахне нуждата от поддържане на сложни сървърни инфраструктури за постигане на добра производителност.

- **HTTP/2 комуникира чрез бинарни данни (data frames)**: Връзките и данните се изпращат в малки, структурирани пакети, което подобрява производителността и ефективността при обработката на заявките.

Основни нововъведения в HTTP/2:

- **HTTP/2 Multiplexing (Мултиплексиране)**: Позволява изпращането на множество заявки и отговори по една и съща връзка, без да се налага тя да бъде затворена или отново отворена за всяка нова заявка. Това намалява латентността и ускорява комуникацията.

- **HTTP/2 Header Compression (Компресия на заглавията)**: Използва механизъм за компресиране на HTTP заглавията, което намалява размера на данните, които трябва да бъдат изпратени между клиента и сървъра, и намалява времето за обработка.

- **HTTP/2 Server Push (Сървърно натискане)**: Сървърът може проактивно да изпраща ресурси към клиента (като CSS, JavaScript файлове) още преди те да бъдат поискани, за да намали времето за зареждане на страницата.
### Multiplexing
Изкуството на обработка на множество потоци през едно TCP свързване

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250409234616.png)
### Header Compression
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250409235104.png)

HTTP/2 поддържа таблица с HTTP заглавия през различни заявки

Драстично оптимизира комуникацията  
Процесът всъщност е дублиране, а не компресия.
### Server Push
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250409235028.png)

HTTP/2 Server Push == процесът на изпращане на ресурси към клиентите, без те да ги изискват.
## HTTP/3
HTTP/3 е нов стандарт в процес на разработка, който ще влияе на начина, по който уеб браузърите и сървърите комуникират.

- Към април 2023 г. HTTP/3 се поддържа от 26% от уеб браузърите (според статистика на W3Techs).
- Използва протокола QUIC.

Значителни подобрения за потребителското изживяване:

- Намаляване на ефектите от загуба на пакети.
- Решение на проблема с бавното представяне, например когато смартфонът преминава от Wi-Fi към мобилни данни.
- Подобрена производителност, надеждност и сигурност.
# Misc
# ChatGPT
# Bookmarks
Completion: 09.04.2025